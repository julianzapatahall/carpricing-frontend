Object.defineProperty(exports, '__esModule', { value: true });

class Account {
    profile() {
        return this.fetcher(`/account`);
    }
    email() {
        return this.fetcher(`/account/email`);
    }
    preferences() {
        return this.fetcher(`/account/preferences`);
    }
    kidMode({ enable } = {}) {
        return this.fetcher(`/account/kid?v=${enable}`, enable !== undefined);
    }
    challenges() {
        return this.fetcher(`/challenge`);
    }
    ongoing({ limit } = {}) {
        return this.fetcher(`/account/playing?nb=${limit}`);
    }
    constructor(fetcher){
        this.fetcher = fetcher;
    }
}

class Board {
    events() {
        return this.fetcher(`/stream/event`);
    }
    // TODO: seek()
    // public seek({
    //   mode,
    //   options: {
    //     rated = false,
    //     variant = 'standard',
    //     color = 'random',
    //     ratingRange = '',
    //     time,
    //     increment,
    //     days,
    //   },
    // }: BoardSeek) {
    //   const ratedString = new Boolean(rated).toString()
    //   if (mode === 'realtime' && time && increment) {
    //     return fetch(`${LICHESS_API_URL}/board/seek`, {
    //       headers: this.headers,
    //       method: 'POST',
    //       body: new URLSearchParams({
    //         rated: ratedString,
    //         variant,
    //         color,
    //         ratingRange,
    //         time: time.toString(),
    //         increment: increment.toString(),
    //       }),
    //     })
    //   }
    //   if (mode === 'correspondence' && days) {
    //     return fetch(`${LICHESS_API_URL}/board/seek`, {
    //       headers: this.headers,
    //       method: 'POST',
    //       body: new URLSearchParams({
    //         rated: ratedString,
    //         variant,
    //         color,
    //         ratingRange,
    //         days: days.toString(),
    //       }),
    //     })
    //   }
    //   return undefined
    // }
    stream({ gameId }) {
        return this.fetcher(`/board/game/stream/${gameId}`);
    }
    move({ gameId, move }) {
        const offerDraw = move === 'draw';
        return this.fetcher(`/board/game/${gameId}/move/${move}?offeringDraw=${offerDraw}`, true);
    }
    chat({ gameId, room, text }) {
        const isSendingChat = !!(room && text);
        return this.fetcher(`/board/game/${gameId}/chat`, isSendingChat, isSendingChat ? new URLSearchParams({
            room,
            text
        }) : undefined);
    }
    abort({ gameId }) {
        return this.fetcher(`/board/game/${gameId}/abort`, true);
    }
    resign({ gameId }) {
        return this.fetcher(`/board/game/${gameId}/resign`, true);
    }
    draw({ gameId, accept }) {
        return this.fetcher(`/board/game/${gameId}/draw/${accept}`, true);
    }
    takeback({ gameId, accept }) {
        return this.fetcher(`/board/game/${gameId}/takeback/${accept}`, true);
    }
    victory({ gameId }) {
        return this.fetcher(`/board/game/${gameId}/claim-victory`, true);
    }
    berserk({ gameId }) {
        return this.fetcher(`/board/game/${gameId}/berserk`, true);
    }
    constructor(fetcher){
        this.fetcher = fetcher;
    }
}

class Challenge {
    create({ username }) {
        return this.fetcher(`/challenge/${username}`, true);
    }
    accept({ challengeId }) {
        return this.fetcher(`/challenge/${challengeId}/accept`, true);
    }
    decline({ challengeId }) {
        return this.fetcher(`/challenge/${challengeId}/decline`, true);
    }
    cancel({ challengeId }) {
        return this.fetcher(`/challenge/${challengeId}/cancel`, true);
    }
    // TODO: refactor
    ai({ level, clockLimit, clockIncrement, days, color, variant, fen }) {
        const params = new URLSearchParams();
        if (level) params.append('level', level.toString());
        if (clockLimit) params.append('clock.limit', clockLimit.toString());
        if (clockIncrement) params.append('clock.increment', clockIncrement.toString());
        if (days) params.append('days', days.toString());
        if (color) params.append('color', color);
        if (variant) params.append('variant', variant);
        if (fen) params.append('fen', fen);
        return this.fetcher(`/challenge/ai`, true, params);
    }
    // TODO: refactor
    open({ rated, clockLimit, clockIncrement, days, color, variant, fen, name, rules, users, expiresAt }) {
        const params = new URLSearchParams();
        if (rated) params.append('rated', rated.toString());
        if (clockLimit) params.append('clock.limit', clockLimit.toString());
        if (clockIncrement !== undefined) params.append('clock.increment', clockIncrement.toString());
        if (days) params.append('days', days.toString());
        if (color) params.append('color', color);
        if (variant) params.append('variant', variant);
        if (fen) params.append('fen', fen);
        if (name) params.append('name', name);
        if (rules) params.append('rules', rules);
        if (users) {
            if (Array.isArray(users)) users = users.join(',');
            users = users.replace(/\s/g, '');
            params.append('users', users.toString());
        }
        if (expiresAt) params.append('expiresAt', expiresAt.toString());
        return this.fetcher(`/challenge/open`, true, params);
    }
    start({ gameId, token1, token2 }) {
        return this.fetcher(`/challenge/${gameId}/start-clocks?token1=${token1}&token2=${token2}`, true);
    }
    grant({ gameId, seconds }) {
        return this.fetcher(`/round/${gameId}/add-time/${seconds}`, true);
    }
    admin({ users, description }) {
        const params = new URLSearchParams();
        if (users) {
            if (Array.isArray(users)) users = users.join(',');
            users = users.replace(/\s/g, '');
            params.append('users', users.toString());
        }
        if (description) params.append('description', description);
        return this.fetcher(`/challenge/admin`, true, params);
    }
    constructor(fetcher){
        this.fetcher = fetcher;
    }
}

class LeaderBoard {
    info({ nb, perfType }) {
        return this.fetcher(`/player/top/${nb}/${perfType}`);
    }
    // TODO: define perfTypes
    topTens() {
        return this.fetcher(`/player`);
    }
    constructor(fetcher){
        this.fetcher = fetcher;
    }
}
class Users {
    info({ ids }) {
        if (Array.isArray(ids)) ids = ids.join(',');
        ids = ids.replace(/\s/g, '');
        return this.fetcher(`/users`, true, ids);
    }
    status({ ids }) {
        if (Array.isArray(ids)) ids = ids.join(',');
        ids = ids.replace(/\s/g, '');
        return this.fetcher(`/users/status?ids=${ids}`);
    }
    crosstable({ user1, user2, matchup = false }) {
        return this.fetcher(`/crosstable/${user1}/${user2}?matchup=${matchup}`);
    }
    streaming() {
        return this.fetcher(`/streamer/live`);
    }
    constructor(fetcher){
        this.fetcher = fetcher;
        this.leaderboard = new LeaderBoard(this.fetcher);
    }
}
class User {
    info({ username }) {
        return this.fetcher(`/user/${username}`);
    }
    history({ username }) {
        return this.fetcher(`/user/${username}/rating-history`);
    }
    performance({ username, perfType }) {
        return this.fetcher(`/user/${username}/perf/${perfType}`);
    }
    activity({ username }) {
        return this.fetcher(`/user/${username}/activity`);
    }
    autocomplete({ term, details = false, friendPrior = false }) {
        return this.fetcher(`/player/autocomplete?term=${term}&object=${details}&friend=${friendPrior}`);
    }
    note({ username, text }) {
        const hasText = typeof text === 'string' && text.length > 0;
        return this.fetcher(`/user/${username}/note`, hasText, hasText ? new URLSearchParams({
            text
        }) : undefined);
    }
    follow({ username }) {
        return this.fetcher(`/rel/follow/${username}`, true);
    }
    unfollow({ username }) {
        return this.fetcher(`/rel/unfollow/${username}`, true);
    }
    constructor(fetcher){
        this.fetcher = fetcher;
    }
}

const LICHESS_API_URL = `https://lichess.${process.env.NODE_ENV === 'test' ? 'dev' : 'org'}/api`;

function asyncGeneratorStep(gen, resolve, reject, _next, _throw, key, arg) {
    try {
        var info = gen[key](arg);
        var value = info.value;
    } catch (error) {
        reject(error);
        return;
    }
    if (info.done) {
        resolve(value);
    } else {
        Promise.resolve(value).then(_next, _throw);
    }
}
function _async_to_generator(fn) {
    return function() {
        var self = this, args = arguments;
        return new Promise(function(resolve, reject) {
            var gen = fn.apply(self, args);
            function _next(value) {
                asyncGeneratorStep(gen, resolve, reject, _next, _throw, "next", value);
            }
            function _throw(err) {
                asyncGeneratorStep(gen, resolve, reject, _next, _throw, "throw", err);
            }
            _next(undefined);
        });
    };
}
function fetcher(_) {
    return _fetcher.apply(this, arguments);
}
function _fetcher() {
    _fetcher = _async_to_generator(function*({ endpoint, token, post, body }) {
        return (yield fetch(`${LICHESS_API_URL}${endpoint}`, {
            headers: {
                Authorization: `Bearer ${token}`
            },
            method: post ? 'POST' : 'GET',
            body
        })).json();
    });
    return _fetcher.apply(this, arguments);
}

class Equine {
    // ...v2 API
    // public analysis: Analysis
    // // TODO: different API endpoint
    // // public message: Message
    // public simuls: Simuls
    // public tv: TV
    // public bot: Bot
    constructor(token){
        this.token = token;
        this.fetcher = (endpoint, post, body)=>fetcher({
                endpoint,
                token: this.token,
                post,
                body
            });
        // v1 API
        this.account = new Account(this.fetcher);
        this.board = new Board(this.fetcher);
        this.challenge = new Challenge(this.fetcher);
        this.user = new User(this.fetcher);
        this.users = new Users(this.fetcher);
    // ...v2 API
    // this.analysis = new Analysis(this.fetcher)
    // // TODO: different API endpoint
    // // this.message = new Message(this.fetcher)
    // this.simuls = new Simuls(this.fetcher)
    // this.tv = new TV(this.fetcher)
    // this.bot = new Bot(this.fetcher)
    }
}

exports.Equine = Equine;
