{"version":3,"file":"danfo.js","sourceRoot":"","sources":["__helpers/typescript:assign.js","__helpers/typescript:spreadArray.js","__helpers/typescript:awaiter.js","__helpers/typescript:generator.js","src/browser/startMain.ts","src/browser/startWorker.ts","src/build/bundle/codeBundler.ts","src/build/code/transforms/convertAmd.ts","src/build/code/transforms/hoistHelpers.ts","src/build/code/transforms/keywords.ts","src/build/code/codeBuilder.ts","src/build/code/findDependencies.ts","src/build/code/importTypescript.ts","src/build/code/keyCache.ts","src/build/code/preciseScriptSnapshot.ts","src/build/code/syntaxPredicates.ts","src/build/css/cssBuilder.ts","src/build/html/htmlBuilder.ts","src/build/SourceFileOrSpan.ts","src/build/getBaseName.ts","src/build/populateSourceStructure.ts","src/build/projectBuilder.ts","src/node/scaffold/performScaffold.ts","src/node/server/runServer.ts","src/node/watchFileSystem/createFS.ts","src/node/worker/runWorker.ts","src/node/bootNode.ts","src/node/colors.ts","src/node/formatBuildError.ts","src/node/helpText.ts","src/node/startBrowser.ts","src/parsing/cmdline/derivePort.ts","src/parsing/cmdline/parseCmdline.ts","src/parsing/sourcemap/combineMappings.ts","src/parsing/sourcemap/concatenate.ts","src/parsing/sourcemap/reader.ts","src/parsing/sourcemap/vlq.ts","src/parsing/sourcemap/writer.ts","src/parsing/atob.ts","src/parsing/decodeEntities.ts","src/parsing/lineMap.ts","src/parsing/parseHTML.ts","src/wscript/bootWScript.ts","src/wscript/findNode.ts","src/wscript/shell.ts","src/xlast/versionStr.ts","src/xlast/xrun.ts","src/defineAmd.js"],"names":[],"mappings":"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","sourcesContent":["\n            var __assign = (this && this.__assign) || function () {\n                __assign = Object.assign || function(t) {\n                    for (var s, i = 1, n = arguments.length; i < n; i++) {\n                        s = arguments[i];\n                        for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))\n                            t[p] = s[p];\n                    }\n                    return t;\n                };\n                return __assign.apply(this, arguments);\n            };","\n            var __spreadArray = (this && this.__spreadArray) || function (to, from, pack) {\n                if (pack || arguments.length === 2) for (var i = 0, l = from.length, ar; i < l; i++) {\n                    if (ar || !(i in from)) {\n                        if (!ar) ar = Array.prototype.slice.call(from, 0, i);\n                        ar[i] = from[i];\n                    }\n                }\n                return to.concat(ar || Array.prototype.slice.call(from));\n            };","\n            var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\n                function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n                return new (P || (P = Promise))(function (resolve, reject) {\n                    function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n                    function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n                    function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n                    step((generator = generator.apply(thisArg, _arguments || [])).next());\n                });\n            };","\n            var __generator = (this && this.__generator) || function (thisArg, body) {\n                var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;\n                return g = { next: verb(0), \"throw\": verb(1), \"return\": verb(2) }, typeof Symbol === \"function\" && (g[Symbol.iterator] = function() { return this; }), g;\n                function verb(n) { return function (v) { return step([n, v]); }; }\n                function step(op) {\n                    if (f) throw new TypeError(\"Generator is already executing.\");\n                    while (g && (g = 0, op[0] && (_ = 0)), _) try {\n                        if (f = 1, y && (t = op[0] & 2 ? y[\"return\"] : op[0] ? y[\"throw\"] || ((t = y[\"return\"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;\n                        if (y = 0, t) op = [op[0] & 2, t.value];\n                        switch (op[0]) {\n                            case 0: case 1: t = op; break;\n                            case 4: _.label++; return { value: op[1], done: false };\n                            case 5: _.label++; y = op[1]; op = [0]; continue;\n                            case 7: op = _.ops.pop(); _.trys.pop(); continue;\n                            default:\n                                if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }\n                                if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }\n                                if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }\n                                if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }\n                                if (t[2]) _.ops.pop();\n                                _.trys.pop(); continue;\n                        }\n                        op = body.call(thisArg, _);\n                    } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }\n                    if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };\n                }\n            };","namespace danfo.browser {\r\n\r\n  export function startMain() {\r\n  }\r\n}","namespace danfo.browser {\r\n\r\n  export function startWorker() {\r\n    \r\n  }\r\n}","namespace danfo.build.bundle {\r\n\r\n  export function codeBundler(options: codeBundler.Options): Bundler {\r\n\r\n    const fileSystem = options.fileSystem;\r\n\r\n    const codeBuilder = code.codeBuilder({\r\n      fileSystem,\r\n      precachedFixedSource: options.precachedFixedSource\r\n    });\r\n\r\n    return {\r\n      build: runBuild\r\n    };\r\n\r\n    function runBuild(inputs: BundleInputs): BundleResult {\r\n\r\n      const resolvedProjectDirWithSlash = inputs.resolvedProjectDir.charCodeAt(inputs.resolvedProjectDir.length - 1) === CharCodes.Slash ? inputs.resolvedProjectDir : inputs.resolvedProjectDir + '/';\r\n      let outputFile = inputs.outputFile;\r\n\r\n      const buildResults = codeBuilder.build({\r\n        resolvedProjectDir: inputs.resolvedProjectDir,\r\n        sources: inputs.sources,\r\n        handleSettings\r\n      });\r\n\r\n      if (!outputFile) {\r\n        if (inputs.sources.length === 1)\r\n          outputFile = resolvedProjectDirWithSlash + 'dist/' + getBaseName(inputs.sources[0].resolvedPath);\r\n        else\r\n          outputFile = resolvedProjectDirWithSlash + 'dist/index.js';\r\n      }\r\n      else {\r\n        outputFile = fileSystem.resolvePath(resolvedProjectDirWithSlash, outputFile);\r\n        if (fileSystem.stat(outputFile)?.isDirectory)\r\n          outputFile = outputFile + '/index.js';\r\n      }\r\n\r\n      const concatenated = danfo.parsing.sourcemap.concatenate(\r\n        { fileName: getBaseName(outputFile) },\r\n        buildResults.emits.map(em => {\r\n          return {\r\n            ...em,\r\n            resolvePath: path => path.replace(/\\\\/g, '')\r\n          };\r\n        }));\r\n      \r\n      return {\r\n        outputFile,\r\n        output: typeof concatenated === 'string' ? concatenated : concatenated.output,\r\n        sourcemap: typeof concatenated === 'string' ? void 0 : concatenated.sourcemap,\r\n        errors: buildResults.errors,\r\n        imports: buildResults.imports\r\n      };\r\n\r\n      function handleSettings(settings: typescript.CompilerOptions): typescript.CompilerOptions {\r\n        if (typeof outputFile === 'undefined') {\r\n          if (settings.out || settings.outFile) {\r\n            outputFile = settings.out || settings.outFile;\r\n          }\r\n          else if (settings.outDir) {\r\n            outputFile = fileSystem.resolvePath(resolvedProjectDirWithSlash, settings.outDir + '/index.js');\r\n          }\r\n        }\r\n\r\n        if (inputs.outputDir && !settings.outDir) {\r\n          return {\r\n            ...settings,\r\n            outFile: void 0,\r\n            out: void 0,\r\n            outDir: inputs.outputDir\r\n          };\r\n        }\r\n        else {\r\n          return settings;\r\n        }\r\n      }\r\n\r\n    }\r\n  }\r\n\r\n  export namespace codeBundler {\r\n\r\n    const regex_typeScriptFileExtension = /\\.(ts|tsx)$/i;\r\n    const regex_jsonFileExtension = /\\.json$/i;\r\n\r\n    export function hasTypeScriptFileExtension(file: string) {\r\n      return regex_typeScriptFileExtension.test(file);\r\n    }\r\n\r\n    export function hasJsonFileExtension(file: string) {\r\n      return regex_jsonFileExtension.test(file);\r\n    }\r\n\r\n  }\r\n}","namespace danfo.build.code {\r\n  export declare namespace convertAmd {\r\n\r\n    type Options = {\r\n      ts: typeof import('typescript');\r\n      generateModuleName(moduleFileName: string): string;\r\n      resolveModuleName(sourceFileName: string, moduleFileName: string): string;\r\n    } &\r\n      ({ program: typescript.Program; checker?: typescript.TypeChecker; }\r\n        | { program?: typescript.Program; checker: typescript.TypeChecker });\r\n\r\n    type ModuleImportsExports = {\r\n      moduleName: string;\r\n      importedBy?: string[];\r\n      exportedBy?: string[];\r\n    }\r\n  }\r\n\r\n\r\n  export function convertAmd({ ts, program, checker, generateModuleName, resolveModuleName }: convertAmd.Options) {\r\n    const typeChecker = checker || program!.getTypeChecker();\r\n\r\n    const defines: { sourceFile: typescript.SourceFile, amd: AmdDefineCall }[] = [];\r\n    const modulesByName: { [moduleName: string]: convertAmd.ModuleImportsExports } = {};\r\n    const modules: convertAmd.ModuleImportsExports[] = [];\r\n\r\n    return {\r\n      transform,\r\n      defines,\r\n      modules\r\n    };\r\n\r\n    function transform(context: typescript.TransformationContext) {\r\n\r\n      return transformSourceFile;\r\n\r\n      function transformSourceFile(sourceFileNode: typescript.SourceFile): typescript.SourceFile {\r\n        const { factory } = context;\r\n        let updatedStatements: typescript.Statement[] | undefined;\r\n        for (let i = 0; i < sourceFileNode.statements.length; i++) {\r\n          let statement = sourceFileNode.statements[i];\r\n\r\n          if (ts.isExpressionStatement(statement)) {\r\n\r\n            const amd = isAmdDefineCall(statement.expression, ts, typeChecker);\r\n            if (amd) {\r\n              defines.push({\r\n                sourceFile: sourceFileNode,\r\n                amd\r\n              });\r\n\r\n              const moduleName = generateModuleName(sourceFileNode.fileName);\r\n              let mod = modulesByName[moduleName];\r\n              if (!mod) {\r\n                mod = modulesByName[moduleName] = { moduleName };\r\n                modules.push(mod);\r\n              }\r\n\r\n              statement = transformRequireCalls(statement, amd, moduleName) as typescript.ExpressionStatement || statement;\r\n\r\n              const exportedBy = (mod.exportedBy || (mod.exportedBy = []));\r\n              if (exportedBy.indexOf(sourceFileNode.fileName) <= 0)\r\n                exportedBy.push(sourceFileNode.fileName);\r\n\r\n              const importsArrayArgument = amd.node.arguments[0];\r\n              const updatedImportsArrayArgument = !importsArrayArgument || !ts.isArrayLiteralExpression(importsArrayArgument) ?\r\n                void 0 :\r\n                factory.updateArrayLiteralExpression(\r\n                  importsArrayArgument,\r\n                  importsArrayArgument.elements.map(\r\n                    el => {\r\n                      const moduleName = getPossibleStringLiteralValues(el, ts, typeChecker);\r\n                      if (typeof moduleName === 'string' && moduleName !== 'require' && moduleName !== 'exports') {\r\n                        const resolvedModuleName = resolveModuleName(sourceFileNode.fileName, moduleName);\r\n                        if (resolvedModuleName) {\r\n                          let mod = modulesByName[resolvedModuleName];\r\n                          if (!mod) {\r\n                            mod = modulesByName[resolvedModuleName] = { moduleName: resolvedModuleName };\r\n                            modules.push(mod);\r\n                          }\r\n\r\n                          const importedBy = (mod.importedBy || (mod.importedBy = []));\r\n                          if (importedBy.indexOf(sourceFileNode.fileName) <= 0)\r\n                            importedBy.push(sourceFileNode.fileName);\r\n                        }\r\n\r\n                        if (resolvedModuleName && resolvedModuleName !== moduleName)\r\n                          return el;\r\n                      }\r\n\r\n                      return el;\r\n                    }\r\n                  ));\r\n\r\n              statement = factory.updateExpressionStatement(\r\n                statement as typescript.ExpressionStatement,\r\n                factory.updateCallExpression(\r\n                  amd.node,\r\n                  amd.node.expression,\r\n                  amd.node.typeArguments,\r\n                  [\r\n                    factory.createStringLiteral(moduleName),\r\n                    updatedImportsArrayArgument || importsArrayArgument,\r\n                    ...amd.node.arguments.slice(1)\r\n                  ]\r\n                ));\r\n            }\r\n          }\r\n\r\n          if (statement === sourceFileNode.statements[i]) {\r\n            statement = transformRequireCalls(statement) as typescript.Statement || statement;\r\n          }\r\n\r\n          if (statement !== sourceFileNode.statements[i]) {\r\n            if (!updatedStatements) updatedStatements = [];\r\n            updatedStatements[i] = statement;\r\n          }\r\n        }\r\n\r\n        if (updatedStatements) {\r\n          for (var i = 0; i < sourceFileNode.statements.length; i++) {\r\n            if (!updatedStatements[i])\r\n              updatedStatements[i] = sourceFileNode.statements[i];\r\n          }\r\n\r\n          return factory.updateSourceFile(\r\n            sourceFileNode,\r\n            updatedStatements);\r\n        }\r\n        else {\r\n          return sourceFileNode;\r\n        }\r\n\r\n        function transformRequireCalls(node: typescript.Node, amd?: AmdDefineCall, moduleName?: string) {\r\n          let amdDefineImportSymbols: import('typescript').Symbol[] | undefined;\r\n          const result = ts.visitEachChild(\r\n            node,\r\n            transformNode,\r\n            context);\r\n\r\n          return result;\r\n\r\n          function transformNode(node: typescript.Node): typescript.Node | undefined {\r\n            if (isRequireCall(node)) {\r\n              const moduleName = getPossibleStringLiteralValues(node.arguments[0], ts, typeChecker);\r\n              if (typeof moduleName === 'string') {\r\n                const resolvedModuleName = resolveModuleName(sourceFileNode.fileName, moduleName);\r\n                if (resolvedModuleName) {\r\n                  let mod = modulesByName[resolvedModuleName];\r\n                  if (!mod) {\r\n                    mod = modulesByName[resolvedModuleName] = { moduleName: resolvedModuleName };\r\n                    modules.push(mod);\r\n                  }\r\n\r\n                  const importedBy = (mod.importedBy || (mod.importedBy = []));\r\n                  if (importedBy.indexOf(sourceFileNode.fileName) <= 0)\r\n                    importedBy.push(sourceFileNode.fileName);\r\n                }\r\n\r\n\r\n                if (resolvedModuleName && resolvedModuleName !== moduleName)\r\n                  return factory.updateCallExpression(\r\n                    node,\r\n                    node.expression,\r\n                    node.typeArguments,\r\n                    [factory.createStringLiteral(resolvedModuleName)]);\r\n              }\r\n            }\r\n\r\n            return ts.visitEachChild(node, transformNode, context);\r\n          }\r\n\r\n          function isRequireCall(node: typescript.Node): node is typescript.CallExpression {\r\n            if (ts.isCallExpression(node)\r\n              && node.arguments.length === 1) {\r\n\r\n              if (isGlobalName(node.expression, 'require', ts, typeChecker)) {\r\n                return true;\r\n              }\r\n              else if (amd &&\r\n                ts.isIdentifier(node.expression)\r\n                && getPossibleNameString(node.expression, ts) === 'require') {\r\n                const requireSymbol = typeChecker.getSymbolAtLocation(node.expression);\r\n                if (!requireSymbol) return true; // undefined means global\r\n\r\n                if (!amdDefineImportSymbols) {\r\n                  amdDefineImportSymbols = [];\r\n                  const signatures = typeChecker.getSignaturesOfType(typeChecker.getTypeAtLocation(amd.moduleBodyArgument), ts.SignatureKind.Call);\r\n                  for (const sig of signatures)\r\n                    amdDefineImportSymbols = sig.getParameters();\r\n                }\r\n\r\n                if (amdDefineImportSymbols.indexOf(requireSymbol) >= 0)\r\n                  return true;\r\n              }\r\n            }\r\n\r\n            return false;\r\n          }\r\n        }\r\n      }\r\n    }\r\n  }\r\n}","namespace danfo.build.code {\r\n\r\n  export declare namespace hoistHelpers {\r\n    type Options = {\r\n      ts: typeof import('typescript')\r\n    }\r\n  }\r\n\r\n  export function hoistHelpers(options: hoistHelpers.Options) {\r\n\r\n    var emitHelpers: { fileName: string, emitHelper: typescript.EmitHelper }[] = [];\r\n\r\n    return {\r\n      transform: transform,\r\n      emitHelpers\r\n    };\r\n\r\n    function transform(context: typescript.TransformationContext) {\r\n\r\n      return transformSourceFile;\r\n\r\n      function transformSourceFile(sourceFileNode: typescript.SourceFile): typescript.SourceFile {\r\n\r\n        let fileNodeEmitHelpers = options.ts.getEmitHelpers(sourceFileNode);\r\n        if (fileNodeEmitHelpers) {\r\n          // removing will affect this same array instance,\r\n          // so iterate through a copy instead\r\n          fileNodeEmitHelpers = fileNodeEmitHelpers.slice();\r\n\r\n          for (const h of fileNodeEmitHelpers) {\r\n            emitHelpers.push({ fileName: sourceFileNode.fileName, emitHelper: h });\r\n            options.ts.removeEmitHelper(sourceFileNode, h);\r\n          }\r\n        }\r\n\r\n        return sourceFileNode;\r\n      }\r\n    }\r\n  }\r\n}","namespace danfo.build.code.keywords {\r\n\r\n  /**\r\n   * A custom transformer supposed to manage the use of what's ES3 keywords but allowed in ES5.\r\n   */\r\n  export function transformKeywords(context: typescript.TransformationContext, es3Keywords: string[], ts: typeof import('typescript')) {\r\n\r\n    return transformSourceFile;\r\n\r\n    function transformSourceFile(sourceFileNode: typescript.SourceFile): typescript.SourceFile {\r\n      const { factory } = context;\r\n      const transformed = ts.visitEachChild(sourceFileNode, visitNodeReplaceES3Keywords, context);\r\n      if (!transformed) {\r\n        return sourceFileNode;\r\n      }\r\n      else {\r\n        return transformed;\r\n      }\r\n\r\n      function visitNodeReplaceES3Keywords(node: typescript.Node): typescript.Node | undefined {\r\n        const nestedReplacements = ts.visitEachChild(node, visitNodeReplaceES3Keywords, context);\r\n        node = nestedReplacements || node;\r\n\r\n        if (ts.isPropertyAccessExpression(node) && ts.isIdentifier(node.name) && es3Keywords.indexOf(node.name.text) >= 0) {\r\n          const replacement = factory.createElementAccessExpression(\r\n            node.expression,\r\n            factory.createStringLiteral(node.name.text));\r\n\r\n          const mappedReplacement = ts.setTextRange(replacement, node);\r\n          return mappedReplacement;\r\n        }\r\n        else if (ts.isPropertyAccessExpression(node) && ts.isIdentifier(node.name) && es3Keywords.indexOf(node.name.text) >= 0) {\r\n          const replacement = factory.createPropertyAssignment(\r\n            node.name.text,\r\n            node.expression);\r\n\r\n          const mappedReplacement = ts.setTextRange(replacement, node);\r\n          return mappedReplacement;\r\n        }\r\n\r\n        return nestedReplacements;\r\n      }\r\n    }\r\n  }\r\n}","namespace danfo.build.code {\r\n\r\n  const es3Keywords = [\r\n    'default', 'delete', 'import', 'export', 'class',\r\n    'break', 'for', 'new', 'true', 'with', 'continue', 'function',\r\n    'null', 'typeof', 'else', 'if', 'return', 'var', 'false', 'in', 'this', 'while'\r\n  ];\r\n\r\n  export var defineAmd: Function;\r\n  export var defineAmdWrappedText: string | undefined;\r\n\r\n  export declare namespace codeBuilder {\r\n\r\n    /**\r\n     * Pass an object with the options, it will be populated with these values as the code is built.\r\n     */\r\n    type DebugState = {\r\n      ts: typeof import('typescript');\r\n      documentRegistry: typescript.DocumentRegistry;\r\n      languageServiceHost: typescript.LanguageServiceHost & typescript.ModuleResolutionHost,\r\n      languageService: typescript.LanguageService;\r\n      moduleResolutionCache: typescript.ModuleResolutionCache;\r\n      program: typescript.Program;\r\n      scriptInputs: SourceFileOrSpan[];\r\n      settings: typescript.CompilerOptions;\r\n      configSourcedFiles: string[];\r\n      tsLibPath: string;\r\n    }\r\n  }\r\n\r\n  export function codeBuilder(options: codeBuilder.BuilderOptions & { debugState?: Partial<codeBuilder.DebugState> }): Builder {\r\n    const { fileSystem, precachedFixedSource, debugState } = options;\r\n\r\n    type CachedState = {\r\n      cachedScriptFileNames?: string[],\r\n      cachedFileEntries?: { [resolvedFile: string]: CachedFileEntry };\r\n      cachedFileStats?: { [resolvedFile: string]: FileSystem.Stat };\r\n      cachedFileContent?: { [resolvedFile: string]: string };\r\n      cacheScriptSnapshots?: { [resolvedFile: string]: typescript.IScriptSnapshot };\r\n      getDirectoriesByPath?: { [resolvedDirPath: string]: string[] };\r\n      cachedResolvedDefaultLibFileName?: string;\r\n    };\r\n\r\n    const ts = importTypeScript();\r\n    if (debugState) debugState.ts = ts;\r\n    // these variables would be re-populated on incremental rebuilds\r\n\r\n    let inputs: BuilderInputs = {\r\n      sources: [],\r\n      resolvedProjectDir: '.'\r\n    };\r\n    let scriptInputs: SourceFileOrSpan[] = [];\r\n    if (debugState) debugState.scriptInputs = scriptInputs;\r\n    const baseSettings = createDefaultSettings();\r\n    let settings = baseSettings;\r\n    if (debugState) debugState.settings = settings;\r\n    \r\n    let configSourcedFiles: string[] = [];\r\n    if (debugState) debugState.configSourcedFiles = configSourcedFiles;\r\n\r\n\r\n\r\n    // memoizing results for repetitive requests during build\r\n    // (will be re-populated before a rebuild starts)\r\n    let cachedState: CachedState = {};\r\n    let fileCache: { [resolvedFileName: string]: CachedFileEntry } = {};\r\n    let cache = createKeyCache(cachedState, null);\r\n\r\n    let buildState!: ReturnType<typeof initializeBuildState>;\r\n\r\n\r\n    const builder: Builder = {\r\n      build: triggerBuild\r\n    };\r\n\r\n    return builder;\r\n\r\n    function resolveJoinPathInProject(path1: string, path2?: string): string {\r\n      let result = fileSystem.resolvePath(inputs.resolvedProjectDir, path1);\r\n      if (path2) result = fileSystem.resolvePath(result, path2);\r\n      return result;\r\n    }\r\n\r\n    function getProjectRelativeFileName(path1: string, path2?: string): string {\r\n      const resolvedPath = resolveJoinPathInProject(path1, path2);\r\n      const relative = fileSystem.getRelativePath(inputs.resolvedProjectDir, resolvedPath);\r\n      return relative;\r\n    }\r\n\r\n    function promoteCaches(cachedState: CachedState) {\r\n      const deleteEntryKeys: string[] =[];\r\n      for (var k in fileCache) {\r\n        const entry = fileCache[k];\r\n        if (entry && typeof entry.unusedCount === 'number') {\r\n          entry.unusedCount++;\r\n          if (entry.unusedCount > 3) {\r\n            deleteEntryKeys.push(k);\r\n          }\r\n        }\r\n      }\r\n\r\n      for (const k of deleteEntryKeys) {\r\n        delete fileCache[k];\r\n      }\r\n\r\n\r\n      return {\r\n\r\n      };\r\n    }\r\n\r\n    function initializeBuildState() {\r\n\r\n      // serves as both ts.LanguageServiceHost and ts.ModuleResolutionHost\r\n      const langHost = {\r\n        getCompilationSettings: hostGetCompilationSettings,\r\n        getScriptFileNames: hostGetScriptFileNames,\r\n        getScriptVersion: hostGetScriptVersion,\r\n        getScriptSnapshot: hostGetScriptSnapshot,\r\n        getCurrentDirectory: hostGetCurrentDirectory,\r\n        getDirectories: hostGetDirectories,\r\n        getDefaultLibFileName: hostGetDefaultLibFileName,\r\n        fileExists: hostFileExists,\r\n        readFile: hostReadFile,\r\n        getCanonicalFileName: hostGetCanonicalFileName,\r\n        useCaseSensitiveFileNames: () => true\r\n      };\r\n      if (debugState) debugState.languageServiceHost = langHost;\r\n\r\n      // two functions overridden, to cache lib.d.ts more aggressively (in tests)\r\n      const baseDocumentRegistry = ts.createDocumentRegistry(\r\n        true /* useCaseSensitiveFileNames */,\r\n        inputs.resolvedProjectDir /* currentDirectory */\r\n      );\r\n\r\n      const documentRegistry: typescript.DocumentRegistry = {\r\n        ...baseDocumentRegistry,\r\n        acquireDocument: cachedAcquireDocument,\r\n        acquireDocumentWithKey: cachedAcquireDocumentWithKey\r\n      };\r\n      if (debugState) debugState.documentRegistry = documentRegistry;\r\n\r\n      const langService = ts.createLanguageService(\r\n        langHost,\r\n        documentRegistry,\r\n        false /* syntaxOnly */);\r\n      if (debugState) debugState.languageService = langService;\r\n\r\n      // TODO: resolve from actual TypeScript used (require.resolve?)\r\n      const tsLibPath = fileSystem.resolvePath(inputs.resolvedProjectDir, 'node_modules/typescript/lib');\r\n      if (debugState) debugState.tsLibPath = tsLibPath;\r\n\r\n      let moduleResolutionCache = ts.createModuleResolutionCache(\r\n        inputs.resolvedProjectDir,\r\n        path => getProjectRelativeFileName(path));\r\n      if (debugState) debugState.moduleResolutionCache = moduleResolutionCache;\r\n\r\n      return {\r\n        langHost,\r\n        documentRegistry,\r\n        langService,\r\n        tsLibPath,\r\n        moduleResolutionCache\r\n      };\r\n\r\n      function cachedAcquireDocument(\r\n        fileName: string,\r\n        compilationSettings: typescript.CompilerOptions,\r\n        scriptSnapshot: typescript.IScriptSnapshot,\r\n        version: string,\r\n        scriptKind: typescript.ScriptKind) {\r\n        if (precachedFixedSource) {\r\n          const resolvedFileName = fileSystem.resolvePath(inputs.resolvedProjectDir, fileName);\r\n          const entry = precachedFixedSource(resolvedFileName);\r\n          if (entry && entry.snapshot === scriptSnapshot)\r\n            return entry.source;\r\n        }\r\n\r\n        return baseDocumentRegistry.acquireDocument(\r\n          fileName, compilationSettings, scriptSnapshot, version, scriptKind);\r\n      }\r\n\r\n      function cachedAcquireDocumentWithKey(\r\n        fileName: string,\r\n        path: import('typescript').Path,\r\n        compilationSettings: typescript.CompilerOptions,\r\n        key: import('typescript').DocumentRegistryBucketKey,\r\n        scriptSnapshot: typescript.IScriptSnapshot,\r\n        version: string,\r\n        scriptKind: typescript.ScriptKind) {\r\n        if (precachedFixedSource) {\r\n          const resolvedFileName = fileSystem.resolvePath(inputs.resolvedProjectDir, fileName);\r\n          const entry = precachedFixedSource(resolvedFileName);\r\n          if (entry && entry.snapshot === scriptSnapshot)\r\n            return entry.source;\r\n        }\r\n\r\n        return baseDocumentRegistry.acquireDocumentWithKey(fileName, path, compilationSettings, key, scriptSnapshot, version, scriptKind);\r\n      }\r\n    }\r\n\r\n    function triggerBuild(newInputs: BuilderInputs): BuildResult {\r\n\r\n      if (!buildState)\r\n        buildState = initializeBuildState();\r\n\r\n      // TODO: promote relevant caches\r\n      cachedState = promoteCaches(cachedState);\r\n\r\n      inputs = newInputs;\r\n      cache = createKeyCache(cachedState, null);\r\n\r\n      scriptInputs = populateScriptFileNamesFromInputs();\r\n      if (debugState) debugState.scriptInputs = scriptInputs;\r\n\r\n      // read and combine any tsconfig.json used as input\r\n      const tsCmdline = populateSettingsIncludingInputs(scriptInputs);\r\n\r\n      settings = tsCmdline?.options || baseSettings;\r\n\r\n      // override/manipulate settings, especially in case tsconfig is read from file system\r\n      if (typeof newInputs.handleSettings === 'function') {\r\n        const updatedSettings = newInputs.handleSettings(settings);\r\n        if (updatedSettings)\r\n          settings = updatedSettings;\r\n      }\r\n      if (debugState) debugState.settings = settings;\r\n\r\n      if (tsCmdline?.fileNames) {\r\n        configSourcedFiles = tsCmdline.fileNames;\r\n        if (debugState) debugState.configSourcedFiles = configSourcedFiles;\r\n      }\r\n\r\n      // TODO: validate if this is needed anyway?\r\n      buildState.moduleResolutionCache = ts.createModuleResolutionCache(\r\n        newInputs.resolvedProjectDir,\r\n        path =>\r\n          getProjectRelativeFileName(path));\r\n      if (debugState) debugState.moduleResolutionCache = buildState.moduleResolutionCache;\r\n\r\n\r\n      /**\r\n       * Matching source and target at a file level.\r\n       * Note either source or target may be missing:\r\n       * compilation could have failed, or extra files generated/injected without actual source on disk.\r\n       */\r\n      type FileEntry = {\r\n        source?: {\r\n          resolvedFileName: string;\r\n          node: typescript.SourceFile;\r\n          dependencies?: {\r\n            imports: findDependencies.Dependency[],\r\n            exports: findDependencies.Export[]\r\n          };\r\n        };\r\n\r\n        target?: {\r\n          resolvedFileName: string;\r\n          sourcemap?: { fileName: string, content: string };\r\n          output?: string;\r\n          typings?: { fileName: string, content: string };\r\n        };\r\n      };\r\n      \r\n      // These will be populated from inputs and outputs, including match one to another.\r\n      // That matching is important when multiple outputs need to be injected to corresponding places in HTML.\r\n      const bySource: { [relativeSourceFileName: string]: FileEntry } = {};\r\n      const byTarget: { [relativeTargetFileName: string]: FileEntry } = {};\r\n      const fileEntryList: FileEntry[] = [];\r\n\r\n      const program = buildState.langService.getProgram();\r\n      if (debugState) debugState.program = program!;\r\n\r\n      if (!program) {\r\n        // TODO: how can it get here???\r\n        return {\r\n          emits: [],\r\n          errors: [],\r\n          imports: []\r\n        };\r\n      }\r\n\r\n      // by now there may be more sources resolved by TypeScript itself\r\n      // (imports, triple-slash and whatnot)\r\n      populateSourcesFromProgram();\r\n\r\n\r\n      type ModuleDependencyDetails = {\r\n        moduleName: string;\r\n        importedBy?: ModuleDependencyImportFromFile[];\r\n        exporting?: {\r\n          sourceFile: typescript.SourceFile;\r\n          exports: findDependencies.Export[];\r\n        }\r\n      }\r\n\r\n      type ModuleDependencyImportFromFile = {\r\n        source: {\r\n          sourceFile: typescript.SourceFile\r\n        };\r\n        dependencies: findDependencies.Dependency[]\r\n      };\r\n\r\n\r\n      const hoistHelpersTransformer = hoistHelpers({ ts });\r\n      const detectAmdDefinesTransformer = convertAmd({\r\n        ts,\r\n        program,\r\n        generateModuleName: sourceFileName => getProjectRelativeFileName(sourceFileName),\r\n        resolveModuleName: (sourceFileName, moduleName) => {\r\n          if (moduleName.charCodeAt(0) === CharCodes.Dot\r\n            || moduleName.charCodeAt(0) === CharCodes.Slash\r\n            || moduleName.charCodeAt(0) === CharCodes.Backslash)\r\n            return fileSystem.resolvePath(inputs.resolvedProjectDir, sourceFileName + '/../' + moduleName);\r\n          else if (moduleName.charCodeAt(0) === CharCodes.Tilda)\r\n            return fileSystem.resolvePath(inputs.resolvedProjectDir, moduleName);\r\n          else\r\n            return moduleName;\r\n        }\r\n      });\r\n\r\n      const codeBuilderResult = runEmit();\r\n\r\n      const externalImportList: Import[] = [];\r\n      for (const mod of detectAmdDefinesTransformer.modules) {\r\n        if (mod.importedBy && !mod.exportedBy) {\r\n          // TODO: resolve external import, if succeeded, process in a separate, relaxed language service\r\n\r\n          externalImportList.push({\r\n            reference: mod.moduleName\r\n          });\r\n        }\r\n      }\r\n\r\n      const buildResult = {\r\n        ...codeBuilderResult,\r\n        emits: [...codeBuilderResult.emits],\r\n        imports: externalImportList\r\n      };\r\n\r\n\r\n      if (detectAmdDefinesTransformer.defines?.length) {\r\n\r\n        const preloadRootSources: string[] = [];\r\n        const preloadRootSourceNames: string[] = [];\r\n        for (const inp of newInputs.sources) {\r\n          // TODO: handle directory (load index.js/ts)\r\n\r\n          for (const defn of detectAmdDefinesTransformer.defines) {\r\n            if (defn.sourceFile.fileName === inp.resolvedPath) {\r\n              const projRelativePath = getProjectRelativeFileName(inp.resolvedPath);\r\n              if (preloadRootSourceNames.indexOf(projRelativePath) < 0) {\r\n                preloadRootSourceNames.push(projRelativePath);\r\n                preloadRootSources.push('define.require(' + JSON.stringify(projRelativePath) + ');');\r\n              }\r\n            }\r\n          }\r\n        }\r\n\r\n        if (!defineAmdWrappedText)\r\n          defineAmdWrappedText = 'var define = (function() { return defineAmd();\\n' + defineAmd + '\\n})()';\r\n\r\n        const defineFunctionEmit = generateHelperEmitWithPerLineMaps({\r\n          name: '__define.js',\r\n          text: defineAmdWrappedText\r\n        });\r\n        \r\n        buildResult.emits.unshift(defineFunctionEmit);\r\n\r\n\r\n        if (preloadRootSources.length) {\r\n          const moduleLoad: Emit = generateHelperEmitWithPerLineMaps({\r\n            name: '__moduleLoad.js',\r\n            text: preloadRootSources.join('\\n')\r\n          });\r\n          moduleLoad.injectAfter = true;\r\n\r\n          buildResult.emits.push(moduleLoad);\r\n        }\r\n      }\r\n\r\n      return buildResult;\r\n\r\n      function populateScriptFileNamesFromInputs() {\r\n        let encounteredTsconfigs: SourceFileOrSpan[] | undefined;\r\n        const allSources: SourceFileOrSpan[] = [];\r\n        for (const src of inputs.sources) {\r\n          if (src.type as string === 'html' || src.type === 'css' || !src.type) continue;\r\n\r\n          if (src.type === 'tsconfig') {\r\n            (encounteredTsconfigs || (encounteredTsconfigs = [])).push(src);\r\n          }\r\n          else {\r\n            allSources.push(src);\r\n          }\r\n        }\r\n\r\n        if (encounteredTsconfigs && encounteredTsconfigs.length === 1)\r\n          allSources.unshift(encounteredTsconfigs[0]);\r\n\r\n        return allSources;\r\n\r\n        // TODO: do we need any special handling for packages?\r\n        // (especially when in node_modules?)\r\n        // function populateFromPackage(packageJsonPath: string) {\r\n\r\n        // }\r\n      }\r\n\r\n      function populateSourcesFromProgram() {\r\n        for (const sourceFile of program!.getSourceFiles()) {\r\n          const resolvedFileName = resolveJoinPathInProject(sourceFile.fileName);\r\n          const relativeFileName = getProjectRelativeFileName(resolvedFileName);\r\n          let entry = bySource[relativeFileName];\r\n          if (entry) {\r\n            if (!entry.source) {\r\n              entry.source = {\r\n                resolvedFileName,\r\n                node: sourceFile\r\n              };\r\n            }\r\n            entry.source.node = sourceFile;\r\n          }\r\n          else {\r\n            entry = {\r\n              source: {\r\n                resolvedFileName,\r\n                node: sourceFile\r\n              }\r\n            };\r\n            bySource[relativeFileName] = entry;\r\n            fileEntryList.push(entry);\r\n          }\r\n        }\r\n      }\r\n\r\n      function runEmit() {\r\n        const emitResult = program!.emit(\r\n          void 0 /* targetSourceFile */,\r\n          onFileEmit,\r\n          void 0 /* cancellationToken */,\r\n          false /* emitOnlyDtsFiles */,\r\n          {\r\n            before: [],\r\n            after: [\r\n              context => keywords.transformKeywords(context, es3Keywords, ts),\r\n              hoistHelpersTransformer.transform,\r\n              detectAmdDefinesTransformer.transform\r\n            ],\r\n            afterDeclarations: []\r\n          } /* customTransformers */);\r\n        \r\n        const errors: BuildError[] = [];\r\n        for (const emit of fileEntryList) {\r\n          if (emit.source && emit.target) {\r\n            if (!/\\bnode_modules\\b/.test(emit.source.resolvedFileName)) {\r\n              addDiagnosticErrors(program!.getSyntacticDiagnostics(emit.source.node));\r\n              addDiagnosticErrors(program!.getSemanticDiagnostics(emit.source.node));\r\n            }\r\n          }\r\n        }\r\n\r\n        addDiagnosticErrors(program!.getGlobalDiagnostics());\r\n        addDiagnosticErrors(program!.getOptionsDiagnostics())\r\n\r\n        addDiagnosticErrors(emitResult.diagnostics);\r\n\r\n        // if (emitResult.emitSkipped) {\r\n        //   errors.push({\r\n        //     code: 'TS',\r\n        //     message: 'Emit was skipped by TypeScript build.'\r\n        //   });\r\n        // }\r\n\r\n        let emits = fileEntryList.map(entry => {\r\n          if (entry.target) {\r\n            return {\r\n              resolvedSourcePath: entry.source ? entry.source.resolvedFileName : entry.target?.resolvedFileName,\r\n              sourcemap: entry.target.sourcemap,\r\n              typings: entry.target.typings,\r\n              output: entry.target.output\r\n            };\r\n          }\r\n          else if (entry.source) {\r\n            // TODO: adjust this simple heuristic\r\n            // A lot of .d.ts typings files are actually taking part in a typical build process\r\n            // -- including standard lib.d.ts and huge react, node typings and such.\r\n            // These are not relevant and should not be included.\r\n            if (!/node_modules/.test(entry.source.resolvedFileName)) {\r\n              const text = entry.source.node.getFullText();\r\n              if (typeof text === 'string') {\r\n                return generatePlainEmitWithEmptyFile(\r\n                  getProjectRelativeFileName(entry.source.resolvedFileName),\r\n                  text);\r\n              }\r\n            }\r\n          }\r\n        }).filter(entry => entry) as Emit[];\r\n\r\n        const namedHelpers: { [name: string]: boolean } = {};\r\n\r\n        const injectHelpers = processInjectedHelpers();\r\n        if (injectHelpers)\r\n          emits = [...injectHelpers, ...emits];\r\n\r\n        return { emits, errors };\r\n\r\n        function processInjectedHelpers() {\r\n          const injectHelpers: typeof emits = [];\r\n          hoistHelpersTransformer.emitHelpers.sort((h1, h2) =>\r\n            (h1.emitHelper.priority || 0) - (h2.emitHelper.priority || 0) // sort by priority, then by name\r\n            || (h1.emitHelper.name > h2.emitHelper.name ? +1 : h1.emitHelper.name < h2.emitHelper.name ? -1 : 0));\r\n\r\n          const emitHelpersOrdered = [...hoistHelpersTransformer.emitHelpers].sort((h1, h2) => h1.fileName > h2.fileName ? +1 : h1.fileName < h2.fileName ? -1 : 0);\r\n\r\n          for (const h of emitHelpersOrdered) {\r\n            if (namedHelpers[h.emitHelper.name]) continue;\r\n            namedHelpers[h.emitHelper.name] = true;\r\n            injectHelpers.push(generateHelperEmitWithPerLineMaps(h.emitHelper));\r\n          }\r\n\r\n          return injectHelpers;\r\n        }\r\n\r\n        function addDiagnosticErrors(diagList: readonly typescript.Diagnostic[] | undefined) {\r\n          if (diagList) {\r\n            for (const diag of diagList) {\r\n              if (diag.file && /\\bnode_modules\\b/i.test(diag.file.fileName))\r\n                continue;\r\n\r\n              errors.push(createErrorFromDiagnostic(diag));\r\n            }\r\n          }\r\n        }\r\n\r\n        function createErrorFromDiagnostic(diag: typescript.Diagnostic): BuildError {\r\n          const err: BuildError = {\r\n            resolvedSourcePath: diag.file ? diag.file.fileName : void 0,\r\n            code: 'TS' + String(diag.code),\r\n            message: typeof diag.messageText === 'string' ? diag.messageText : diag.messageText.messageText,\r\n            typescriptDetails: diag,\r\n            format: formatDiagnostic\r\n          };\r\n\r\n          return err;\r\n\r\n          function formatDiagnostic(overrideBaseDir?: string) {\r\n            return danfo.node.formatBuildError(\r\n              err,\r\n              {\r\n                typescriptForFormatting: ts,\r\n                projRoot: overrideBaseDir ? fileSystem.resolvePath(inputs.resolvedProjectDir, overrideBaseDir) : inputs.resolvedProjectDir,\r\n                fileSystem\r\n              });\r\n          }\r\n        }\r\n      }\r\n\r\n      /**\r\n       * Callback invoked by TypeScript on every file emitted.\r\n       * Note an important parameter here is `sourceFiles`, allowing to map an emitted output back to the original source file.\r\n       * \r\n       * It's usually 1 file, can be multiple when TypeScript's own bundling is in use (--outFile tsconfig parameter)\r\n       */\r\n      function onFileEmit(\r\n        fileName: string,\r\n        data: string,\r\n        writeByteOrderMark: boolean,\r\n        onError?: (message: string) => void,\r\n        sourceFiles?: readonly typescript.SourceFile[]) {\r\n\r\n        const resolvedFileName = resolveJoinPathInProject(inputs.resolvedProjectDir, fileName);\r\n        const relativeFileName = getProjectRelativeFileName(resolvedFileName);\r\n        const isTypings = codeBuilder.isTypingsFilename(resolvedFileName);\r\n        const isSourcemap = codeBuilder.isSourcemapFilename(resolvedFileName);\r\n        const isJavaScript = codeBuilder.hasJavascriptFileExtension(resolvedFileName);\r\n        if (!isTypings && !isSourcemap && !isJavaScript) {\r\n          if (sourceFiles) {\r\n            // TODO: that may be something intended?\r\n          }\r\n          else {\r\n            // TODO: that is likely junk or cache files\r\n          }\r\n\r\n          return;\r\n        }\r\n\r\n        let entry = byTarget[relativeFileName];\r\n        if (!entry) {\r\n          // find possible source file for this emit\r\n          if (sourceFiles) {\r\n            for (const sourceFileEntry of sourceFiles) {\r\n              const resolvedSourceFileName = resolveJoinPathInProject(inputs.resolvedProjectDir, sourceFileEntry.fileName);\r\n              const relativeSourceFileName = getProjectRelativeFileName(resolvedSourceFileName);\r\n              entry = bySource[relativeSourceFileName];\r\n              // known source found\r\n              if (entry) break;\r\n            }\r\n            if (!entry) {\r\n              // source found, but not known, let's add it\r\n              const useFirstSource = sourceFiles[0];\r\n              if (useFirstSource) {\r\n                const resolvedSourceFileName = resolveJoinPathInProject(inputs.resolvedProjectDir, useFirstSource.fileName);\r\n                entry = {\r\n                  source: {\r\n                    resolvedFileName: resolvedSourceFileName,\r\n                    node: useFirstSource\r\n                  }\r\n                };\r\n                fileEntryList.push(entry);\r\n              }\r\n            }\r\n          }\r\n\r\n          if (!entry) {\r\n            // source not found: this has to be an emit without original source\r\n            entry = {\r\n              target: {\r\n                resolvedFileName\r\n              }\r\n            };\r\n            fileEntryList.push(entry);\r\n          }\r\n\r\n          byTarget[relativeFileName] = entry;\r\n        }\r\n\r\n        if (!entry.target) {\r\n          entry.target = {\r\n            resolvedFileName\r\n          };\r\n        }\r\n\r\n        if (isTypings)\r\n          entry.target!.typings = { fileName: resolvedFileName, content: data };\r\n        else if (isSourcemap)\r\n          entry.target!.sourcemap = { fileName: resolvedFileName, content: data };\r\n        else\r\n          entry.target!.output = data;\r\n      }\r\n    }\r\n\r\n    function createDefaultSettings() {\r\n      const settings = ts.getDefaultCompilerOptions();\r\n      settings.jsx = ts.JsxEmit.React;\r\n      settings.checkJs = true;\r\n      settings.allowJs = true;\r\n      settings.sourceMap = true;\r\n      settings.inlineSources = true;\r\n      settings.module = ts.ModuleKind.AMD;\r\n      settings.moduleResolution = ts.ModuleResolutionKind.Node10;\r\n      settings.declaration = true;\r\n      settings.newLine = ts.NewLineKind.LineFeed;\r\n      settings.target = ts.ScriptTarget.ES5;\r\n      settings.skipDefaultLibCheck = true;\r\n      settings.resolveJsonModule = true;\r\n\r\n      // settings.lib = (settings.lib || []);\r\n      // // 'dom.iterable'\r\n      // // 'scripthost'\r\n      // // 'dom', 'webworker'\r\n      // for (const lib of ['esnext']) {\r\n      //   if (settings.lib.indexOf(lib) < 0)\r\n      //     settings.lib.push(lib);\r\n      // }\r\n\r\n      // settings.incremental = true;\r\n      // settings.composite = true;\r\n      // settings.tsBuildInfoFile = projectDir + '/.cache.tsbuildinfo';\r\n      settings.strict = true;\r\n\r\n      settings.outDir = inputs.resolvedProjectDir + '/dist';\r\n\r\n      return settings;\r\n    }\r\n\r\n    function populateSettingsIncludingInputs(sources: SourceFileOrSpan[]): import('typescript').ParsedCommandLine | undefined {\r\n      let result: import('typescript').ParsedCommandLine | undefined;\r\n      for (const src of sources) {\r\n        if (src.type === 'tsconfig') {\r\n          const cfgDir = resolveJoinPathInProject(src.resolvedPath, '..');\r\n          const resolvedNormalizedPath = getProjectRelativeFileName(src.resolvedPath);\r\n          const configJson = ts.readJsonConfigFile(\r\n            resolvedNormalizedPath,\r\n            filePath => fileSystem.readFile(filePath === resolvedNormalizedPath ? src.resolvedPath : filePath));\r\n          const host: import('typescript').ParseConfigHost = {\r\n            useCaseSensitiveFileNames: true, // TODO: rely on underlying OS?\r\n            readDirectory: (...args) => readDirectory(inputs.resolvedProjectDir, fileSystem, ...args),\r\n            fileExists: filePath => {\r\n              const ex = !!fileSystem.stat(\r\n                filePath === resolvedNormalizedPath ?\r\n                  src.resolvedPath :\r\n                  fileSystem.resolvePath(cfgDir, filePath));\r\n              return ex;\r\n            },\r\n            readFile: filePath => {\r\n              const data = fileSystem.readFile(\r\n                filePath === resolvedNormalizedPath ?\r\n                  src.resolvedPath :\r\n                  fileSystem.resolvePath(cfgDir, filePath));\r\n              return data;\r\n            }\r\n            // TODO: trace?(s: string): void\r\n          };\r\n          const parsedConfigJson = ts.parseJsonSourceFileConfigFileContent(\r\n            configJson,\r\n            host,\r\n            cfgDir,\r\n            result && result.options || baseSettings,\r\n            src.resolvedPath);\r\n          \r\n          // make all file paths absolute\r\n          if (parsedConfigJson.fileNames) {\r\n            for (let i = 0; i < parsedConfigJson.fileNames.length; i++) {\r\n              parsedConfigJson.fileNames[i] = fileSystem.resolvePath(cfgDir, parsedConfigJson.fileNames[i]);\r\n            }\r\n          }\r\n\r\n          parsedConfigJson.fileNames = joinArrays(result?.fileNames, parsedConfigJson.fileNames)!;\r\n          parsedConfigJson.projectReferences = joinArrays(result?.projectReferences, parsedConfigJson.projectReferences);\r\n          // TODO: parsedConfigJson.wildcardDirectories\r\n          result = parsedConfigJson;\r\n        }\r\n      }\r\n      return result;\r\n\r\n      function joinArrays<T, TArray extends ConcatArray<T>>(array1: TArray | undefined, array2: TArray | undefined): TArray | undefined {\r\n        if (!array1)\r\n          return array2;\r\n        else if (!array2)\r\n          return array1;\r\n        else\r\n          return (array1 as any as T[]).concat(array2) as any as TArray;\r\n      }\r\n    }\r\n\r\n    type CachedFileEntry = {\r\n      stat?: FileSystem.Stat;\r\n      version: string;\r\n      content?: string;\r\n      snapshot?: typescript.IScriptSnapshot;\r\n      unusedCount: number;\r\n    }\r\n\r\n    function getFileStatDirect(resolvedFileName: string) {\r\n      let stat = fileSystem.stat(resolvedFileName);\r\n\r\n      if (!stat || stat.isDirectory) {\r\n        const defaultLib = hostGetDefaultLibFileName(settings);\r\n        const parentDirPath = resolveJoinPathInProject(resolvedFileName, '..');\r\n        if (parentDirPath === defaultLib\r\n          || parentDirPath === resolveJoinPathInProject(defaultLib, '..')\r\n          || parentDirPath.toLowerCase() === defaultLib.toLowerCase()\r\n          || parentDirPath.toLowerCase() === resolveJoinPathInProject(defaultLib, '..').toLowerCase()) {\r\n          const libFileName = getBaseName(resolvedFileName);\r\n          const redirectToStandardLibPath = ts.resolveDefaultLibFromOfficial(libFileName);\r\n          if (redirectToStandardLibPath) {\r\n            stat = fileSystem.stat(redirectToStandardLibPath);\r\n          }\r\n        }\r\n      }\r\n\r\n      return stat;\r\n    }\r\n\r\n    function getFileContentDirect(resolvedFileName: string) {\r\n      let content = fileSystem.readFile(resolvedFileName);\r\n      if (typeof content !== 'string') {\r\n        const defaultLib = hostGetDefaultLibFileName(settings);\r\n        const parentDirPath = resolveJoinPathInProject(resolvedFileName, '..');\r\n        if (parentDirPath === defaultLib\r\n          || parentDirPath === resolveJoinPathInProject(defaultLib, '..')\r\n          || parentDirPath.toLowerCase() === defaultLib.toLowerCase()\r\n          || parentDirPath.toLowerCase() === resolveJoinPathInProject(defaultLib, '..').toLowerCase()) {\r\n          const libFileName = getBaseName(resolvedFileName);\r\n          const redirectToStandardLibPath = ts.resolveDefaultLibFromOfficial(libFileName);\r\n          if (redirectToStandardLibPath)\r\n            content = fileSystem.readFile(redirectToStandardLibPath);\r\n        }\r\n\r\n      }\r\n      return typeof content === 'string' ? content : null;\r\n    }\r\n\r\n    function getScriptSnapshotDirect(resolvedFileName: string) {\r\n      if (typeof precachedFixedSource === 'function') {\r\n        const entry = precachedFixedSource(resolvedFileName);\r\n        if (entry) return entry.snapshot;\r\n      }\r\n\r\n      let fileContent = getFileContentDirect(resolvedFileName);\r\n      if (typeof fileContent !== 'string') {\r\n        const defaultLib = hostGetDefaultLibFileName(settings);\r\n        const parentDirPath = resolveJoinPathInProject(resolvedFileName, '..');\r\n        if (parentDirPath === defaultLib\r\n          || parentDirPath === resolveJoinPathInProject(defaultLib, '..')) {\r\n          const libFileName = getBaseName(resolvedFileName);\r\n          const redirectToStandardLibPath = ts.resolveDefaultLibFromOfficial(libFileName);\r\n          if (redirectToStandardLibPath) {\r\n            fileContent = getFileContentDirect(redirectToStandardLibPath);\r\n          }\r\n        }\r\n\r\n        return null;\r\n      }\r\n\r\n      return createScriptSnapshot(resolvedFileName, fileContent);\r\n    }\r\n\r\n    function getCachedFileEntry(resolvedFileName: string): CachedFileEntry | null {\r\n      const entry = cache.cachedOrPopulate<CachedFileEntry>({\r\n        cacheField: 'cachedFileEntries',\r\n        key: resolvedFileName,\r\n        populate: () => {\r\n          const stat = getFileStatDirect(resolvedFileName);\r\n          if (!stat) {\r\n            return fileCache[resolvedFileName] = {\r\n              unusedCount: 0,\r\n              version: 'missing'\r\n            };\r\n          }\r\n\r\n          const oldEntry = fileCache[resolvedFileName];\r\n          if (oldEntry && typeof oldEntry.unusedCount === 'number') {\r\n            if (oldEntry.stat?.length === stat?.length && oldEntry.stat?.timestamp === stat?.timestamp) {\r\n              oldEntry.unusedCount = 0;\r\n              return oldEntry;\r\n            }\r\n          }\r\n\r\n          const content = getFileContentDirect(resolvedFileName) || undefined;\r\n\r\n          if (oldEntry && oldEntry.content === content) {\r\n            // timestamp changed, but content remained - retain everything\r\n            oldEntry.stat = stat;\r\n            oldEntry.unusedCount = 0;\r\n            return oldEntry;\r\n          }\r\n\r\n          const version = deriveFileVersionFromStat(stat);\r\n          const snapshot = getScriptSnapshotDirect(resolvedFileName) || undefined;\r\n\r\n          return fileCache[resolvedFileName] = {\r\n            unusedCount: 0,\r\n            stat,\r\n            version,\r\n            content,\r\n            snapshot\r\n          };\r\n        }\r\n      });\r\n\r\n      return entry.completed && entry.success && entry.result || null;\r\n    }\r\n\r\n    function getFileStat(resolvedFileName: string): FileSystem.Stat | null {\r\n      const entry = cache.cachedOrPopulate<FileSystem.Stat | null>({\r\n        cacheField: 'cachedFileStats',\r\n        key: resolvedFileName,\r\n        populate: () => {\r\n          const entry = getCachedFileEntry(resolvedFileName);\r\n          return entry?.stat || null;\r\n        }\r\n      });\r\n\r\n      return entry.completed && entry.success && entry.result || null;\r\n    }\r\n\r\n    function getFileContent(resolvedFileName: string): string | null {\r\n      const entry = cache.cachedOrPopulate<string | null>({\r\n        cacheField: 'cachedFileContent',\r\n        key: resolvedFileName,\r\n        populate: () => {\r\n          const entry = getCachedFileEntry(resolvedFileName);\r\n          return typeof entry?.content === 'string' ? entry.content : null;\r\n        }\r\n      });\r\n\r\n      return entry.completed && entry.success && entry.result || null;\r\n    }\r\n\r\n    function hostGetCompilationSettings(): typescript.CompilerOptions {\r\n      return settings;\r\n    }\r\n\r\n    function hostGetScriptFileNames(): string[] {\r\n      const entry = cache.cachedOrPopulate<string[]>({\r\n        cacheField: 'cachedScriptFileNames',\r\n        populate: () => {\r\n          const sources: string[] = [];\r\n          for (const src of scriptInputs) {\r\n            if (src.type !== 'tsconfig') {\r\n              sources.push(src.resolvedPath);\r\n            }\r\n          }\r\n          if (configSourcedFiles) {\r\n            for (const src of configSourcedFiles) {\r\n              const resolvedPath = resolveJoinPathInProject(src);\r\n              // const relativePath = getProjectRelativeFileName(resolvedPath);\r\n              sources.push(resolvedPath);\r\n            }\r\n          }\r\n          return sources;\r\n        }\r\n      });\r\n\r\n      return !entry.completed || !entry.success ? [] : entry.result;\r\n    }\r\n\r\n    function hostGetScriptVersion(fileName: string): string {\r\n      const resolvedFileName = resolveJoinPathInProject(fileName);\r\n      if (typeof precachedFixedSource === 'function') {\r\n        const entry = precachedFixedSource(resolvedFileName);\r\n        if (entry) return 'precached';\r\n      }\r\n\r\n\r\n      const entry = getCachedFileEntry(resolvedFileName);\r\n      return entry?.version || 'cache-miss';\r\n    }\r\n\r\n    function deriveFileVersionFromStat({ timestamp, length }: { timestamp: number, length: number }) {\r\n      return length + '@' + timestamp;\r\n    }\r\n    \r\n    function hostFileExists(fileName: string): boolean {\r\n      const resolvedFileName = resolveJoinPathInProject(fileName);\r\n      const stat = getFileStat(resolvedFileName);\r\n      return !!stat && !stat.isDirectory;\r\n    }\r\n\r\n    function hostGetScriptSnapshot(fileName: string): typescript.IScriptSnapshot | undefined {\r\n      const resolvedFileName = resolveJoinPathInProject(fileName);\r\n      if (typeof precachedFixedSource === 'function') {\r\n        const entry = precachedFixedSource(resolvedFileName);\r\n        if (entry) return entry.snapshot;\r\n      }\r\n\r\n      const entry = cache.cachedOrPopulate<typescript.IScriptSnapshot | null>({\r\n        cacheField: 'cacheScriptSnapshots',\r\n        key: resolvedFileName,\r\n        populate: () => {\r\n          const entry = getCachedFileEntry(resolvedFileName);\r\n          return entry?.snapshot ||null;\r\n        }\r\n      });\r\n\r\n      if (entry.completed && entry.success) return entry.result || void 0;\r\n      else return void 0;\r\n    }\r\n\r\n    function hostReadFile(fileName: string): string | undefined {\r\n      const resolvedFileName = resolveJoinPathInProject(fileName);\r\n      const fileContent = getFileContent(resolvedFileName);\r\n      return typeof fileContent === 'string' ? fileContent : void 0;\r\n    }\r\n\r\n    function hostGetCanonicalFileName(fileName: string): string {\r\n      return getProjectRelativeFileName(fileName);\r\n    }\r\n\r\n    function hostGetCurrentDirectory(): string {\r\n      return inputs.resolvedProjectDir;\r\n    }\r\n\r\n    let emptyDirectoryList: string[] | undefined;\r\n    function hostGetDirectories(dirPath: string): string[] {\r\n      const resolvedDirPath = resolveJoinPathInProject(dirPath);\r\n      const entry = cache.cachedOrPopulate<string[] | null>({\r\n        cacheField: 'getDirectoriesByPath',\r\n        key: resolvedDirPath,\r\n        populate: () => {\r\n          const dirs = fileSystem.readDirectory(resolvedDirPath);\r\n          return dirs || null;\r\n        }\r\n      });\r\n\r\n      return (entry.completed && entry.success ? entry.result : null) ||\r\n        emptyDirectoryList || (emptyDirectoryList = []);\r\n    }\r\n\r\n    function hostGetDefaultLibFileName(options: typescript.CompilerOptions): string {\r\n      const entry = cache.cachedOrPopulate<string>({\r\n        cacheField: 'cachedResolvedDefaultLibFileName',\r\n        populate: () => hostGetCanonicalFileName(fileSystem.resolvePath(buildState.tsLibPath, ts.getDefaultLibFileName(options)))\r\n      });\r\n\r\n      return entry.completed && entry.success ? entry.result : 'lib.d.ts';\r\n    }\r\n\r\n    function createScriptSnapshot(resolvedFileName: string, fileContent: string) {\r\n      // TODO: implement getChangeRange?\r\n      return preciseScriptSnapshot(fileContent);\r\n    }\r\n  }\r\n\r\n  export namespace codeBuilder {\r\n\r\n    export type DefaultImport = {};\r\n    export const DefaultImport: DefaultImport = {};\r\n\r\n    export type StarImport = {};\r\n    export const StarImport: StarImport = {};\r\n\r\n    export type RawImport = {};\r\n    export const RawImport: RawImport = {};\r\n\r\n    const regex_DTS = /\\.d\\.ts$/i;\r\n    const regex_MAP = /\\.map$/i;\r\n\r\n    const regex_getFileExt = /^.*[^.\\\\/](\\.[^.\\\\/]+)$/;\r\n    const regex_javascriptFileExtension = /\\.(js|jsx)$/i;\r\n\r\n    export function isTypingsFilename(fileName: string) { return regex_DTS.test(fileName); }\r\n\r\n    export function isSourcemapFilename(fileName: string) { return regex_MAP.test(fileName); }\r\n\r\n    export function getFileExtension(fileName: string) {\r\n      const ext = fileName.replace(regex_getFileExt, '$1');\r\n      if (ext === fileName) // failed to match the .ext regexp\r\n        return '';\r\n      else\r\n        return ext;\r\n    }\r\n\r\n    export function hasJavascriptFileExtension(file: string) {\r\n      return regex_javascriptFileExtension.test(file);\r\n    }\r\n\r\n  }\r\n\r\n  function shouldSkipDirectoryContentFromIteration(fName: string) {\r\n    return fName === 'node_modules'\r\n      || fName === '.git'\r\n      || fName === '.DS_Store';\r\n  }\r\n\r\n  function readDirectory(\r\n    projectDir: string,\r\n    fileSystem: FileSystem,\r\n    rootDir: string,\r\n    extensions: readonly string[],\r\n    excludes: readonly string[] | undefined,\r\n    includes: readonly string[],\r\n    depth?: number | undefined): readonly string[] {\r\n\r\n    let result: string[] = [];\r\n    readDirectoryRecursive(\r\n      fileSystem.resolvePath(projectDir, rootDir),\r\n      depth);\r\n\r\n    return result;\r\n\r\n    function readDirectoryRecursive(resolvedDirPath: string, moreDepth: number | undefined): void {\r\n      const dirEntries = fileSystem.readDirectory(resolvedDirPath);\r\n      if (!dirEntries) return;\r\n\r\n      const ownFiles: string[] = [];\r\n      dirEntries.sort();\r\n      for (const entry of dirEntries) {\r\n        const stat = fileSystem.stat(entry);\r\n        if (!stat) continue;\r\n        if (stat.isDirectory) {\r\n          readDirectoryRecursive(entry, typeof moreDepth === 'undefined' ? moreDepth : moreDepth - 1);\r\n        }\r\n        else if (!extensions || !extensions.length || extensions.indexOf(codeBuilder.getFileExtension(entry).toLowerCase()) >= 0) {\r\n          // TODO: handle excludes/includes\r\n          ownFiles.push(fileSystem.getRelativePath(rootDir, entry));\r\n        }\r\n      }\r\n\r\n      if (ownFiles.length) {\r\n        for (let i = 0; i < ownFiles.length; i++) {\r\n          result.push(ownFiles[i]);\r\n        }\r\n      }\r\n    }\r\n  }\r\n\r\n  function createImportOriginEntry(resolvedSourcePath: string, node: typescript.Node) {\r\n    const sourceFile = node.getSourceFile();\r\n    const start = sourceFile.getLineAndCharacterOfPosition(node.getStart());\r\n    const lineStart = sourceFile.getPositionOfLineAndCharacter(start.line, 0);\r\n    const lineEnd = sourceFile.getLineEndOfPosition(node.getStart());\r\n    const lineText = sourceFile.getText().slice(lineStart, lineEnd);\r\n    const nodeEndOrLineEnd = sourceFile.getLineAndCharacterOfPosition(Math.min(node.getEnd(), lineEnd));\r\n    const importOrigin = {\r\n      resolvedSourcePath,\r\n      line: start.line,\r\n      character: start.character,\r\n      length: nodeEndOrLineEnd.character - start.character,\r\n      lineText\r\n    };\r\n    return importOrigin;\r\n  }\r\n\r\n  function generatePlainEmitWithEmptyFile(sourceName: string, text: string) {\r\n    const sourcemap: danfo.parsing.sourcemap.Sourcemap = {\r\n      version: 3,\r\n      file: sourceName,\r\n      sourceRoot: '',\r\n      sources: [sourceName],\r\n      names: [],\r\n      mappings: '',\r\n      sourcesContent: [text]\r\n    };\r\n\r\n    const sourcemapText = JSON.stringify(sourcemap);\r\n\r\n    return {\r\n      resolvedSourcePath: sourceName,\r\n      output: '\\n//# sourceMappingURL=' + sourceName + '.map',\r\n      sourcemap: sourcemapText\r\n    };\r\n  }\r\n\r\n  function generateHelperEmitWithPerLineMaps(h: { name: string, text: string | ((node: ((nm: string) => string)) => string) }) {\r\n    const sourceName = h.name + '.js';\r\n    const sourcePath = '__helpers/' + sourceName;\r\n    const sourceContent = typeof h.text === 'string' ? h.text : h.text((nm: string) => nm);\r\n    const sourcemap: danfo.parsing.sourcemap.Sourcemap = {\r\n      version: 3,\r\n      file: sourceName,\r\n      sourceRoot: '',\r\n      sources: [sourcePath],\r\n      names: [],\r\n      mappings: '',\r\n      sourcesContent: [sourceContent]\r\n    };\r\n\r\n    const sourcemapWriter = danfo.parsing.sourcemap.writer();\r\n    let linePos = 0;\r\n    let mapping: danfo.parsing.sourcemap.Mapping = {\r\n      generatedLine: 0,\r\n      generatedColumn: 0,\r\n      originalLine: 0,\r\n      originalColumn: 0,\r\n      originalFile: 0,\r\n      originalName: -1\r\n    };\r\n    while (linePos < sourceContent.length) {\r\n      let lineEnd = sourceContent.indexOf('\\n', linePos);\r\n      if (lineEnd < 0) lineEnd = sourceContent.length;\r\n      mapping.generatedLine++;\r\n      mapping.originalLine++;\r\n      sourcemapWriter.write(mapping);\r\n      linePos = lineEnd + 1;\r\n    }\r\n\r\n    sourcemap.mappings = sourcemapWriter.text();\r\n    const sourcemapText = JSON.stringify(sourcemap);\r\n    const sourcemapFileName = sourceName + '.map';\r\n\r\n    return {\r\n      resolvedSourcePath: sourcePath,\r\n      output: sourceContent + '\\n//# sourceMappingURL=' + sourcemapFileName,\r\n      sourcemap: { fileName: sourcemapFileName, content: sourcemapText }\r\n    };\r\n  }\r\n\r\n}\r\n","namespace danfo.build.code {\r\n\r\n  export declare namespace findDependencies {\r\n\r\n    type Dependency = {\r\n      async: boolean;\r\n      dynamic: boolean;\r\n      importNode: typescript.Node;\r\n      moduleNode: typescript.Node;\r\n      assignsTo?: DependencyTarget;\r\n      reference: string | string[] | null;\r\n      sourceFile: typescript.SourceFile;\r\n      resolvedSourceFile?: typescript.SourceFile;\r\n    }\r\n\r\n    type Export = {\r\n      kind: 'exportStatement' | 'exportsAssignment' | 'amd';\r\n      exportNode: typescript.Node;\r\n      wholeModuleBody?: typescript.Node;\r\n      moduleNameOverride?: string;\r\n      defaultExport?: typescript.Node;\r\n      namedExports?: {\r\n        name: string;\r\n        exportedAs: typescript.Node;\r\n      }[];\r\n    }\r\n\r\n    type DependencyTarget = {\r\n      defaultTarget?: typescript.Node;\r\n      starTarget?: typescript.Node;\r\n      named?: { sourceName: string, target?: typescript.Node }[];\r\n    }\r\n    \r\n    type Input = {\r\n      program: typescript.Program;\r\n      resolutionHost: typescript.ModuleResolutionHost;\r\n      resolutionCache: typescript.ModuleResolutionCache;\r\n      ts: typeof import('typescript');\r\n      sourceFile: typescript.SourceFile;\r\n      transformationContext?: typescript.TransformationContext,\r\n      dependencyCallback?: (dependency: findDependencies.Dependency) => typescript.Node | void | undefined;\r\n      exportCallback?: (dependency: findDependencies.Export) => typescript.Node | void | undefined;\r\n    }\r\n    \r\n    type Output = {\r\n      transformed?: typescript.SourceFile;\r\n      imports?: findDependencies.Dependency[];\r\n      exports?: Export[];\r\n    }\r\n  }\r\n\r\n  export function findDependencies(args: findDependencies.Input): findDependencies.Output {\r\n    const {\r\n      program,\r\n      resolutionHost,\r\n      resolutionCache,\r\n      ts,\r\n      sourceFile,\r\n      transformationContext,\r\n      exportCallback, dependencyCallback\r\n    } = args;\r\n\r\n    const dependencies: findDependencies.Output = {\r\n      transformed: sourceFile\r\n    };\r\n\r\n    const checker = program.getTypeChecker();\r\n\r\n    dependencies.transformed = invokeTransformationOrSimpleVisitor();\r\n\r\n    return dependencies;\r\n\r\n    function invokeTransformationOrSimpleVisitor() {\r\n      let visitChildNodes: (node: typescript.Node, visitor: (node: typescript.Node) => typescript.Node | undefined) => typescript.Node | undefined;\r\n      if (typeof exportCallback !== 'function' && typeof dependencyCallback !== 'function') {\r\n        // use a simple visitor, without transforms\r\n        visitChildNodes = (node, visitor) =>\r\n          ts.forEachChild(node, visitor);\r\n\r\n        visitDependencies(sourceFile) || sourceFile as any;\r\n      }\r\n      else if (transformationContext) {\r\n        // transform with a given transformation context\r\n        visitChildNodes = (node, visitor) =>\r\n          ts.visitEachChild(node, visitor, transformationContext);\r\n\r\n        return visitDependencies(sourceFile) || sourceFile as any;\r\n      }\r\n      else {\r\n        // transform without a transformation context passed:\r\n        // by invoking `ts.transform` and passing a manufactured custom transformer,\r\n        // which will invoke the visitor we have\r\n        const transformResult = ts.transform(sourceFile, [\r\n          context => sourceFileNode => {\r\n            visitChildNodes = (node, visitor) =>\r\n              ts.visitEachChild(node, visitor, context);\r\n\r\n            return visitDependencies(sourceFileNode) as typescript.SourceFile || sourceFile;\r\n          }\r\n        ], program.getCompilerOptions());\r\n\r\n        transformResult.dispose();\r\n        return transformResult.transformed[0];\r\n      }\r\n    }\r\n\r\n    function visitDependencies(input: typescript.Node) {\r\n      let processed: typescript.Node | undefined = ts.forEachChild<typescript.Node>(input, visitDependencies) || input;\r\n\r\n      if (ts.isImportDeclaration(input)) {\r\n        // console.log('import declaration ' + ts.SyntaxKind[input.kind] + ' at ' + input.pos);\r\n        processed = includeImportDeclaration(input);\r\n      }\r\n      else if (ts.isImportEqualsDeclaration(input)) {\r\n        // console.log('import equals declaration ' + ts.SyntaxKind[input.kind] + ' at ' + input.pos);\r\n        // TODO: handle this weird old syntax\r\n      }\r\n      else if (isImportExpression(input, ts)) {\r\n        // console.log('import expression ' + ts.SyntaxKind[input.kind] + ' at ' + input.pos);\r\n        processed = includeImportExpression(input);\r\n      }\r\n      else if (isRequireExpression(input, ts, checker)) {\r\n        // console.log('require declaration ' + ts.SyntaxKind[input.kind] + ' at ' + input.pos);\r\n        processed = includeRequireDeclaration(input);\r\n      }\r\n      else if (ts.isExportAssignment(input)) {\r\n        processed = inlcudeExportAssignment(input);\r\n      }\r\n      else if (ts.isExportDeclaration(input)) {\r\n        processed = inlcudeExportDeclaration(input);\r\n      }\r\n      else if (isDeclarationWithModifier(input, ts.SyntaxKind.ExportKeyword, ts)) {\r\n        processed = includeDeclarationWithExportModifier(input);\r\n      }\r\n      else if (isModuleExportsAssignment(input, ts, checker)) {\r\n        processed = includeModuleExportsAssignment(input);\r\n      }\r\n      else if (isModuleExportsPropertyAssignment(input, ts, checker)) {\r\n        processed = includeModuleExportsPropertyAssignment(input);\r\n      }\r\n      else {\r\n        const amdDefine = isAmdDefineCall(input, ts, checker);\r\n        if (amdDefine) {\r\n          processed = includeAmdImportsExports(amdDefine);\r\n        }\r\n      }\r\n      \r\n      if (processed !== input)\r\n        return processed;\r\n    }\r\n\r\n\r\n    function createDependency(\r\n      import_: typescript.Node,\r\n      moduleNode: typescript.Node,\r\n      assignsTo: findDependencies.DependencyTarget | undefined,\r\n      async: boolean) {\r\n      const reference = getPossibleStringLiteralValues(moduleNode, ts, checker);\r\n\r\n      let resolvedSourceFile: typescript.SourceFile | undefined;\r\n\r\n      if (typeof reference === 'string') {\r\n        const resolvedReference = ts.resolveModuleName(\r\n          reference,\r\n          import_.getSourceFile().fileName,\r\n          program.getCompilerOptions(),\r\n          resolutionHost,\r\n          resolutionCache);\r\n\r\n        if (resolvedReference.resolvedModule\r\n          && resolvedReference.resolvedModule.resolvedFileName) {\r\n          resolvedSourceFile = program.getSourceFile(resolvedReference.resolvedModule.resolvedFileName);\r\n        }\r\n      }\r\n      \r\n      const dep = {\r\n        async,\r\n        dynamic: typeof reference !== 'string',\r\n        importNode: import_,\r\n        moduleNode,\r\n        assignsTo,\r\n        reference,\r\n        sourceFile: sourceFile,\r\n        resolvedSourceFile\r\n      };\r\n        \r\n      if (!dependencies.imports)\r\n        dependencies.imports = [dep];\r\n      else\r\n        dependencies.imports.push(dep);\r\n      \r\n      if (typeof dependencyCallback === 'function') {\r\n        const converted = dependencyCallback(dep);\r\n        if (converted) {\r\n          return converted;\r\n        }\r\n      }\r\n    }\r\n\r\n    function includeImportDeclaration(node: typescript.ImportDeclaration) {\r\n      return createDependency(\r\n        node,\r\n        node.moduleSpecifier,\r\n        getImportDeclarationAssigns(node),\r\n        /* async */ false);\r\n    }\r\n\r\n    function getImportDeclarationAssigns(node: typescript.ImportDeclaration): findDependencies.DependencyTarget | undefined {\r\n      let assignsTo: findDependencies.DependencyTarget | undefined;\r\n      if (node.importClause) {\r\n        if (node.importClause.name) {\r\n          assignsTo = {\r\n            defaultTarget: node.importClause.name\r\n          };\r\n        }\r\n\r\n        if (node.importClause.namedBindings) {\r\n          if (ts.isNamedImports(node.importClause.namedBindings)) {\r\n            const named: { sourceName: string, target: typescript.Node }[] = [];\r\n            for (const bin of node.importClause.namedBindings.elements) {\r\n              named.push({\r\n                sourceName: bin.name.text,\r\n                target: bin.propertyName || bin.name\r\n              });\r\n            }\r\n\r\n            if (!assignsTo)\r\n              assignsTo = { named };\r\n            else\r\n              assignsTo.named = named;\r\n          }\r\n          else if (ts.isNamespaceImport(node.importClause.namedBindings)) {\r\n            if (!assignsTo)\r\n              assignsTo = {\r\n                starTarget: node.importClause.namedBindings.name\r\n              };\r\n            else\r\n              assignsTo.starTarget = node.importClause.namedBindings.name;\r\n          }\r\n        }\r\n      }\r\n      return assignsTo;\r\n    }\r\n\r\n    function includeImportExpression(node: typescript.CallExpression) {\r\n      return createDependency(\r\n        node,\r\n        node.arguments[0],\r\n        getExpressionAssigns(node),\r\n        /* async */ true);\r\n    }\r\n\r\n    function includeRequireDeclaration(node: typescript.CallExpression) {\r\n      return createDependency(\r\n        node,\r\n        node.arguments[0],\r\n        getExpressionAssigns(node),\r\n        /* async */ false);\r\n    }\r\n\r\n    function getExpressionAssigns(node: typescript.Expression): findDependencies.DependencyTarget | undefined {\r\n      if (ts.isVariableDeclaration(node.parent) && node.parent.initializer === node) {\r\n        return { starTarget: node.parent.name };\r\n      }\r\n\r\n      // TODO: detect other expressions\r\n    }\r\n\r\n    function inlcudeExportAssignment(node: typescript.ExportAssignment) {\r\n\r\n      return createExport({\r\n        exportNode: node,\r\n        kind: 'exportsAssignment',\r\n        defaultExport: node\r\n      });\r\n    }\r\n\r\n    function inlcudeExportDeclaration(node: typescript.ExportDeclaration) {\r\n      if (node.exportClause) {\r\n        if (ts.isNamespaceExport(node.exportClause)) {\r\n          const name = getPossibleNameString(node.exportClause.name, ts);\r\n          if (typeof name === 'string') {\r\n            return createExport({\r\n              exportNode: node,\r\n              kind: 'exportStatement',\r\n              namedExports: [{\r\n                name: name,\r\n                exportedAs: node\r\n              }]\r\n            });\r\n          }\r\n        }\r\n        else {\r\n          const namedExports = [] as {\r\n            name: string;\r\n            exportedAs: typescript.Node;\r\n          }[];\r\n\r\n          for (const el of node.exportClause.elements) {\r\n            const name = getPossibleNameString(el.name, ts);\r\n            if (typeof name === 'string')\r\n              namedExports.push({\r\n                name,\r\n                exportedAs: el\r\n              });\r\n          }\r\n\r\n          return createExport({\r\n            exportNode: node,\r\n            kind: 'exportStatement',\r\n            namedExports\r\n          });\r\n        }\r\n      }\r\n    }\r\n\r\n    function includeDeclarationWithExportModifier(node: typescript.Node) {\r\n      const isDefault = isDeclarationWithModifier(node, ts.SyntaxKind.DefaultKeyword, ts);\r\n      const nameNode = isDefault ? void 0 : (node as typescript.FunctionDeclaration).name;\r\n      const name = nameNode && getPossibleNameString(nameNode, ts);\r\n      return createExport({\r\n        exportNode: node,\r\n        kind: 'exportStatement',\r\n        defaultExport: isDefault ? node : void 0,\r\n        namedExports: typeof name === 'string' ? [{\r\n          name,\r\n          exportedAs: node\r\n        }] : void 0\r\n      });\r\n    }\r\n    \r\n    function includeModuleExportsAssignment(node: typescript.PropertyAssignment) {\r\n      const name = getPossibleNameString(node.name, ts);\r\n      if (typeof name === 'string')\r\n        return createExport({\r\n          exportNode: node,\r\n          wholeModuleBody: node,\r\n          kind: 'exportsAssignment',\r\n          namedExports: [{\r\n            name,\r\n            exportedAs: node.initializer\r\n          }]\r\n        });\r\n    }\r\n    \r\n    function includeModuleExportsPropertyAssignment(node: typescript.PropertyAssignment) {\r\n      const name = getPossibleNameString(node.name, ts);\r\n      if (typeof name === 'string')\r\n        return createExport({\r\n          exportNode: node,\r\n          kind: 'exportsAssignment',\r\n          namedExports: [{\r\n            name,\r\n            exportedAs: node.initializer\r\n          }]\r\n        });\r\n    }\r\n\r\n    function includeAmdImportsExports(amdDefine: AmdDefineCall) {\r\n      if (amdDefine.moduleName) {\r\n        createExport({\r\n          exportNode: amdDefine.node,\r\n          wholeModuleBody: amdDefine.moduleBodyArgument,\r\n          kind: 'amd',\r\n          moduleNameOverride: amdDefine.moduleName\r\n        });\r\n      }\r\n\r\n      if (amdDefine.imports && amdDefine.imports.length) {\r\n        createDependency(\r\n          amdDefine.moduleBodyArgument.parent,\r\n          amdDefine.moduleBodyArgument,\r\n          {\r\n            named: amdDefine.imports\r\n          },\r\n          false);\r\n      }\r\n      return void 0;\r\n    }\r\n\r\n    function createExport(\r\n      exportElement: findDependencies.Export) {\r\n      if (!dependencies.exports)\r\n        dependencies.exports = [exportElement];\r\n      else\r\n        dependencies.exports.push(exportElement);\r\n\r\n      if (typeof exportCallback === 'function') {\r\n        const converted = exportCallback(exportElement);\r\n        if (converted) {\r\n          return converted;\r\n        }\r\n      }\r\n    }\r\n\r\n  }\r\n\r\n}","namespace danfo.build.code {\r\n\r\n  export function importTypeScript() {\r\n    const ts = require('typescript') as (typeof import('typescript') & { resolveDefaultLibFromOfficial(libFileName: string): string | undefined });\r\n    ts.resolveDefaultLibFromOfficial = resolveDefaultLibFromOfficial;\r\n    return ts;\r\n\r\n    function resolveDefaultLibFromOfficial(libFileName: string): string | undefined {\r\n      try {\r\n        const libPath = require.resolve('typescript/lib/' + libFileName);\r\n        return libPath;\r\n      }\r\n      catch (error) {}\r\n    }\r\n  }\r\n\r\n}","namespace danfo.build.code {\n\n  export declare namespace createKeyCache {\n\n    namespace Response {\n      type InProgress = { completed: false, initial: boolean, reset(): void };\n      type Resolved<TEntry> = { completed: true, success: true, result: TEntry, reset(): void };\n      type Failed = { completed: true, success: false, error: any, reset(): void };\n    }\n\n    type Cache<TCache> = {\n      cachedOrPopulate<TEntry>(options: cachedOrPopulateOptions<TCache, TEntry>): Response<TEntry>;\n    }\n\n    type cachedOrPopulateOptions<TCache, TEntry> = {\n      cacheField: keyof TCache;\n      key?: string;\n      populate(): TEntry | Promise<TEntry>;\n    };\n\n    type Response<TEntry> = createKeyCache.Response.InProgress | createKeyCache.Response.Resolved<TEntry> | createKeyCache.Response.Failed;\n  }\n\n  export function createKeyCache<TCache extends object>(cacheOwner: TCache, promiseWrap: { <T>(work: Promise<T>): Promise<T> } | null): createKeyCache.Cache<TCache> {\n    return {\n      cachedOrPopulate\n    };\n\n    function cachedOrPopulate<TCache, TEntry>({ cacheField, key, populate }: createKeyCache.cachedOrPopulateOptions<TCache, TEntry>): createKeyCache.Response<TEntry> {\n      let cache = (cacheOwner as any)[cacheField] as { [key: string]: any };\n      if (!cache && typeof key === 'string') {\n        cache = {};\n        (cacheOwner as any)[cacheField] = cache;\n      }\n\n      const entry = (typeof key === 'string' ? cache[key] : cache) as createKeyCache.Response<TEntry> | undefined;\n      if (entry) {\n        if (!entry.completed && (entry as createKeyCache.Response.InProgress).initial)\n          (entry as createKeyCache.Response.InProgress).initial = false;\n\n        return entry;\n      }\n\n      const newEntry: createKeyCache.Response.InProgress = {\n        completed: false,\n        initial: true,\n        reset\n      };\n\n      if (typeof key === 'string') cache[key] = newEntry;\n      else (cacheOwner as any)[cacheField] = newEntry;\n      try {\n        const populateResult = populate();\n        const populateResultPromise = populateResult as unknown as Promise<TEntry>;\n        if (populateResult && typeof populateResultPromise.then === 'function') {\n          const wrappedPromise = typeof promiseWrap === 'function' ?\n            promiseWrap(populateResultPromise) :\n            populateResultPromise;\n\n          wrappedPromise.then(\n            result => {\n              const populatedEntry: createKeyCache.Response.Resolved<TEntry> = {\n                completed: true,\n                success: true,\n                result,\n                reset\n              };\n              if (typeof key === 'string') cache[key] = populatedEntry;\n              else (cacheOwner as any)[cacheField] = populatedEntry;\n            },\n            error => {\n              const populatedFail: createKeyCache.Response.Failed = {\n                completed: true,\n                success: false,\n                error,\n                reset\n              };\n              if (typeof key === 'string') cache[key] = populatedFail;\n              else (cacheOwner as any)[cacheField] = populatedFail;\n            }\n          );\n          return newEntry;\n        }\n        else {\n          const populatedEntry: createKeyCache.Response.Resolved<TEntry> = {\n            completed: true,\n            success: true,\n            result: populateResult as TEntry,\n            reset\n          };\n          if (typeof key === 'string') cache[key] = populatedEntry;\n          else (cacheOwner as any)[cacheField] = populatedEntry;\n\n          return populatedEntry;\n        }\n      }\n      catch (error) {\n        const populatedFail: createKeyCache.Response.Failed = {\n          completed: true,\n          success: false,\n          error,\n          reset\n        };\n        if (typeof key === 'string') cache[key] = populatedFail;\n        else (cacheOwner as any)[cacheField] = populatedFail;\n  \n        return populatedFail;\n      }\n\n      function reset() {\n        delete (cacheOwner as any)[cacheField];\n      }\n    }\n  }\n}","namespace danfo.build.code {\r\n\r\n  export function preciseScriptSnapshot(text: string): typescript.IScriptSnapshot {\r\n    return new PreciseScriptSnapshot(text);\r\n  }\r\n\r\n  class PreciseScriptSnapshot implements typescript.IScriptSnapshot {\r\n\r\n    constructor(private text: string) {\r\n    }\r\n\r\n    getText(start: number, end: number) {\r\n      return this.text.slice(start, end);\r\n    }\r\n\r\n    getLength() {\r\n      return this.text.length;\r\n    }\r\n\r\n    getChangeRange(oldSnapshot: typescript.IScriptSnapshot) {\r\n      if (oldSnapshot === this) return {\r\n        span: {\r\n          start: this.text.length,\r\n          length: 0\r\n        },\r\n        newLength: 0\r\n      };\r\n\r\n      const oldSnapshotText: string = (oldSnapshot as PreciseScriptSnapshot).text;\r\n\r\n      if (typeof oldSnapshotText !== 'string')\r\n        return void 0;\r\n\r\n      let leadMatchLength: number, trailMatchLength: number;\r\n      for (leadMatchLength = 0; leadMatchLength < this.text.length && leadMatchLength < oldSnapshotText.length; leadMatchLength++) {\r\n        if (this.text.charCodeAt(leadMatchLength) !== oldSnapshotText.charCodeAt(leadMatchLength))\r\n          break;\r\n      }\r\n\r\n      for (trailMatchLength = 0; trailMatchLength < this.text.length - leadMatchLength && trailMatchLength < oldSnapshotText.length - leadMatchLength; trailMatchLength++) {\r\n        if (this.text.charCodeAt(this.text.length - 1 - trailMatchLength) !== oldSnapshotText.charCodeAt(oldSnapshotText.length - 1 - trailMatchLength))\r\n          break;\r\n      }\r\n\r\n      return {\r\n        span: {\r\n          start: leadMatchLength,\r\n          length: oldSnapshotText.length - leadMatchLength - trailMatchLength\r\n        },\r\n        newLength: this.text.length - leadMatchLength - trailMatchLength\r\n      };\r\n    }\r\n  }\r\n}","namespace danfo.build.code {\r\n\r\n  export type AmdDefineCall = {\r\n    node: typescript.CallExpression;\r\n    moduleName?: string;\r\n    imports?: { sourceName: string, target?: typescript.Node }[];\r\n    moduleBodyArgument: typescript.Node;\r\n  }\r\n\r\n  export function isAmdDefineCall(node: typescript.Node, ts: typeof import('typescript'), checker: typescript.Program | typescript.TypeChecker): AmdDefineCall | undefined {\r\n    const typeChecker = typeof (checker as typescript.Program).getTypeChecker === 'function' ?\r\n      (checker as typescript.Program).getTypeChecker() :\r\n      (checker as typescript.TypeChecker);\r\n\r\n    if (ts.isCallExpression(node)\r\n      && isGlobalName(node.expression, 'define', ts, typeChecker)\r\n      && node.arguments.length >= 2 && node.arguments.length <= 3) {\r\n      const factoryArgument = node.arguments[node.arguments.length - 1];\r\n      const factorySignature = getPossibleFunctionArguments(factoryArgument, ts, typeChecker);\r\n      if (factorySignature) {\r\n        if (!factorySignature)\r\n          return void 0; // function should be the last parameter to define(...)\r\n\r\n        if (node.arguments.length === 2) {\r\n          const firstArgumentStringValues = getPossibleStringLiteralValues(node.arguments[0], ts, typeChecker);\r\n          if (firstArgumentStringValues) {\r\n            if (typeof firstArgumentStringValues === 'string')\r\n              return {\r\n                node,\r\n                moduleName: firstArgumentStringValues,\r\n                imports: [],\r\n                moduleBodyArgument: factoryArgument\r\n              };\r\n            else\r\n              return void 0; // if first argument is of string type, its value should be statically known\r\n          }\r\n\r\n          const firstArgumentArrayValues = getPossibleStringArrayValues(node.arguments[0], ts, typeChecker);\r\n          if (firstArgumentArrayValues) {\r\n            const imports: { sourceName: string, target?: typescript.Node }[] = [];\r\n            for (let i = 0; i < firstArgumentArrayValues.length; i++) {\r\n\r\n              imports.push({\r\n                sourceName: firstArgumentArrayValues[i],\r\n                target: i < factorySignature.length && (factorySignature[i] as typescript.Node).kind ?\r\n                  factorySignature[i] as typescript.Node :\r\n                  void 0\r\n              });\r\n            }\r\n\r\n            if (imports.length) {\r\n              return {\r\n                node,\r\n                imports,\r\n                moduleBodyArgument: factoryArgument\r\n              };\r\n            }\r\n          }\r\n        }\r\n        else if (node.arguments.length === 3) {\r\n          const firstArgumentStringValues = getPossibleStringLiteralValues(node.arguments[0], ts, typeChecker);\r\n          if (typeof firstArgumentStringValues === 'string') {\r\n\r\n            const secondArgumentArrayValues = getPossibleStringArrayValues(node.arguments[1], ts, typeChecker);\r\n            if (secondArgumentArrayValues) {\r\n              const imports: { sourceName: string, target?: typescript.Node }[] = [];\r\n              for (let i = 0; i < secondArgumentArrayValues.length; i++) {\r\n                imports.push({\r\n                  sourceName: secondArgumentArrayValues[i],\r\n                  target: i < factorySignature.length && (factorySignature[i] as typescript.Node).kind ?\r\n                    factorySignature[i] as typescript.Node :\r\n                    void 0\r\n                });\r\n              }\r\n\r\n              return {\r\n                node,\r\n                moduleName: firstArgumentStringValues,\r\n                imports: imports.length ? imports : void 0,\r\n                moduleBodyArgument: factoryArgument\r\n              };\r\n            }\r\n          }\r\n        }\r\n      }\r\n    }\r\n\r\n    return void 0;\r\n  }\r\n  \r\n  export function isGlobalName(node: typescript.Node, name: string, ts: typeof import('typescript'), checker: typescript.Program | typescript.TypeChecker): boolean {\r\n    const typeChecker = typeof (checker as typescript.Program).getTypeChecker === 'function' ?\r\n      (checker as typescript.Program).getTypeChecker() :\r\n      (checker as typescript.TypeChecker);\r\n\r\n    return isGlobalNameWorker(node, name, [], ts, typeChecker);\r\n  }\r\n\r\n  function isGlobalNameWorker(node: typescript.Node, name: string, visitedNodes: typescript.Node[], ts: typeof import('typescript'), checker: typescript.TypeChecker): boolean {\r\n    const fnSymbol = checker.getSymbolAtLocation(node);\r\n    if (!fnSymbol)\r\n      return ts.isIdentifier(node) && node.text === name;\r\n\r\n    const declArray = fnSymbol.getDeclarations();\r\n    if (!declArray || !declArray.length)\r\n      return fnSymbol.name === name;\r\n\r\n    for (const decl of declArray) {\r\n      if (ts.isVariableDeclaration(decl)) {\r\n        if (decl.initializer) {\r\n          return invokeRecursivePredicateEscapeCycles(\r\n            isGlobalNameWorker,\r\n            decl.initializer,\r\n            name,\r\n            visitedNodes,\r\n            ts, checker);\r\n        }\r\n\r\n        // check if global scope?\r\n        if (isVariableGlobalScope(decl, ts) && ts.isIdentifier(decl.name)) {\r\n          return decl.name.text === name;\r\n        }\r\n        // console.log('variable decl: ', ts.SyntaxKind[decl.kind], decl);\r\n        return false;\r\n      }\r\n      else if (ts.isParameter(decl)) {\r\n        // parameter can be defaulted to global symbol - check\r\n        if (decl.initializer) {\r\n          if (invokeRecursivePredicateEscapeCycles(\r\n            isGlobalNameWorker,\r\n            decl.initializer,\r\n            name,\r\n            visitedNodes,\r\n            ts, checker))\r\n            return true;\r\n        }\r\n\r\n        // or it could be IIFE, check arguments then\r\n        const fnExpr = decl.parent;\r\n        if (ts.isFunctionExpression(fnExpr)) {\r\n          const fnInvok = getIIFEInvocation(fnExpr, ts);\r\n          if (fnInvok) {\r\n            const paramIndex = fnExpr.parameters.indexOf(decl);\r\n            const invokParam = fnInvok.arguments[paramIndex];\r\n            if (invokParam) {\r\n              return invokeRecursivePredicateEscapeCycles(\r\n                isGlobalNameWorker,\r\n                invokParam,\r\n                name,\r\n                visitedNodes,\r\n                ts, checker);\r\n            }\r\n          }\r\n        }\r\n        return false;\r\n      }\r\n    }\r\n\r\n    return false;\r\n  }\r\n\r\n  function invokeRecursivePredicateEscapeCycles<T, Arg, TState1, TState2>(\r\n    predicate: (item: T, arg: Arg, visited: T[], s1: TState1, s2: TState2) => boolean,\r\n    item: T,\r\n    arg: Arg,\r\n    visited: undefined | T[],\r\n    s1: TState1, s2: TState2): boolean {\r\n\r\n    if (visited) {\r\n      if (visited.indexOf(item))\r\n        return false;\r\n      visited.push(item);\r\n    }\r\n    else {\r\n      visited = [item];\r\n    }\r\n\r\n    return predicate(item, arg, visited, s1, s2);\r\n  }\r\n\r\n\r\n  export function isVariableGlobalScope(variable: typescript.VariableDeclaration, ts: typeof import('typescript')) {\r\n    return ts.isSourceFile(variable.parent.parent.parent);\r\n  }\r\n\r\n  export function getIIFEInvocation(fnExpr: typescript.Node, ts: typeof import('typescript')): typescript.CallExpression | undefined {\r\n    let fnCurrent = fnExpr;\r\n    for (let i = 0; fnCurrent.parent && i < 5; i++) { // max check depth\r\n      if (ts.isCallExpression(fnCurrent.parent) && fnCurrent.parent.expression === fnCurrent)\r\n        return fnCurrent.parent;\r\n\r\n      if (!ts.isParenthesizedExpression(fnCurrent.parent))\r\n        return;\r\n\r\n      fnCurrent = fnCurrent.parent;\r\n    }\r\n  }\r\n\r\n  export function isDeclarationWithModifier(node: typescript.Node, modifier: typescript.SyntaxKind, ts: typeof import('typescript')): boolean {\r\n    const withModifiers = node as typescript.HasModifiers;\r\n    if (withModifiers.modifiers) {\r\n      for (const mod of withModifiers.modifiers) {\r\n        if (mod.kind === modifier)\r\n          return true;\r\n      }\r\n    }\r\n\r\n    return false;\r\n  }\r\n\r\n  /** module.exports = ... */\r\n  export function isModuleExportsAssignment(node: typescript.Node, ts: typeof import('typescript'), checker: typescript.Program | typescript.TypeChecker): node is typescript.PropertyAssignment {\r\n    if (ts.isPropertyAssignment(node)\r\n      && ts.isIdentifier(node.parent)\r\n      && isGlobalName(node.parent, 'module', ts, checker)\r\n      && getPossibleNameString(node.name, ts) === 'exports') {\r\n      return true;\r\n    }\r\n\r\n    return false;\r\n\r\n  }\r\n\r\n  /** module.exports.xxxxx = ... */\r\n  export function isModuleExportsPropertyAssignment(node: typescript.Node, ts: typeof import('typescript'), checker: typescript.Program | typescript.TypeChecker): node is typescript.PropertyAssignment {\r\n    if (ts.isBinaryExpression(node)\r\n      && node.operatorToken.kind === ts.SyntaxKind.EqualsToken\r\n      && ts.isPropertyAccessExpression(node.parent)\r\n      && node.parent.parent\r\n      && ts.isIdentifier(node.parent.parent)\r\n      && isGlobalName(node.parent.parent, 'module', ts, checker)\r\n      && getPossibleNameString(node.parent.name, ts) === 'export') {\r\n      return true;\r\n    }\r\n\r\n    return false;\r\n  }\r\n\r\n  export function getPossibleNameString(node: typescript.Node, ts: typeof import('typescript')): string | undefined {\r\n    if (ts.isIdentifier(node))\r\n      return node.text;\r\n\r\n    if (ts.isStringLiteralLike(node)) // TODO: handle escapes?\r\n      return node.text;\r\n\r\n    if (ts.isNumericLiteral(node)) // TODO: normalize?\r\n      return node.text;\r\n  }\r\n\r\n  export function isRequireExpression(node: typescript.Node, ts: typeof import('typescript'), checker: typescript.Program | typescript.TypeChecker): node is typescript.CallExpression {\r\n    return ts.isCallExpression(node) && isGlobalName(node.expression, 'require', ts, checker);\r\n  }\r\n\r\n  export function isImportExpression(node: typescript.Node, ts: typeof import('typescript')): node is typescript.CallExpression {\r\n    return ts.isCallExpression(node) && node.expression.kind === ts.SyntaxKind.ImportKeyword;\r\n  }\r\n\r\n  export function getPossibleFunctionArguments(node: typescript.Node, ts: typeof import('typescript'), checker: typescript.Program | typescript.TypeChecker) {\r\n    if (ts.isFunctionExpression(node))\r\n      return node.parameters;\r\n    \r\n    const typeChecker = typeof (checker as typescript.Program).getTypeChecker === 'function' ?\r\n      (checker as typescript.Program).getTypeChecker() :\r\n      (checker as typescript.TypeChecker);\r\n\r\n    const expressionType = typeChecker.getTypeAtLocation(node);\r\n    const callSignatures = expressionType.getCallSignatures();\r\n    let longestSignature = callSignatures[0];\r\n    for (let i = 1; i < callSignatures.length; i++) {\r\n      if (callSignatures[i].parameters.length > longestSignature.parameters.length)\r\n        longestSignature = callSignatures[i];\r\n    }\r\n    return longestSignature ? longestSignature.parameters : null;\r\n  }\r\n\r\n  export function getPossibleStringLiteralValues(expression: typescript.Node, ts: typeof import('typescript'), checker: typescript.Program | typescript.TypeChecker): string | string[] | null {\r\n    if (ts.isStringLiteralLike(expression))\r\n      return expression.text;\r\n\r\n    const typeChecker = typeof (checker as typescript.Program).getTypeChecker === 'function' ?\r\n      (checker as typescript.Program).getTypeChecker() :\r\n      (checker as typescript.TypeChecker);\r\n\r\n    const expressionType = typeChecker.getTypeAtLocation(expression);\r\n    return getPossibleStringLiteralValuesOfType(expressionType);\r\n  }\r\n\r\n  export function getPossibleStringLiteralValuesOfType(type: typescript.Type): string | string[] | null {\r\n    if (type.isStringLiteral()) {\r\n      return type.value;\r\n    }\r\n\r\n    if (type.isUnion()) {\r\n      let unionTypeValues: string[] = [];\r\n      let hasNull = false;\r\n      for (const uniType of type.types) {\r\n        const values = getPossibleStringLiteralValuesOfType(uniType);\r\n        if (typeof values === 'string')\r\n          unionTypeValues.push(values);\r\n        else if (values && values.length)\r\n          unionTypeValues = unionTypeValues.concat(values);\r\n      }\r\n      return !unionTypeValues.length ? null : unionTypeValues.length === 1 ? unionTypeValues[0] : unionTypeValues;\r\n    }\r\n\r\n    return null;\r\n  }\r\n\r\n  export function getPossibleStringArrayValues(node: typescript.Node, ts: typeof import('typescript'), checker: typescript.Program | typescript.TypeChecker) {\r\n    const typeChecker = typeof (checker as typescript.Program).getTypeChecker === 'function' ?\r\n      (checker as typescript.Program).getTypeChecker() :\r\n      (checker as typescript.TypeChecker);\r\n\r\n    if (ts.isArrayLiteralExpression(node)) {\r\n      const strings: string[] = [];\r\n      for (const el of node.elements) {\r\n        const elString = getPossibleStringLiteralValues(el, ts, checker);\r\n        if (typeof elString === 'string')\r\n          strings.push(elString);\r\n        else\r\n          break;\r\n      }\r\n\r\n      return strings;\r\n    }\r\n  }\r\n\r\n\r\n}","namespace danfo.build.css {\r\n\r\n  export function cssBuilder(file: string, content: string) {\r\n\r\n  }\r\n\r\n}","namespace danfo.build.html {\r\n\r\n  type ParsedEntry = {\r\n    parsed: danfo.parsing.parseHTML.ReferenceOrContent;\r\n    isDirectory?: boolean;\r\n    isTsConfig?: boolean;\r\n    syntheticResolvedFileName?: string;\r\n    emitted?: {\r\n      output?: string;\r\n      sourcemap?: { fileName: string, content: string };\r\n    };\r\n  };\r\n\r\n  const regex_LF_withPossibleTrailingWhitespace_thenEOF = /\\n\\s*$/;\r\n  const regex_leadingLineHasNonWhitespace = /^[^\\S\\r\\n]*\\S/;\r\n  const regex_trailingLineHasNonWhitespace = /\\S[^\\S\\r\\n]*$/;\r\n\r\n  export function htmlBuilder({ fileSystem, precachedFixedSource: precachedFixedSnapshots }: htmlBuilder.Options): Builder {\r\n\r\n    let htmlFile!: danfo.build.SourceFileOrSpan;\r\n    let resolvedHtmlFilePath!: string;\r\n    let resolvedProjectDir!: string;\r\n\r\n    let onDemandCodeBuilder: danfo.build.code.Builder | undefined;\r\n    let processEntries: ParsedEntry[] = [];\r\n\r\n    const builder: Builder = {\r\n      build: buildHtml\r\n    };\r\n\r\n    return builder;\r\n\r\n    function buildHtml(inputs: BuilderInputs): BuildResult {\r\n      htmlFile = inputs.htmlFile;\r\n      resolvedProjectDir = inputs.resolvedProjectDir;\r\n      resolvedHtmlFilePath = htmlFile.resolvedPath;\r\n\r\n      const htmlContent = fileSystem.readFile(resolvedHtmlFilePath)!;\r\n      if (typeof htmlContent !== 'string')\r\n        return {\r\n          htmlEmit: void 0,\r\n          errors: [{\r\n            code: 'No file',\r\n            message: 'File cannot be read from ' + resolvedHtmlFilePath,\r\n            resolvedSourcePath: resolvedHtmlFilePath\r\n          }]\r\n        }\r\n\r\n      const htmlParsed = danfo.parsing.parseHTML(htmlContent);\r\n      const errors: danfo.build.code.BuildError[] = [];\r\n\r\n      processEntries = htmlParsed.map(parsed => {\r\n        const entry: ParsedEntry = {\r\n          parsed\r\n        };\r\n        return entry\r\n      });\r\n\r\n      extractAndProcessCssEntries();\r\n\r\n      const codeSources: SourceFileOrSpan[] = [];\r\n      const codeEntriesByResolvedPath: { [resolvedFileName: string]: ParsedEntry } = {};\r\n      let htmlContentLineMap!: parsing.lineMap.Output;\r\n      for (const entry of processEntries) {\r\n        if (!entry.parsed || !htmlBuilder.isCompileScriptType(entry.parsed.type))\r\n          continue;\r\n\r\n        let content = entry.parsed.content;\r\n        let resolvedPath: string | undefined;\r\n        if (typeof content !== 'string' && typeof entry.parsed.reference === 'string') {\r\n          // reference is relative to the HTML file directory\r\n          resolvedPath = fileSystem.resolvePath(htmlFile.resolvedPath + '/../' + entry.parsed.reference);\r\n\r\n          const entryStat = fileSystem.stat(resolvedPath);\r\n          if (!entryStat) {\r\n            errors.push({\r\n              code: 'File not found',\r\n              message: 'Cannot read referenced file ' + resolvedPath + '.'\r\n            });\r\n          }\r\n          else if (entryStat.isDirectory) {\r\n            entry.isDirectory = true;\r\n            const dirContent = danfo.build.populateSourceStructure({\r\n              projectPath: inputs.resolvedProjectDir,\r\n              fileSystem,\r\n              sources: [resolvedPath]\r\n            });\r\n            for (const dirEntry of dirContent.sources) {\r\n              codeSources.push(dirEntry);\r\n            }\r\n          }\r\n          else {\r\n            content = fileSystem.readFile(resolvedPath);\r\n          }\r\n        }\r\n\r\n        if (typeof content === 'string') {\r\n          if (typeof resolvedPath !== 'string') {\r\n            resolvedPath = generateSyntheticFilePath(entry.parsed);\r\n            entry.syntheticResolvedFileName = resolvedPath;\r\n          }\r\n\r\n          codeEntriesByResolvedPath[resolvedPath] = entry;\r\n          if (entry.parsed.type === 'tsconfig')\r\n            entry.isTsConfig = true;\r\n\r\n          codeSources.push({\r\n            resolvedPath,\r\n            type: entry.parsed.type,\r\n            stat: inputs.htmlFile.stat,\r\n            span: {\r\n              content,\r\n              start: entry.parsed.start + entry.parsed.originalLeadLength,\r\n              length: entry.parsed.length - entry.parsed.originalLeadLength - entry.parsed.originalTrailLength\r\n            }\r\n          });\r\n        }\r\n      }\r\n\r\n      let unresolvedImports: UnresolvedImports[] | undefined;\r\n      let externalEmits: code.Emit[] | undefined;\r\n\r\n      for (const src of inputs.otherFiles) {\r\n        codeSources.push(src as SourceFileOrSpan);\r\n      }\r\n\r\n      if (codeSources.length) {\r\n        const builtCode = runCodeBuilder({\r\n          resolvedProjectDir: inputs.resolvedProjectDir,\r\n          sources: codeSources,\r\n          handleSettings: settings => {\r\n            settings.outDir = inputs.outputDirPath;\r\n            return settings;\r\n          }\r\n        });\r\n\r\n        if (builtCode.imports) {\r\n          // TODO: handle imports?\r\n          unresolvedImports = builtCode.imports;\r\n        }\r\n\r\n        if (builtCode.errors) {\r\n          for (const err of builtCode.errors) {\r\n            errors.push(err);\r\n          }\r\n        }\r\n\r\n        if (builtCode.emits) {\r\n          for (const emit of builtCode.emits) {\r\n            let entry = codeEntriesByResolvedPath[emit.resolvedSourcePath];\r\n            if (!entry) {\r\n              if (!externalEmits) externalEmits = [];\r\n              externalEmits.push(emit);\r\n            }\r\n            else {\r\n              entry.emitted = {\r\n                output: emit.output,\r\n                sourcemap: emit.sourcemap\r\n              };\r\n            }\r\n          }\r\n        }\r\n      }\r\n\r\n      const { htmlEmit, resources } = combineEmits(\r\n        htmlContent,\r\n        processEntries,\r\n        externalEmits);\r\n\r\n      return {\r\n        htmlEmit,\r\n        resources,\r\n        errors,\r\n        unresolvedImports: unresolvedImports?.length ? unresolvedImports : void 0\r\n      };\r\n\r\n      function extractAndProcessCssEntries() {\r\n        for (const entry of processEntries) {\r\n          if (!entry.parsed || entry.parsed.type !== 'css')\r\n            continue;\r\n\r\n          let content = entry.parsed.content;\r\n          if (typeof content !== 'string' && typeof entry.parsed.reference === 'string') {\r\n            // local to the directory containing HTML file\r\n            const resolvedFileName = fileSystem.resolvePath(htmlFile.resolvedPath + '/../' + entry.parsed.reference);\r\n            content = fileSystem.readFile(resolvedFileName);\r\n            if (typeof content !== 'string') {\r\n              errors.push({\r\n                code: 'File not found',\r\n                message: 'Cannot read referenced file ' + resolvedFileName + '.'\r\n              });\r\n            }\r\n          }\r\n\r\n          if (typeof content === 'string') {\r\n            const processedCSS = processCSS(content);\r\n            entry.emitted = {\r\n              output: processedCSS\r\n            };\r\n          }\r\n        }\r\n      }\r\n\r\n      function generateSyntheticFilePath(parsed: danfo.parsing.parseHTML.ReferenceOrContent): string {\r\n        if (!htmlContentLineMap)\r\n          htmlContentLineMap = parsing.lineMap(htmlContent);\r\n        \r\n        let contentStart = parsed.start + parsed.originalLeadLength;\r\n        const firstContentChar = htmlContent.charCodeAt(contentStart);\r\n        if (firstContentChar === 10) {\r\n          contentStart++;\r\n        }\r\n        else if (firstContentChar === 13) {\r\n          const secondContentChar = htmlContent.charCodeAt(contentStart + 1);\r\n          if (secondContentChar === 10)\r\n            contentStart += 2;\r\n          else\r\n            contentStart++;\r\n        }\r\n\r\n        const lnch = htmlContentLineMap.getLineAndCharacter(contentStart)!;\r\n        const reference =\r\n          htmlFile.resolvedPath + '.L' + lnch.ln +\r\n          (lnch.ch > 1 ? '-' + lnch.ch : '') +\r\n          (parsed.type === 'typescript' ? '.tsx' : '.js');\r\n        \r\n        return reference;\r\n      }\r\n\r\n      function processCSS(rawCSS: string): string {\r\n        // TODO: build css\r\n        return rawCSS;\r\n      }\r\n\r\n    }\r\n\r\n    function runCodeBuilder(inputs: code.BuilderInputs): code.BuildResult {\r\n      if (!onDemandCodeBuilder)\r\n        onDemandCodeBuilder = code.codeBuilder({\r\n          fileSystem: {\r\n            ...fileSystem,\r\n            readFile: overrideReadFile,\r\n            stat: overrideStat\r\n          },\r\n          precachedFixedSource: precachedFixedSnapshots\r\n        });\r\n\r\n      return onDemandCodeBuilder.build(inputs);\r\n\r\n      function getSyntheticFile(resolvedFilePath: string) {\r\n        for (const entry of processEntries) {\r\n          if (entry.syntheticResolvedFileName === resolvedFilePath && typeof entry.parsed.content === 'string')\r\n            return entry;\r\n        }\r\n      }\r\n\r\n      function overrideReadFile(filePath: string) {\r\n        const resolvedFilePath = fileSystem.resolvePath(resolvedProjectDir, filePath)\r\n        const entry = getSyntheticFile(resolvedFilePath);\r\n        if (entry)\r\n          return entry.parsed.content!;\r\n\r\n        return fileSystem.readFile(filePath);\r\n      }\r\n\r\n      function overrideStat(filePath: string) {\r\n        const resolvedFilePath = fileSystem.resolvePath(resolvedProjectDir, filePath);\r\n        const entry = getSyntheticFile(resolvedFilePath);\r\n        if (entry) {\r\n          return {\r\n            isDirectory: false,\r\n            timestamp: htmlFile.stat?.timestamp || 0,\r\n            length: entry.parsed.content!.length\r\n          };\r\n        }\r\n\r\n        return fileSystem.stat(filePath);\r\n      }\r\n    }\r\n\r\n    function combineEmits(htmlContent: string, processEntries: ParsedEntry[], allExternalEmits?: code.Emit[]): { htmlEmit: string, resources?: { name: string, content: string }[] } {\r\n      let htmlEmit = '';\r\n      let resources: { name: string, content: string }[] | undefined;\r\n\r\n      let lastChunkEnd = 0;\r\n      let injectAfterList: code.Emit[] | undefined;\r\n      let injectExternalEmitsIntoNextScript: code.Emit[] | undefined;\r\n      if (allExternalEmits) {\r\n        for (const em of allExternalEmits) {\r\n          if (em.injectAfter) {\r\n            if (!injectAfterList) injectAfterList = [];\r\n            injectAfterList.push(em);\r\n          }\r\n          else {\r\n            if (!injectExternalEmitsIntoNextScript) injectExternalEmitsIntoNextScript = [];\r\n            injectExternalEmitsIntoNextScript.push(em);\r\n          }\r\n        }\r\n      }\r\n\r\n      for (let i = 0; i < processEntries.length; i++) {\r\n        const entry = processEntries[i];\r\n        addEntry(entry, i === processEntries.length - 1);\r\n      }\r\n\r\n      if (lastChunkEnd < htmlContent.length) {\r\n        htmlEmit += htmlContent.slice(lastChunkEnd);\r\n      }\r\n\r\n      return { htmlEmit, resources };\r\n\r\n      function needsNewLineInjection(entry: ParsedEntry) {\r\n        const leadText = htmlContent.slice(Math.max(0, entry.parsed.start - 15), entry.parsed.start);\r\n        return !leadText || regex_LF_withPossibleTrailingWhitespace_thenEOF.test(leadText);\r\n      }\r\n\r\n      function addEntry(entry: ParsedEntry, last: boolean) {\r\n\r\n        let emitResult: { output: string, sourcemap?: { fileName: string, content: string } } | undefined;\r\n        if (typeof entry.emitted?.output === 'string')\r\n          emitResult = getEmittedEntryContent(entry, last);\r\n        else if (entry.isTsConfig)\r\n          emitResult = getTsConfigEntryContent(entry);\r\n        else if (entry.isDirectory)\r\n          emitResult  = getDirectoryEntryContent(entry);\r\n        \r\n        if (emitResult) {\r\n          htmlEmit +=\r\n            htmlContent.slice(lastChunkEnd, entry.parsed.start) +\r\n            (entry.parsed.lead || '') +\r\n            emitResult.output +\r\n            (entry.parsed.trail || '');\r\n\r\n          lastChunkEnd = entry.parsed.start + entry.parsed.length;\r\n\r\n          addEntrySourcemap(entry, emitResult.sourcemap);\r\n        }\r\n      }\r\n\r\n      function getEmittedEntryContent(entry: ParsedEntry, last: boolean): { output: string, sourcemap?: { fileName: string, content: string } } | undefined {\r\n        if (typeof entry.emitted?.output !== 'string') return; // this should be redundant\r\n\r\n        const injectGraciousNewLines = needsNewLineInjection(entry);\r\n        const shouldInjectExternalEmits =\r\n          (injectExternalEmitsIntoNextScript || (last && injectAfterList)) &&\r\n          (!entry.parsed.type || htmlBuilder.isCompileScriptType(entry.parsed.type));\r\n\r\n        if (shouldInjectExternalEmits) {\r\n          let emits =\r\n            [\r\n              ...(!injectExternalEmitsIntoNextScript ? [] :\r\n                [\r\n                  injectGraciousNewLines ? '\\n' : '',\r\n              ...injectExternalEmitsIntoNextScript!\r\n                ]),\r\n              entry.emitted,\r\n              ...(!(last && injectAfterList) ? [] :\r\n                injectAfterList\r\n              )\r\n            ];\r\n\r\n          injectExternalEmitsIntoNextScript = void 0;\r\n          if (last) injectAfterList = void 0;\r\n\r\n          return combineExternalEmits(\r\n            entry,\r\n            emits);\r\n        }\r\n\r\n        if (entry.emitted.sourcemap && injectGraciousNewLines)\r\n          return surroundNewLinesAdjustSourcemap(entry.emitted.output, entry.emitted.sourcemap, entry);\r\n        else if (injectGraciousNewLines)\r\n          return { output: wrapNewLines(entry.emitted.output) };\r\n        else\r\n          return { output: entry.emitted.output, sourcemap: entry.emitted.sourcemap };\r\n      }\r\n\r\n      function surroundNewLinesAdjustSourcemap(output: string, sourcemap: { fileName: string, content: string }, entry: ParsedEntry) {\r\n        const needsLead = regex_leadingLineHasNonWhitespace.test(output);\r\n        const needsTrail = regex_trailingLineHasNonWhitespace.test(output);\r\n\r\n        if (!needsLead && !needsTrail) {\r\n          return { output, sourcemap };\r\n        }\r\n\r\n        if (needsLead) {\r\n          let sourcemapJson: danfo.parsing.sourcemap.Sourcemap;\r\n          try {\r\n            sourcemapJson = JSON.parse(sourcemap.content);\r\n          }\r\n          catch (parseSourcemapError) {\r\n            return { output, sourcemap };\r\n          }\r\n\r\n          sourcemapJson.mappings = danfo.parsing.sourcemap.combineMappings([{\r\n            generatedLine: 1,\r\n            generatedColumn: 0,\r\n            fileCount: 0,\r\n            nameCount: 0,\r\n            mappings: sourcemapJson.mappings\r\n          }]);\r\n\r\n          sourcemap = {\r\n            fileName: sourcemap.fileName,\r\n            content: JSON.stringify(sourcemapJson)\r\n          };\r\n        }\r\n\r\n        return {\r\n          output: (needsLead ? '\\n' : '') + output + (needsTrail ? '\\n' : ''),\r\n          sourcemap\r\n        };\r\n      }\r\n\r\n      function wrapNewLines(content: string) {\r\n        const needsLead = regex_leadingLineHasNonWhitespace.test(content);\r\n        const needsTrail = regex_trailingLineHasNonWhitespace.test(content);\r\n\r\n        if (!needsLead && needsTrail)\r\n          return content;\r\n        else\r\n          return (needsLead ? '\\n' : '') + content + (needsTrail ? '\\n' : '');\r\n      }\r\n\r\n      function getTsConfigEntryContent(entry: ParsedEntry): { output: string, sourcemap?: { fileName: string, content: string } } {\r\n\r\n        const injectGraciousNewLines = needsNewLineInjection(entry);\r\n        let output =\r\n          (injectGraciousNewLines ? '\\n' : '') +\r\n          '/* ' + entry.parsed.reference + ' */';\r\n        if (typeof entry.parsed.content === 'string') {\r\n          output =\r\n            '/* ' + (entry.parsed.reference || 'embedded tsconfig.json') +\r\n            '\\n' + entry.parsed.content.replace(/\\*\\//g, '*\\\\/') + '*/';\r\n        }\r\n        else {\r\n          if (typeof entry.parsed.reference === 'string') {\r\n            const originalContent = fileSystem.readFile(fileSystem.resolvePath(resolvedProjectDir, entry.parsed.reference));\r\n            if (typeof originalContent === 'string')\r\n              output =\r\n                '/* ' + entry.parsed.reference +\r\n                '\\n' + originalContent.replace(/\\*\\//g, '*\\\\/') + '*/';\r\n          }\r\n        }\r\n\r\n        if (injectExternalEmitsIntoNextScript) {\r\n          if (injectExternalEmitsIntoNextScript) {\r\n            const emits = [output, ...injectExternalEmitsIntoNextScript];\r\n            injectExternalEmitsIntoNextScript = void 0;\r\n            return combineExternalEmits(entry, emits);\r\n          }\r\n        }\r\n\r\n        return { output };\r\n      }\r\n\r\n      function getDirectoryEntryContent(entry: ParsedEntry): { output: string, sourcemap?: { fileName: string, content: string } } {\r\n        const injectGraciousNewLines = needsNewLineInjection(entry);\r\n        let header =\r\n          (injectGraciousNewLines ? '\\n' : '') +\r\n          '/* ' + (entry.parsed.reference || 'directory') + ' */';\r\n        if (injectExternalEmitsIntoNextScript) {\r\n          const emits = [header, ...injectExternalEmitsIntoNextScript];\r\n          injectExternalEmitsIntoNextScript = void 0;\r\n\r\n          return combineExternalEmits(entry, emits);\r\n        }\r\n\r\n        return { output: header + (injectGraciousNewLines ? '\\n' : '') };\r\n      }\r\n\r\n      function addEntrySourcemap(entry: ParsedEntry, sourcemap = entry.emitted?.sourcemap) {\r\n        if (sourcemap) {\r\n          (resources || (resources = [])).push({\r\n            name: sourcemap.fileName,\r\n            content: sourcemap.content\r\n          });\r\n        }\r\n      }\r\n\r\n      function combineExternalEmits(\r\n        entry: ParsedEntry,\r\n        externalEmits: (string | { output?: string, sourcemap?: { fileName: string, content: string } } | undefined)[]) {\r\n\r\n        const result = danfo.parsing.sourcemap.concatenate(\r\n          { fileName: getBaseName(entry.syntheticResolvedFileName || entry.parsed.reference!) },\r\n          externalEmits\r\n        );\r\n\r\n        return typeof result === 'string' ? { output: result } : result;\r\n      }\r\n    }\r\n\r\n  }\r\n\r\n  export namespace htmlBuilder {\r\n\r\n    const regex_compileScriptType = /javascript|typescript|json|tsconfig|directory/i;\r\n\r\n    export function isCompileScriptType(type: string): type is 'javascript' | 'typescript' | 'json' | 'tsconfig' {\r\n      return regex_compileScriptType.test(type);\r\n    }\r\n\r\n  }\r\n\r\n}","declare namespace danfo.build {\r\n\r\n  type SourceFileOrSpan = {\r\n    resolvedPath: string;\r\n    originalSourcePath?: string;\r\n    type?: 'typescript' | 'javascript' | 'json' | 'tsconfig' | 'css' | 'html' | 'package';\r\n    asExternal?: boolean;\r\n    stat?: FileSystem.Stat;\r\n\r\n    span?: {\r\n      start: number;\r\n      length: number;\r\n      content: string;\r\n    };\r\n  }\r\n\r\n}","namespace danfo.build {\r\n\r\n  const regex_basename = /^.*[\\/\\\\]([^\\/\\\\]+)$/;\r\n  const regex_basenameCleanup = /[\\/\\\\]+/g;\r\n  // const regex_slash = /\\//g;\r\n  // const regex_backslash = /\\\\/g;\r\n\r\n  export function getBaseName(path: string) {\r\n    if (!path)\r\n      return path;\r\n    return path.replace(regex_basename, '$1').replace(regex_basenameCleanup, '');\r\n  }\r\n\r\n  // export function getRelativePath(resolvedBaseDir: string, resolvedFileName: string) {\r\n  //   const baseDelimiter = detectDelimiter(resolvedBaseDir);\r\n  //   const fileDelimiter = detectDelimiter(resolvedFileName);\r\n\r\n  //   if (resolvedBaseDir === resolvedFileName)\r\n  //     return '.';\r\n\r\n  //   // if it's strictly nested\r\n  //   if (resolvedFileName.indexOf(resolvedBaseDir) === 0 // path starts with base dir\r\n  //     // but also need to make guard against situation like /basedir and /basedirlong/file,\r\n  //     // where it's just textual match but not directory match\r\n  //     && (resolvedBaseDir.charCodeAt(resolvedBaseDir.length - 1) === baseDelimiter\r\n  //       || resolvedFileName.charCodeAt(resolvedBaseDir.length) === fileDelimiter)) {\r\n  //     let result = resolvedFileName.slice(\r\n  //       resolvedBaseDir.length +\r\n  //       (resolvedFileName.charCodeAt(resolvedBaseDir.length) === fileDelimiter ? 1 : 0));\r\n  //     if (fileDelimiter !== baseDelimiter)\r\n  //       result = fileDelimiter === CharCodes.Slash ? result.replace(regex_slash, '\\\\') : result.replace(regex_backslash, '/');\r\n  //   }\r\n\r\n  //   const resolvedFileNameParts = resolvedFileName.split(fileDelimiter === CharCodes.Slash ? '/' : '\\\\');\r\n  //   const resolvedProjectDirParts = resolvedBaseDir.split(baseDelimiter === CharCodes.Slash ? '/' : '\\\\');\r\n\r\n  //   const result: string[] = [];\r\n  //   for (let i = 0; i < Math.max(resolvedFileNameParts.length, resolvedProjectDirParts.length); i++) {\r\n  //     if (!result.length && resolvedFileNameParts[i] === resolvedProjectDirParts[i])\r\n  //       continue;\r\n\r\n  //     if (i < resolvedProjectDirParts.length)\r\n  //       result.unshift('..');\r\n\r\n  //     if (i < resolvedFileNameParts.length)\r\n  //       result.push(resolvedFileNameParts[i]);\r\n  //   }\r\n\r\n  //   if (result.length)\r\n  //     return result.join(baseDelimiter === CharCodes.Slash ? '/' : '\\\\');\r\n  //   else\r\n  //     return '.';\r\n  // }\r\n\r\n  // function detectDelimiter(resolvedPath: string) {\r\n  //   // Windows absolute paths start with a letter C:\\file.txt or a back-slash \\\\desktop\\share\\file.txt\r\n  //   // however C:/file.txt is also allowed\r\n  //   // Linux absolute paths start with a forward-slash: /usr/bin/file.txt\r\n\r\n  //   if (resolvedPath.charCodeAt(0) === CharCodes.Slash) return CharCodes.Slash;\r\n  //   if (resolvedPath.length >= 3 &&\r\n  //     resolvedPath.charCodeAt(1) === CharCodes.Colon &&\r\n  //     resolvedPath.charCodeAt(2) === CharCodes.Slash) return CharCodes.Slash;\r\n  //   else return CharCodes.Backslash;\r\n  // }\r\n\r\n}","namespace danfo.build {\r\n\r\n  export declare namespace populateSourceStructure {\r\n    type Options = {\r\n      fileSystem: FileSystem;\r\n      sources: string[];\r\n      projectPath?: string;\r\n      exclude?: (resolvedPath: string, relativePath: string, stat: FileSystem.Stat | undefined) => boolean;\r\n    }\r\n\r\n    type Result = {\r\n      /** in certain error cases may remain undefined */\r\n      projectDir: string | undefined;\r\n      sources: SourceFileOrSpan[];\r\n      missing?: SourceFileOrSpan[];\r\n    }\r\n  }\r\n\r\n  type TopLevelEntry = {\r\n    originalSourcePath: string;\r\n    resolvedPath: string;\r\n    type: 'dir' | 'file' | 'missing' | 'unresolved-proj-relative';\r\n    directoryPath?: string;\r\n    stat?: FileSystem.Stat\r\n  }\r\n\r\n  type addTopLevelEntry = (topLevelEntry: TopLevelEntry) => void;\r\n\r\n  export function populateSourceStructure(options: populateSourceStructure.Options): populateSourceStructure.Result {\r\n    const topLevelEntryList: TopLevelEntry[] = [];\r\n    const topLevelEntriesByResolvedPath: { [resolvedPath: string]: TopLevelEntry } = {};\r\n\r\n    let { projectDir, projectTopLevelEntry } = verifyProjectPath(options.fileSystem, options.projectPath);\r\n    if (projectTopLevelEntry) topLevelEntryList.push(projectTopLevelEntry);\r\n\r\n    populateTopLevelEntries(options.fileSystem, projectDir, options.sources, addTopLevelEntry);\r\n\r\n    let rootDirs: string[] = [];\r\n    for (const entry of topLevelEntryList) {\r\n      if (entry.directoryPath) {\r\n        rootDirs.push(entry.directoryPath);\r\n      }\r\n    }\r\n    \r\n    if (!projectDir) {\r\n      projectDir = resolveProjectDirFromRootDirs(rootDirs);\r\n\r\n      if (projectDir)\r\n        lateResolveProjRelatives(options.fileSystem, projectDir, topLevelEntryList);\r\n    }\r\n\r\n    let missing: SourceFileOrSpan[] | undefined;\r\n    let sourceList: (SourceFileOrSpan | { type: 'root-dir', sourceFileEntries: SourceFileOrSpan[] })[] = [];\r\n    let topLevelHTML = false;\r\n    let topLevelTsconfig = false;\r\n    let topLevelPackage = false;\r\n\r\n    for (const topLevelEntry of topLevelEntryList) {\r\n      if (topLevelEntry.type === 'missing' || topLevelEntry.type === 'unresolved-proj-relative') {\r\n        const missingEntry = {\r\n          resolvedPath: topLevelEntry.resolvedPath,\r\n          originalSourcePath: topLevelEntry.originalSourcePath\r\n        };\r\n        if (!missing) missing = [missingEntry];\r\n        else missing.push(missingEntry);\r\n      }\r\n      else if (topLevelEntry.type === 'file') {\r\n        const type = populateSourceStructure.inferSourceFileTypeFromExtension(topLevelEntry.originalSourcePath);\r\n        sourceList.push({\r\n          resolvedPath: topLevelEntry.resolvedPath,\r\n          originalSourcePath: topLevelEntry.originalSourcePath,\r\n          type,\r\n          stat: topLevelEntry.stat\r\n        });\r\n        if (type === 'html') topLevelHTML = true;\r\n        else if (type === 'tsconfig') topLevelTsconfig = true;\r\n        else if (type === 'package') topLevelPackage = true;\r\n      }\r\n      else if (topLevelEntry.type === 'dir') {\r\n        const sourceFileEntries: SourceFileOrSpan[] = [];\r\n        populateDir(\r\n          topLevelEntry.resolvedPath,\r\n          rootDirs.length === 1 ? DirType.OnlyRoot : DirType.Root,\r\n          projectDir || topLevelEntry.resolvedPath /* baseDirPath */,\r\n          sourceFileEntries);\r\n\r\n        sourceList.push({\r\n          type: 'root-dir',\r\n          sourceFileEntries\r\n        });\r\n      }\r\n    }\r\n\r\n    const result: populateSourceStructure.Result = {\r\n      projectDir,\r\n      sources: [],\r\n      missing\r\n    };\r\n\r\n    for (const sourceEntry of sourceList) {\r\n      if (sourceEntry.type === 'root-dir') {\r\n        for (const sourceFileEntry of sourceEntry.sourceFileEntries) {\r\n          if (sourceFileEntry.type === 'html') {\r\n            if (topLevelHTML) continue;\r\n            topLevelHTML = true;\r\n          }\r\n          else if (sourceFileEntry.type === 'tsconfig') {\r\n            if (topLevelTsconfig) continue;\r\n            topLevelTsconfig = true;\r\n          }\r\n          else if (sourceFileEntry.type === 'package') {\r\n            if (topLevelPackage) continue;\r\n            topLevelPackage = true;\r\n          }\r\n\r\n          result.sources.push(sourceFileEntry);\r\n        }\r\n      }\r\n      else {\r\n        result.sources.push(sourceEntry);\r\n      }\r\n    }\r\n\r\n    return result;\r\n\r\n    function addTopLevelEntry(topLevelEntry: TopLevelEntry) {\r\n      let existingTopLevelEntry = topLevelEntriesByResolvedPath[topLevelEntry.resolvedPath];\r\n      if (existingTopLevelEntry) {\r\n        if (!existingTopLevelEntry.originalSourcePath && topLevelEntry.originalSourcePath) existingTopLevelEntry.originalSourcePath = topLevelEntry.originalSourcePath;\r\n        if (!existingTopLevelEntry.directoryPath && topLevelEntry.directoryPath) existingTopLevelEntry.directoryPath = topLevelEntry.directoryPath;\r\n      }\r\n      else {\r\n        topLevelEntriesByResolvedPath[topLevelEntry.resolvedPath] = topLevelEntry;\r\n        topLevelEntryList.push(topLevelEntry);\r\n      }\r\n    }\r\n\r\n    const enum DirType {\r\n      Any,\r\n      Root,\r\n      OnlyRoot\r\n    }\r\n\r\n    function populateDir(dirPath: string, dirType: DirType, baseDirPath: string, populateSourceList: SourceFileOrSpan[]) {\r\n      const dirFileList = options.fileSystem.readDirectory(dirPath);\r\n      if (!dirFileList) return;\r\n      dirFileList.sort();\r\n\r\n      let subdirectoryList: { resolvedPath: string, stat: FileSystem.Stat }[] | undefined;\r\n      const fileSourceList: SourceFileOrSpan[] = [];\r\n      let indexHTMLs: SourceFileOrSpan[] | undefined;\r\n      let otherCandidateHTMLs: SourceFileOrSpan[] | undefined;\r\n      let tsconfigs: SourceFileOrSpan[] | undefined;\r\n      let packages: SourceFileOrSpan[] | undefined;\r\n\r\n      for (const file of dirFileList) {\r\n        const resolvedPath = options.fileSystem.resolvePath(dirPath, file);\r\n        const baseName = getBaseName(resolvedPath);\r\n\r\n        // don't even touch those .git entries, no point creating watch entries on them\r\n        if (regex_excludeDirectory.test(baseName)) continue;\r\n\r\n        const stat = options.fileSystem.stat(resolvedPath);\r\n        if (!stat) continue;\r\n        if (stat.isDirectory) {\r\n          if (!subdirectoryList) subdirectoryList = [{ resolvedPath, stat }];\r\n          else subdirectoryList.push({ resolvedPath, stat });\r\n          continue;\r\n        }\r\n\r\n        const type = populateSourceStructure.inferSourceFileTypeFromExtension(resolvedPath);\r\n        if (dirType === DirType.Root || dirType === DirType.OnlyRoot) {\r\n          if (type === 'html' || type === 'tsconfig' || type === 'package') {\r\n            // look out for project-level 'root' index.html and tsconfig.json\r\n            let source: SourceFileOrSpan = {\r\n              resolvedPath,\r\n              type,\r\n              stat\r\n            };\r\n            fileSourceList.push(source);\r\n\r\n            if (type === 'html') {\r\n              const baseName = getBaseName(resolvedPath);\r\n              if (regex_fileName_indexHTML.test(baseName)) {\r\n                if (!indexHTMLs) indexHTMLs = [source];\r\n                else indexHTMLs.push(source);\r\n              }\r\n              else if (regex_fileName_candidateHTML.test(baseName)) {\r\n                if (!otherCandidateHTMLs) otherCandidateHTMLs = [source];\r\n                else otherCandidateHTMLs.push(source);\r\n              }\r\n            }\r\n            else if (type === 'tsconfig') {\r\n              if (!tsconfigs) tsconfigs = [source];\r\n              else tsconfigs.push(source);\r\n            }\r\n            else if (type === 'package') {\r\n              if (!packages) packages = [source];\r\n              else packages.push(source);\r\n            }\r\n            continue;\r\n          }\r\n        }\r\n\r\n        if (type === 'javascript' || type === 'typescript') {\r\n          fileSourceList.push({\r\n            resolvedPath,\r\n            type,\r\n            stat\r\n          });\r\n        }\r\n      }\r\n\r\n      if (dirType === DirType.OnlyRoot) {\r\n        let codeFileCount = 0;\r\n        for (const f of fileSourceList) {\r\n          if (f.type === 'typescript' || f.type === 'javascript') {\r\n            codeFileCount++;\r\n          }\r\n          else if (f.type === 'html') {\r\n            const htmlCandidateBaseName = getBaseName(f.resolvedPath);\r\n            if (regex_fileName_indexHTML.test(htmlCandidateBaseName) || regex_fileName_candidateHTML.test(htmlCandidateBaseName))\r\n              codeFileCount++;\r\n          }\r\n        }\r\n        if (!codeFileCount && subdirectoryList?.length) {\r\n          // if the root dir has no source files, and has 'src' or 'sources' directory,\r\n          // only search that directory and ignore other sibling subdirectories\r\n          //\r\n          // [myproj]\r\n          //    [data] ... ignore ...\r\n          //    [src]  ... YES, COMPILE THIS\r\n          //    [test] ... ignore ...\r\n          //\r\n          const sourcesDirs: string[] = [];\r\n          for (const subdir of subdirectoryList) {\r\n            if (regex_dirName_src.test(getBaseName(subdir.resolvedPath))) sourcesDirs.push(subdir.resolvedPath);\r\n          }\r\n\r\n          if (sourcesDirs.length === 1) {\r\n            populateDir(sourcesDirs[0], DirType.Root, baseDirPath, populateSourceList);\r\n            return;\r\n          }\r\n        }\r\n      }\r\n\r\n      if (subdirectoryList) {\r\n        for (const subdir of subdirectoryList) {\r\n          const { exclude } = options;\r\n          if (typeof exclude === 'function') {\r\n            const relativeDirectoryPath = options.fileSystem.getRelativePath(baseDirPath, subdir.resolvedPath);\r\n            if (exclude(subdir.resolvedPath, relativeDirectoryPath, subdir.stat)) continue;\r\n          }\r\n\r\n          populateDir(subdir.resolvedPath, DirType.Any, baseDirPath, populateSourceList);\r\n        }\r\n      }\r\n\r\n      for (const file of fileSourceList) {\r\n        if (file.type === 'html') {\r\n          const includeAsHTML =\r\n            (indexHTMLs?.length === 1 && indexHTMLs[0] === file)\r\n            || (!indexHTMLs && otherCandidateHTMLs?.length === 1 && otherCandidateHTMLs[0] === file);\r\n          \r\n          if (!includeAsHTML) continue;\r\n        }\r\n        else if (file.type === 'tsconfig') {\r\n          const includeAsTsconfig = tsconfigs?.length === 1;\r\n          if (!includeAsTsconfig) continue;\r\n        }\r\n        else if (file.type === 'package') {\r\n          const includeAsPackage = packages?.length === 1;\r\n          if (!includeAsPackage) continue;\r\n        }\r\n\r\n        const { exclude } = options;\r\n        if (typeof exclude === 'function') {\r\n          const relativePath = projectDir ? options.fileSystem.getRelativePath(projectDir, file.resolvedPath) : file.resolvedPath;\r\n          if (exclude(file.resolvedPath, relativePath, file.stat)) continue;\r\n        }\r\n\r\n        populateSourceList.push(file);\r\n      }\r\n    }\r\n  }\r\n\r\n  function lateResolveProjRelatives(fileSystem: FileSystem, projectDir: string, topLevelEntries: TopLevelEntry[]) {\r\n    for (const entry of topLevelEntries) {\r\n      if (entry.type === 'unresolved-proj-relative') {\r\n        entry.resolvedPath = fileSystem.resolvePath(projectDir, entry.resolvedPath);\r\n        entry.stat = fileSystem.stat(entry.resolvedPath);\r\n        if (!entry.stat) {\r\n          entry.type = 'missing';\r\n        }\r\n        else {\r\n          if (entry.stat.isDirectory) {\r\n            entry.type = 'dir';\r\n            entry.directoryPath = entry.resolvedPath;\r\n          }\r\n          else {\r\n            entry.type = 'file';\r\n            entry.directoryPath = fileSystem.resolvePath(entry.resolvedPath, '..');\r\n          }\r\n        }\r\n      }\r\n    }\r\n  }\r\n\r\n  function verifyProjectPath(fileSystem: FileSystem, projectPath: string | undefined) {\r\n    let projectDir = projectPath;\r\n    let projectTopLevelEntry: TopLevelEntry | undefined;\r\n    if (projectDir) {\r\n      const originalSourcePath = projectDir;\r\n      const resolvedPath = fileSystem.resolvePath(projectDir);\r\n      const stat = fileSystem.stat(projectDir);\r\n      if (!stat) {\r\n        projectDir = void 0;\r\n        projectTopLevelEntry = {\r\n          originalSourcePath,\r\n          resolvedPath,\r\n          type: 'missing'\r\n        };\r\n      }\r\n      else {\r\n        if (stat.isDirectory) {\r\n          projectTopLevelEntry = {\r\n            originalSourcePath,\r\n            resolvedPath,\r\n            type: 'dir',\r\n            directoryPath: resolvedPath,\r\n            stat\r\n          };\r\n        }\r\n        else {\r\n          projectDir = fileSystem.resolvePath(projectDir, '..');\r\n          projectTopLevelEntry = {\r\n            originalSourcePath,\r\n            resolvedPath,\r\n            type: 'file',\r\n            directoryPath: projectDir,\r\n            stat\r\n          };\r\n        }\r\n      }\r\n    }\r\n\r\n    return { projectDir, projectTopLevelEntry };\r\n  }\r\n\r\n  function populateTopLevelEntries(fileSystem: FileSystem, projectDir: string | undefined, sources: string[], addTopLevelEntry: addTopLevelEntry) {\r\n    for (const originalSourcePath of sources) {\r\n      let resolvedPath: string;\r\n      const stripLeadingAtSlash = originalSourcePath.replace(regex_stripLeadingAtSlash, '');\r\n      if (stripLeadingAtSlash !== originalSourcePath) {\r\n        if (!projectDir) {\r\n          addTopLevelEntry({\r\n            originalSourcePath,\r\n            resolvedPath: stripLeadingAtSlash,\r\n            type: 'unresolved-proj-relative'\r\n          });\r\n          continue;\r\n        }\r\n\r\n        resolvedPath = fileSystem.resolvePath(projectDir, stripLeadingAtSlash);\r\n      }\r\n      else {\r\n        resolvedPath = fileSystem.resolvePath(originalSourcePath);\r\n      }\r\n\r\n      const stat = fileSystem.stat(resolvedPath);\r\n\r\n      if (!stat) {\r\n        addTopLevelEntry({\r\n          originalSourcePath,\r\n          resolvedPath,\r\n          type: 'missing'\r\n        });\r\n        continue;\r\n      }\r\n\r\n      if (stat.isDirectory) {\r\n        addTopLevelEntry({\r\n          originalSourcePath,\r\n          resolvedPath,\r\n          type: 'dir',\r\n          directoryPath: resolvedPath,\r\n          stat\r\n        });\r\n      }\r\n      else {\r\n        const directoryPath = fileSystem.resolvePath(resolvedPath, '..');\r\n        addTopLevelEntry({\r\n          originalSourcePath,\r\n          resolvedPath,\r\n          type: 'file',\r\n          directoryPath,\r\n          stat\r\n        });\r\n      }\r\n    }\r\n  }\r\n\r\n\r\n  export namespace populateSourceStructure {\r\n\r\n    export function inferSourceFileTypeFromExtension(path: string) {\r\n      const extMatch = regex_ext.exec(path);\r\n      let ext = extMatch && extMatch[1] || '';\r\n      const type = inferSourceFileTypeFromExtensionLowercase(ext) || inferSourceFileTypeFromExtensionLowercase(ext.toLowerCase());\r\n      if (type === 'json') {\r\n        const baseName = getBaseName(path);\r\n        if (regex_fileName_tsconfigJSON.test(baseName))\r\n          return 'tsconfig';\r\n        else if (regex_fileName_packageJSON.test(baseName))\r\n          return 'package';\r\n      }\r\n      return type;\r\n    }\r\n\r\n    function inferSourceFileTypeFromExtensionLowercase(ext: string) {\r\n      switch (ext) {\r\n        case 'js':\r\n        case 'jsx':\r\n          return 'javascript';\r\n\r\n        case 'ts':\r\n        case 'tsx':\r\n          return 'typescript';\r\n        \r\n        case 'css':\r\n          return 'css';\r\n        \r\n        case 'html':\r\n        case 'htm':\r\n          return 'html';\r\n        \r\n        case 'json':\r\n          return 'json';\r\n      }\r\n    }\r\n  }\r\n\r\n  function resolveProjectDirFromRootDirs(rootDirs: string[]): string | undefined {\r\n    if (!rootDirs.length) return;\r\n    return rootDirs[0];\r\n  }\r\n\r\n  const regex_ext = /\\.([^\\.\\\\\\/]+)$/;\r\n  const regex_fileName_indexHTML = /^index\\.htm(l?)$/i;\r\n  const regex_fileName_candidateHTML = /^default.htm(l?)$/i;\r\n  const regex_fileName_tsconfigJSON = /^tsconfig\\.json$/i;\r\n  const regex_fileName_packageJSON = /^package\\.json$/i;\r\n\r\n  const regex_excludeDirectory = /(^|\\\\|\\/|\\:)(node_modules|\\.git|\\.DS_Store)$/i;\r\n  const regex_dirName_src = /^(src|source|sources)$/i;\r\n\r\n  const regex_stripLeadingAtSlash = /^\\@[\\\\\\/]+/;\r\n\r\n}","namespace danfo.build {\r\n\r\n\r\n  export declare namespace projectBuilder {\r\n    type Options = {\r\n      projRoot?: string;\r\n      trackingFileSystem: danfo.node.FileSystemTrackingChanges;\r\n      outputPath?: string;\r\n      watch?: boolean;\r\n      sources: string[];\r\n\r\n      onBuildStart?: (args: OnBuildStartArgs) => void;\r\n      onBuildFinish?: (args: OnBuildFinishArgs) => void;\r\n\r\n    } & danfo.build.code.codeBuilder.CacheOptions;\r\n\r\n    type OnBuildStartArgs = populateSourceStructure.Result & {\r\n      outputDirPath: string;\r\n      changes?: string[];\r\n      html: boolean;\r\n    };\r\n\r\n    type OnBuildFinishArgs = populateSourceStructure.Result & {\r\n      outputDirPath: string;\r\n      success: boolean;\r\n      buildTime: number;\r\n      html: boolean;\r\n      emits: BuildEmit[];\r\n      unresolvedImports?: danfo.build.html.UnresolvedImports[];\r\n      errors: build.code.BuildError[];\r\n    }; \r\n\r\n    type BuildEmit = {\r\n      localPath: string;\r\n      fullPath: string;\r\n      content: string | { [byteIndex: number]: number, length: number };\r\n      changedFrom?: {\r\n        timestamp?: number;\r\n        content?: string | { [byteIndex: number]: number, length: number };\r\n      }\r\n    }\r\n\r\n    type Builder = {\r\n      stop(): void;\r\n    }\r\n  }\r\n\r\n\r\n  export function projectBuilder(options: projectBuilder.Options) {\r\n\r\n    let htmlBuilderInstance: danfo.build.html.Builder | undefined;\r\n    let bundlerInstance: danfo.build.bundle.Bundler | undefined;\r\n\r\n    let firstBuild = true;\r\n\r\n    if (options.watch !== false) options.trackingFileSystem.onChanges = handleChanges;\r\n\r\n    let resolvedOutputDirPath = getOutputDirPath(options.outputPath);\r\n    let preciseEmitPaths: string[] | undefined;\r\n    \r\n    const excludeOutputCheck = (dirPath: string) => {\r\n      return (\r\n        preciseEmitPaths ?\r\n          preciseEmitPaths.indexOf(dirPath) >= 0 :\r\n          dirPath.indexOf(resolvedOutputDirPath) === 0\r\n      );\r\n    };\r\n\r\n\r\n    buildOrRebuild();\r\n    firstBuild = false;\r\n\r\n    function getOutputDirPath(outputPath?: string) {\r\n      let probePath = options.trackingFileSystem.fs.resolvePath(outputPath || 'dist');\r\n      const stat = options.trackingFileSystem.fs.stat(probePath);\r\n      if (!stat || stat.isDirectory) return probePath;\r\n      else return options.trackingFileSystem.fs.resolvePath(probePath, '..');\r\n    }\r\n\r\n    function handleChanges(allChanges: string[]) {\r\n      if (allChanges) {\r\n        let anyRealChanges: string[] | undefined;\r\n        for (const ch of allChanges) {\r\n          if (!excludeOutputCheck(ch)) {\r\n            if (!anyRealChanges) anyRealChanges = [ch];\r\n            else anyRealChanges.push(ch);\r\n          }\r\n        }\r\n        if (!anyRealChanges) return;\r\n        else allChanges = anyRealChanges\r\n      }\r\n\r\n      buildOrRebuild({ allChanges });\r\n    }\r\n\r\n    function buildOrRebuild(reason?: { allChanges: string[] }) {\r\n      const sourceStructure = populateSourceStructure({\r\n        fileSystem: options.trackingFileSystem.fs,\r\n        projectPath: options.projRoot,\r\n        sources: options.sources,\r\n        exclude: excludeOutputCheck\r\n      });\r\n\r\n      if (!options.outputPath)\r\n        resolvedOutputDirPath = getOutputDirPath(\r\n          sourceStructure.projectDir ? options.trackingFileSystem.fs.resolvePath(sourceStructure.projectDir, 'dist') : void 0);\r\n\r\n      let html: SourceFileOrSpan | undefined;\r\n      for (const srcEntry of sourceStructure.sources) {\r\n        if (srcEntry.type === 'html') {\r\n          html = srcEntry;\r\n          break;\r\n        }\r\n      }\r\n\r\n      if (typeof options.onBuildStart === 'function')\r\n        options.onBuildStart({\r\n          ...sourceStructure,\r\n          outputDirPath: resolvedOutputDirPath,\r\n          changes: reason && reason.allChanges,\r\n          html: !!html\r\n        });\r\n      \r\n      if (html) {\r\n        buildForHtml(sourceStructure, html);\r\n      }\r\n      else {\r\n        if (firstBuild && typeof options.watch !== 'boolean') {\r\n          // no need for watching, if neither asked nor can infer from the presence of HTML\r\n          options.trackingFileSystem.stopWatching();\r\n        }\r\n\r\n        buildForJS(sourceStructure);\r\n      }\r\n    }\r\n\r\n    function buildForJS(sourceStructure: populateSourceStructure.Result) {\r\n      if (!bundlerInstance) bundlerInstance = danfo.build.bundle.codeBundler({\r\n        fileSystem: options.trackingFileSystem.fs\r\n      });\r\n\r\n      const buildStart = Date.now();\r\n\r\n      const bundleBuildResult = bundlerInstance.build({\r\n        outputDir: resolvedOutputDirPath,\r\n        resolvedProjectDir: sourceStructure.projectDir || options.projRoot!,\r\n        sources: sourceStructure.sources as SourceFileOrSpan[]\r\n      });\r\n      if (bundleBuildResult.outputFile)\r\n        resolvedOutputDirPath = options.trackingFileSystem.fs.resolvePath(resolvedOutputDirPath, bundleBuildResult.outputFile + '/..');\r\n\r\n      const emits: projectBuilder.BuildEmit[] = [];\r\n      if (bundleBuildResult.outputFile) {\r\n        if (bundleBuildResult.output)\r\n          emits.push(createEmit(bundleBuildResult.outputFile, bundleBuildResult.output));\r\n        if (bundleBuildResult.sourcemap)\r\n          emits.push(createEmit(bundleBuildResult.sourcemap.fileName, bundleBuildResult.sourcemap.content));\r\n        if (bundleBuildResult.typings)\r\n          emits.push(createEmit(bundleBuildResult.typings.fileName, bundleBuildResult.typings.content));\r\n      }\r\n\r\n      const errors = concatWithMissingFileErrors(bundleBuildResult.errors, sourceStructure);\r\n\r\n      const buildTime = Date.now() - buildStart;\r\n\r\n      const buildResult: projectBuilder.OnBuildFinishArgs = {\r\n        ...sourceStructure,\r\n        success: !!bundleBuildResult.outputFile,\r\n        outputDirPath: resolvedOutputDirPath,\r\n        buildTime,\r\n        html: false,\r\n        emits,\r\n        unresolvedImports: bundleBuildResult.imports,\r\n        errors\r\n      };\r\n\r\n      preciseEmitPaths = emits.map(em => em.fullPath);\r\n\r\n      if (typeof options.onBuildFinish === 'function')\r\n        options.onBuildFinish(buildResult);\r\n    }\r\n\r\n    function buildForHtml(sourceStructure: populateSourceStructure.Result, htmlEntry: SourceFileOrSpan) {\r\n      if (!htmlBuilderInstance)\r\n        htmlBuilderInstance = danfo.build.html.htmlBuilder({\r\n          fileSystem: options.trackingFileSystem.fs,\r\n          precachedFixedSource: options.precachedFixedSource\r\n        });\r\n\r\n      const buildStart = Date.now();\r\n\r\n      const htmlBuildResults = htmlBuilderInstance.build({\r\n        resolvedProjectDir: sourceStructure.projectDir!,\r\n        htmlFile: htmlEntry,\r\n        otherFiles: sourceStructure.sources,\r\n        outputDirPath: resolvedOutputDirPath\r\n      });\r\n\r\n      let outputHtmlPath: string;\r\n      if (options.outputPath) {\r\n        const probePath = options.trackingFileSystem.fs.resolvePath(options.outputPath);\r\n        const stat = options.trackingFileSystem.fs.stat(probePath);\r\n        if (!stat || stat.isDirectory) {\r\n          outputHtmlPath = options.trackingFileSystem.fs.resolvePath(options.outputPath, getBaseName(htmlEntry.resolvedPath));\r\n        }\r\n        else {\r\n          outputHtmlPath = probePath;\r\n        }\r\n      }\r\n      else {\r\n        outputHtmlPath = options.trackingFileSystem.fs.resolvePath(resolvedOutputDirPath, getBaseName(htmlEntry.resolvedPath));\r\n      }\r\n\r\n      const emits: projectBuilder.BuildEmit[] = [];\r\n      if (htmlBuildResults.htmlEmit)\r\n        emits.push(createEmit(outputHtmlPath, htmlBuildResults.htmlEmit));\r\n\r\n      if (htmlBuildResults.resources) {\r\n        for (const res of htmlBuildResults.resources) {\r\n          const resPath = options.trackingFileSystem.fs.resolvePath(resolvedOutputDirPath, res.name);\r\n          emits.push(createEmit(resPath, res.content));\r\n        }\r\n      }\r\n\r\n      const errors = concatWithMissingFileErrors(htmlBuildResults.errors, sourceStructure);\r\n\r\n      const buildTime = Date.now() - buildStart;\r\n\r\n      const buildResult: projectBuilder.OnBuildFinishArgs = {\r\n        ...sourceStructure,\r\n        success: typeof htmlBuildResults.htmlEmit === 'string',\r\n        outputDirPath: resolvedOutputDirPath,\r\n        buildTime,\r\n        html: true,\r\n        emits,\r\n        unresolvedImports: htmlBuildResults.unresolvedImports,\r\n        errors\r\n      };\r\n\r\n      preciseEmitPaths = emits.map(em => em.fullPath);\r\n\r\n      if (typeof options.onBuildFinish === 'function')\r\n        options.onBuildFinish(buildResult);\r\n    }\r\n\r\n    function createEmit(fullPath: string, content: string) {\r\n      let localPath = options.trackingFileSystem.fs.getRelativePath(resolvedOutputDirPath, fullPath).replace(/\\\\/g, '/');\r\n      if (/^\\//.test(localPath)) localPath = localPath.slice(1);\r\n      const currentStat = options.trackingFileSystem.fs.stat(fullPath);\r\n\r\n      if (!currentStat || currentStat.isDirectory) {\r\n        return {\r\n          localPath,\r\n          fullPath,\r\n          content,\r\n          changedFrom: {}\r\n        };\r\n      }\r\n\r\n      const currentContent = options.trackingFileSystem.fs.readFile(fullPath);\r\n\r\n      return content === currentContent ?\r\n        {\r\n          localPath,\r\n          fullPath,\r\n          content\r\n        }\r\n        : {\r\n          localPath,\r\n          fullPath,\r\n          content,\r\n          changedFrom: {\r\n            timestamp: currentStat.timestamp,\r\n            content: currentContent\r\n          }\r\n        };\r\n    }\r\n  }\r\n\r\n\r\n  function concatWithMissingFileErrors(errors: code.BuildError[], sourceStructure: populateSourceStructure.Result) {\r\n    if (sourceStructure.missing?.length) {\r\n      errors = [...errors];\r\n      for (const miss of sourceStructure.missing) {\r\n        errors.push({\r\n          code: 'MISS',\r\n          message: 'Cannot find file ' + (miss.originalSourcePath || miss.resolvedPath),\r\n          resolvedSourcePath: miss.originalSourcePath || miss.resolvedPath\r\n        });\r\n      }\r\n    }\r\n\r\n    return errors;\r\n  }\r\n}","namespace danfo.node {\n  export function performScaffold() {\n  }\n}","namespace danfo.node.server {\r\n\r\n  export declare namespace run {\r\n\r\n    type Options = {\r\n      fileSystem: danfo.node.FileSystemWithBinary;\r\n      projectDir: string;\r\n      distDir: string;\r\n      host?: string;\r\n      port?: number;\r\n    }\r\n\r\n  }\r\n\r\n  export type Server = {\r\n    distDir: string;\r\n    close(): void;\r\n  }\r\n\r\n  export namespace extensionContentTypes {\r\n    export const html = 'text/html';\r\n    export const gif = 'image/gif';\r\n    export const jpg = 'image/jpeg';\r\n    export const js = 'application/javascript';\r\n  }\r\n\r\n  export function run(options: run.Options): Server {\r\n    const http = require('http') as typeof import('http');\r\n    const URL = require('url') as typeof import('url');\r\n    const srv = http.createServer({}, requestListener);\r\n    srv.listen(typeof options.port === 'number' ? options.port : 8080);\r\n\r\n    let resolvedDistDir = options.fileSystem.resolvePath(options.distDir);\r\n    let server = {\r\n      distDir: options.distDir,\r\n      close: closeServer\r\n    };\r\n\r\n    return server;\r\n\r\n    function closeServer() {\r\n      srv.close();\r\n    }\r\n\r\n    async function requestListener(req: import('http').IncomingMessage, res: import('http').ServerResponse): Promise<void> {\r\n      try {\r\n        resolvedDistDir = options.fileSystem.resolvePath(server.distDir);\r\n\r\n        const parsedUrl = URL.parse('http://' + req.headers.host + req.url!);\r\n        const path = (parsedUrl.path || '/').replace(/^\\//, '');\r\n        let resolvedPath = options.fileSystem.resolvePath(resolvedDistDir, path);\r\n\r\n        if (resolvedPath.indexOf(resolvedDistDir) !== 0) {\r\n          await reject404(req, res, parsedUrl, resolvedPath, 'Request trying to escape beyond home directory.');\r\n          return;\r\n        }\r\n\r\n        let stat = options.fileSystem.stat(resolvedPath);\r\n        if (!stat) {\r\n          await reject404(req, res, parsedUrl, resolvedPath);\r\n          return;\r\n        }\r\n\r\n        if (stat.isDirectory) {\r\n          const resolvedIndexPath = options.fileSystem.resolvePath(resolvedPath, 'index.html');\r\n          const indexStat = options.fileSystem.stat(resolvedIndexPath);\r\n          if (indexStat && !indexStat.isDirectory) {\r\n            resolvedPath = resolvedIndexPath;\r\n            stat = indexStat;\r\n          }\r\n        }\r\n\r\n        if (stat.isDirectory)\r\n          await renderDirectoryList(req, res, parsedUrl, resolvedPath);\r\n        else\r\n          await renderFile(req, res, parsedUrl, resolvedPath);\r\n      }\r\n      catch (error) {\r\n        await wrapRequestError(error, req, res);\r\n      }\r\n      finally {\r\n        if (typeof req.destroy === 'function' && !req.destroyed)\r\n          req.destroy();\r\n        if (typeof res.destroyed === 'function' && !res.destroyed)\r\n          res.destroy();\r\n      }\r\n    }\r\n\r\n    async function renderFile(req: import('http').IncomingMessage, res: import('http').ServerResponse, parsedUrl: import('url').UrlWithStringQuery, resolvedFilePath: string): Promise<void> {\r\n      const buffer = options.fileSystem.readFile(resolvedFilePath, 'binary');\r\n      if (!buffer) {\r\n        await reject404(req, res, parsedUrl, resolvedFilePath);\r\n        return;\r\n      }\r\n\r\n      res.statusCode = 200;\r\n      res.statusMessage = 'OK';\r\n\r\n      const ext = resolvedFilePath.split('.').reverse().filter(part => part)[0];\r\n      const contentType = (extensionContentTypes as any)[ext];\r\n      if (contentType) {\r\n        res.setHeader('Content-Type', contentType);\r\n      }\r\n\r\n      console.log(\r\n        node.colors.green + 'HTTP 200 ' + req.method + ' ' + resolvedFilePath + node.colors.reset +\r\n        node.colors.brightGreen + ' ' + (contentType || ext) + ' ' + buffer.length + node.colors.reset +\r\n        node.colors.green + ' byte' + (buffer.length === 1 ? '' : 's') + node.colors.reset);\r\n\r\n      await new Promise<void>(resolve =>\r\n        res.end(buffer, resolve));\r\n    }\r\n\r\n    async function renderDirectoryList(req: import('http').IncomingMessage, res: import('http').ServerResponse, parsedUrl: import('url').UrlWithStringQuery, resolvedDirPath: string): Promise<void> {\r\n      const dirList = options.fileSystem.readDirectory(resolvedDirPath);\r\n      if (!dirList) {\r\n        await reject404(req, res, parsedUrl, resolvedDirPath);\r\n        return;\r\n      }\r\n\r\n      console.log(\r\n        node.colors.green + 'HTTP 200 ' + req.method + ' ' + parsedUrl.path + ' -> ' + resolvedDirPath + node.colors.reset +\r\n        node.colors.brightGreen + dirList.length + node.colors.reset +\r\n        node.colors.green + (dirList.length === 1 ? ' entry' : 'entries') + node.colors.reset);\r\n\r\n\r\n      res.statusCode = 200;\r\n      res.statusMessage = 'OK';\r\n\r\n      let dirRenderHTML =\r\n        '<html><head><title>' + resolvedDistDir + ': ' + dirList.length + ' file' + (dirList.length === 1 ? '' : 's') + '</title></head>' +\r\n        '<body>' +\r\n        '<h2>' + resolvedDistDir + ': ' + dirList.length + ' file' + (dirList.length === 1 ? '' : 's') + '</h2>' +\r\n        '<ul>' +\r\n        (resolvedDirPath === resolvedDistDir ?\r\n          '' :\r\n          '<li><a href=\"..\">..</a>') +\r\n        dirList.map(entry => {\r\n          const baseName = danfo.build.getBaseName(entry);\r\n          return '<li><a href=\"' + baseName+ '\">' + baseName + '</a>';\r\n        }).join('\\n') +\r\n        '</ul>' +\r\n        '</body></html>';\r\n\r\n      await endRequestWithHTML(res, dirRenderHTML);\r\n    }\r\n\r\n    async function reject404(req: import('http').IncomingMessage, res: import('http').ServerResponse, parsedUrl: import('url').UrlWithStringQuery, resolvedPath: string, additionalMessage?: string) {\r\n\r\n      res.statusCode = 404;\r\n\r\n      const errorMessage =\r\n        typeof additionalMessage === 'string' ?\r\n          additionalMessage + ' for ' + resolvedPath :\r\n          'File not found: ' + resolvedPath;\r\n\r\n      res.statusMessage = errorMessage;\r\n\r\n      console.log(\r\n        node.colors.green + 'HTTP ' + node.colors.reset + node.colors.red + '404 ' + node.colors.reset + node.colors.green + req.method + ' ' + parsedUrl.path + ' -> ' + resolvedPath + node.colors.reset +\r\n        (additionalMessage ? ' ' + node.colors.brightGreen + additionalMessage + node.colors.reset : ''));\r\n      \r\n      await endRequestWithHTML(\r\n        res,\r\n        '<html><head><title>' + errorMessage + '</title><head><body>' +\r\n        '<h2 style=\"color: firebrick\">' + errorMessage + '</h2>' +\r\n        'at ' + Date() +\r\n        '</body></html>'\r\n      );\r\n    }\r\n\r\n    async function endRequestWithHTML(res: import('http').ServerResponse, html: string | Buffer, contentType: string = 'text/html') {\r\n      try { res.setHeader('Content-Type', contentType); }\r\n      catch (error) { /* ignore content type failure */ }\r\n\r\n      await new Promise<void>(resolve => res.end(html, resolve));\r\n    }\r\n\r\n    async function wrapRequestError(error: any, req: import('http').IncomingMessage, res: import('http').ServerResponse): Promise<void> {\r\n      try {\r\n        if (req.destroyed || res.destroyed)\r\n          return;\r\n\r\n        const errorMessage =\r\n          error && error.message ? String(error.message) :\r\n            error ? String(error) :\r\n              'Internal failure';\r\n        \r\n        res.statusCode = 500;\r\n        res.statusMessage = errorMessage;\r\n\r\n        console.log(\r\n          node.colors.green + 'HTTP ' + node.colors.reset + node.colors.red + '500 ' + node.colors.reset + node.colors.green + req.method + ' ' + req.url + node.colors.reset +\r\n          node.colors.brightGreen + ' ' + errorMessage+ node.colors.reset);\r\n\r\n        \r\n        await endRequestWithHTML(\r\n          res,\r\n          '<html><head><title>' + errorMessage + '</title><head><body>' +\r\n          '<h2 style=\"color: firebrick\">' + errorMessage + '</h2>' +\r\n          'at ' + Date() +\r\n          '</body></html>');\r\n      }\r\n      catch (secondaryError) {\r\n        // oops that is too bad?\r\n      }\r\n      finally {\r\n        if (typeof req.destroy === 'function' && !req.destroyed)\r\n          req.destroy(error);\r\n        if (typeof res.destroyed === 'function' && !res.destroyed)\r\n          res.destroy(error);\r\n      }\r\n    }\r\n  }\r\n\r\n}","namespace danfo.node {\r\n\r\n  export type FileSystemWithBinary = danfo.build.FileSystem & {\r\n    readFile: {\r\n      (file: string): string | undefined;\r\n      (file: string, encoding: 'binary'): Buffer | readonly number[] | undefined;\r\n    }\r\n  }\r\n\r\n  export type FileSystemTrackingChanges = {\r\n    fs: FileSystemWithBinary;\r\n    onChanges?: (allChanges: string[]) => void;\r\n    next(): void;\r\n    stopWatching(): void;\r\n  }\r\n\r\n  export declare namespace createFS {\r\n    type DebugOptions = {\r\n      fs: typeof import('fs');\r\n      path: typeof import('path');\r\n    }\r\n  }\r\n\r\n  function doNothing() { }\r\n\r\n  export function createFS(rootDir: string, options?: Partial<createFS.DebugOptions>) {\r\n\r\n    const changesTimeoutMS = 50;\r\n    const recurringMissingCheckTimeoutMS = 10000;\r\n\r\n    const fs = options && options.fs || require('fs') as typeof import('fs');\r\n    if (options && !options.fs) options.fs = fs;\r\n    const path = options && options.path || require('path') as typeof import('path');\r\n    if (options && !options.path) options.path = path;\r\n    let needsWatching = true;\r\n\r\n    type WatchingEntry = {\r\n      close(): void;\r\n      latestStat?: danfo.build.FileSystem.Stat;\r\n      changed: boolean;\r\n      missing: boolean;\r\n    };\r\n\r\n    let session = createSession();\r\n\r\n    let fsWithChanges: FileSystemTrackingChanges = {\r\n      fs: {\r\n        basePath: path.resolve(rootDir),\r\n        readDirectory,\r\n        readFile,\r\n        getRelativePath,\r\n        resolvePath,\r\n        stat,\r\n        writeFile\r\n      },\r\n      next,\r\n      stopWatching\r\n    };\r\n\r\n\r\n    return fsWithChanges;\r\n\r\n    function stopWatching() {\r\n      if (!needsWatching) return;\r\n      needsWatching = false;\r\n      if (session.watchingMap) {\r\n        for (const k in session.watchingMap) {\r\n          const entry = session.watchingMap[k];\r\n          if (entry && typeof entry.close === 'function')\r\n            entry.close();\r\n        }\r\n        session.watchingMap = {};\r\n      }\r\n      if (session.recurringMissingCheckTimeout) {\r\n        clearTimeout(session.recurringMissingCheckTimeout);\r\n        session.recurringMissingCheckTimeout = void 0;\r\n      }\r\n    }\r\n\r\n    function createSession() {\r\n      return {\r\n        watchingMap: {} as { [resolvedPath: string]: WatchingEntry },\r\n        allChangesList: [] as string[],\r\n        onChangesTimeout: null as any,\r\n        recurringMissingCheckTimeout: null as any\r\n      };\r\n    }\r\n\r\n    function readDirectory(dirPath: string): string[] | undefined {\r\n      const resolvedFullDirPath = resolvePath(dirPath);\r\n      watchPath(resolvedFullDirPath);\r\n      try {\r\n        const dirFiles = fs.readdirSync(resolvedFullDirPath);\r\n        const resolvedResults = [];\r\n        for (const f of dirFiles) {\r\n          const res = path.normalize(path.resolve(resolvedFullDirPath, f));\r\n          resolvedResults.push(res);\r\n        }\r\n        return resolvedResults;\r\n      }\r\n      catch (noAccessOrDoesNotExist) {\r\n      }\r\n    }\r\n\r\n    function readFile(file: string): string | undefined;\r\n    function readFile(file: string, encoding: 'binary'): Buffer | readonly number[] | undefined;\r\n    function readFile(filePath: string, encoding?: 'binary'): string | Buffer | readonly number[] | undefined {\r\n      const resolvedFullPath = resolvePath(filePath);\r\n      watchPath(resolvedFullPath);\r\n      try {\r\n        if (encoding === 'binary')\r\n          return fs.readFileSync(resolvedFullPath);\r\n\r\n        const buf = fs.readFileSync(resolvedFullPath, { encoding });\r\n        return buf.toString(encoding || 'utf8');\r\n      }\r\n      catch (noAccessOrDoesNotExist) { }\r\n    }\r\n\r\n    function writeFile(filePath: string, data: string | Buffer, encoding?: 'binary'): void {\r\n      const resolvedFullPath = resolvePath(filePath);\r\n      fs.writeFileSync(resolvedFullPath, data, encoding);\r\n      unwatchPathOnWrite(filePath, data.length);\r\n    }\r\n\r\n    function getRelativePath(resolvedBaseDir: string, resolvedFileName: string): string {\r\n      return path.relative(resolvedBaseDir, resolvedFileName);\r\n    }\r\n\r\n    function resolvePath(path1: string, path2?: string) {\r\n      // note a forced normalize is required (is it only on some versions?)\r\n      const resolvedPath = path.normalize(\r\n        path2 ? path.resolve(fsWithChanges.fs.basePath, path1, path2) :\r\n          path.resolve(fsWithChanges.fs.basePath, path1)\r\n      );\r\n\r\n      return resolvedPath;\r\n    }\r\n\r\n    function stat(filePath: string): danfo.build.FileSystem.Stat | undefined {\r\n      const resolvedFullPath = resolvePath(filePath);\r\n      const stat = watchPath(resolvedFullPath);\r\n      // console.log('stat(', filePath, ') ', stat);\r\n      return stat;\r\n    }\r\n\r\n    function next() {\r\n      if (!needsWatching)\r\n        return;\r\n        \r\n      if (session.onChangesTimeout) {\r\n        clearTimeout(session.onChangesTimeout);\r\n        session.onChangesTimeout = null;\r\n      }\r\n        \r\n      for (const resolveFullPath in session.watchingMap) {\r\n        const entry = session.watchingMap[resolveFullPath];\r\n        if (entry && typeof entry.close === 'function') {\r\n          try {\r\n            entry.close();\r\n          }\r\n          catch { }\r\n        }\r\n      }\r\n\r\n      session = createSession();\r\n    }\r\n\r\n    function deriveTimestamp(fsStat: import('fs').Stats): number | undefined {\r\n      const timestampM = statTimestamp(fsStat.mtimeMs, fsStat.mtime);\r\n      const timestampC = statTimestamp(fsStat.ctimeMs, fsStat.ctime);\r\n      const timestampBirth = statTimestamp(fsStat.birthtimeMs, fsStat.birthtime);\r\n      return Math.max(timestampM!, timestampC!, timestampBirth!);\r\n    }\r\n\r\n    function statTimestamp(xtimeMs: number | undefined, xtime: Date | undefined): number | null {\r\n      if (typeof xtimeMs === 'number')\r\n        return xtimeMs;\r\n      else if (xtime && typeof xtime.getTime === 'function')\r\n        return xtime.getTime();\r\n      return null;\r\n    }\r\n\r\n    function watchPath(resolvedFullPath: string, refreshStat?: boolean): danfo.build.FileSystem.Stat | undefined {\r\n      if (!needsWatching) {\r\n        try { return statDirect(resolvedFullPath); }\r\n        catch { return; }\r\n      }\r\n        \r\n      const existingWatchingEntry = session.watchingMap[resolvedFullPath];\r\n      if (existingWatchingEntry) {\r\n        if (!refreshStat && existingWatchingEntry.latestStat && !existingWatchingEntry.changed)\r\n          return existingWatchingEntry.latestStat;\r\n\r\n        try {\r\n          const currentStat = statDirect(resolvedFullPath);\r\n          if (currentStat && !existingWatchingEntry.latestStat)\r\n            existingWatchingEntry.latestStat = currentStat;\r\n            \r\n          return currentStat;\r\n        }\r\n        catch {\r\n          watchNoteMissing(resolvedFullPath);\r\n          return;\r\n        }\r\n      }\r\n\r\n      let currentStat: danfo.build.FileSystem.Stat;\r\n      let fsWatcher: import('fs').FSWatcher | undefined;\r\n      let entry: WatchingEntry | undefined;\r\n      try {\r\n        currentStat = statDirect(resolvedFullPath);\r\n        fsWatcher = fs.watch(resolvedFullPath, { recursive: false }, (event, filename) => {\r\n          if (entry) {\r\n            if (!entry.changed) {\r\n              entry.changed = true;\r\n              session.allChangesList.push(resolvedFullPath);\r\n            }\r\n\r\n            queueOnChanges();\r\n          }\r\n        });\r\n      }\r\n      catch (statError) {\r\n        if (fsWatcher)\r\n          fsWatcher.close();\r\n\r\n        watchNoteMissing(resolvedFullPath);\r\n        return;\r\n      }\r\n        \r\n      entry = {\r\n        close: closeWatcher,\r\n        changed: false,\r\n        missing: false,\r\n        latestStat: currentStat\r\n      };\r\n\r\n      session.watchingMap[resolvedFullPath] = entry;\r\n\r\n      return currentStat;\r\n\r\n      function closeWatcher() {\r\n        if (fsWatcher)\r\n          fsWatcher.close();\r\n        entry!.close = doNothing;\r\n      }\r\n    }\r\n\r\n    function unwatchPathOnWrite(resolvedFullPath: string, length: number) {\r\n      if (!needsWatching) return;\r\n      const latestStat = {\r\n        isDirectory: false,\r\n        length,\r\n        timestamp: Date.now()\r\n      };\r\n\r\n      const existingWatchingEntry = session.watchingMap[resolvedFullPath];\r\n      if (existingWatchingEntry) {\r\n        existingWatchingEntry.changed = false;\r\n        existingWatchingEntry.latestStat = latestStat;\r\n        existingWatchingEntry.close();\r\n      }\r\n      else {\r\n        const entry: WatchingEntry = {\r\n          close: doNothing,\r\n          changed: false,\r\n          missing: false,\r\n          latestStat\r\n        };\r\n        session.watchingMap[resolvedFullPath] = entry;\r\n      }\r\n    }\r\n\r\n    function queueOnChanges() {\r\n      if (session.onChangesTimeout)\r\n        clearTimeout(session.onChangesTimeout);\r\n        \r\n      session.onChangesTimeout = setTimeout(invokeOnChanges, changesTimeoutMS);\r\n    }\r\n\r\n    function invokeOnChanges() {\r\n      session.onChangesTimeout = null;\r\n      const arg = session.allChangesList;\r\n      if (typeof fsWithChanges.onChanges === 'function') {\r\n        // reset changes for the next watch result\r\n        session.allChangesList = [];\r\n        for (const key in session.watchingMap) {\r\n          const entry = session.watchingMap[key];\r\n          if (entry && entry.changed) {\r\n            entry.changed = false;\r\n            entry.latestStat = void 0;\r\n          }\r\n        }\r\n\r\n        fsWithChanges.onChanges(arg);        \r\n      }\r\n    }\r\n\r\n    function watchNoteMissing(resolvedFullPath: string): void {\r\n      let entry = session.watchingMap[resolvedFullPath];\r\n      if (entry && entry.missing)\r\n        return;\r\n\r\n      {\r\n        // walk up the directories until not missing anymore\r\n        // (to avoid watching many missing paths within the same missing directory)\r\n        while (true) {\r\n          const parentPath = path.dirname(resolvedFullPath);\r\n          if (!parentPath || parentPath === resolvedFullPath || parentPath === '/') {\r\n            break;\r\n          }\r\n          const parentEntry = session.watchingMap[parentPath];\r\n          if (parentEntry) {\r\n            if (parentEntry.missing) return;\r\n            resolvedFullPath = resolvedFullPath;\r\n            break;\r\n          }\r\n          else {\r\n            if (fs.existsSync(parentPath))\r\n              break;\r\n          }\r\n\r\n          resolvedFullPath = parentPath;\r\n        }\r\n      }\r\n      \r\n\r\n      if (entry && typeof entry.close === 'function') {\r\n        try {\r\n          entry.close();\r\n        }\r\n        catch { }\r\n      }\r\n\r\n      if (entry) {\r\n        entry.missing = true;\r\n      }\r\n      else {\r\n        entry = {\r\n          changed: false,\r\n          missing: true,\r\n          close: doNothing\r\n        };\r\n        session.watchingMap[resolvedFullPath] = entry;\r\n      }\r\n\r\n      entry.missing = true;\r\n      if (session.recurringMissingCheckTimeout)\r\n        clearTimeout(session.recurringMissingCheckTimeout);\r\n        \r\n      session.recurringMissingCheckTimeout = setTimeout(\r\n        retryMissing,\r\n        recurringMissingCheckTimeoutMS\r\n      );\r\n    }\r\n\r\n    function retryMissing() {\r\n      session.recurringMissingCheckTimeout = null;\r\n\r\n      for (const resolvedFullPath in session.watchingMap) {\r\n        const entry = session.watchingMap[resolvedFullPath];\r\n        if (entry && entry.missing) {\r\n          try {\r\n            const renewedStat = statDirect(resolvedFullPath);\r\n            entry.missing = false;\r\n            if (!entry.changed) {\r\n              session.allChangesList.push(resolvedFullPath);\r\n              // TODO: maybe even restart watching?\r\n              queueOnChanges();\r\n            }\r\n          }\r\n          catch (missingAgain) {\r\n            // OK, do nothing...\r\n          }\r\n        }\r\n      }\r\n\r\n      clearTimeout(session.recurringMissingCheckTimeout);\r\n      session.recurringMissingCheckTimeout = setTimeout(\r\n        retryMissing,\r\n        recurringMissingCheckTimeoutMS\r\n      );\r\n    }\r\n\r\n    function statDirect(resolvedFullPath: string) {\r\n      const fsStat = fs.statSync(resolvedFullPath);\r\n      return {\r\n        isDirectory: fsStat.isDirectory(),\r\n        length: fsStat.size,\r\n        timestamp: deriveTimestamp(fsStat) || 0\r\n      };\r\n    }\r\n  }\r\n\r\n}","namespace danfo {\n  export function runWorker() {\n  }\n}","/** needed for creepy @types/node syntax */\ndeclare interface Set<T> { }\n\nnamespace danfo {\n\n  export declare function node(): void;\n\n  export namespace node {\n\n    for (const k in danfo.node) {\n      if (k in bootNode) continue;\n\n      (bootNode as any)[k] = (danfo.node as any)[k];\n    }\n    (danfo.node as any) = bootNode;\n    (node as any) = bootNode;\n\n    function bootNode() {\n\n      if (!process?.stdout?.isTTY) {\n        for (const k in node.colors) {\n          if (typeof (node.colors as any)[k] === 'string')\n            (node.colors as any)[k] = '';\n        }\n      }\n\n      let cmdline: danfo.parsing.cmdline.parseCmdline.Cmdline;\n\n      {\n        let cmd = danfo.parsing.cmdline.parseCmdline(process);\n        if (!cmd) {\n          // must have been invoked as a library, not a command line tool\n          return;\n        }\n\n        if (cmd === 'worker')\n          return runWorker();\n        else\n          cmdline = cmd;\n      }\n\n      console.log(node.colors.yellow + '🚌 𝒹𝒶𝓃𝒻𝑜 v' + danfo.versionStr + node.colors.reset);\n\n      if (cmdline.dumpCmdLine) {\n        const _dumpCmdline = { ...cmdline } as any;\n        if (_dumpCmdline.packageJson)\n          _dumpCmdline.packageJson = '{...}';\n        console.log('cmdline ', _dumpCmdline);\n      }\n\n\n      if (cmdline.knownArguments && cmdline.knownArguments.help) {\n        console.log(helpText());\n      }\n\n      if (cmdline.knownArguments && cmdline.knownArguments.version) {\n        console.log(versionStr);\n      }\n\n      if (cmdline.errors) {\n        for (let i = 0; i < cmdline.errors.length; i++) {\n          console.log(node.colors.red + 'ERROR ' + cmdline.errors[i] + node.colors.reset);\n        }\n\n        process.exit(1); // error exit code 1\n        return;\n      }\n\n      runAsync().then(() => {\n        // TODO: finished.\n      }, error => {\n        console.error(error);\n        process.exit(2); // error exit code 2 (crash not just incorrect arguments)\n      });\n\n      return;\n\n      async function runAsync() {\n        let serverUp: { options: danfo.node.server.run.Options, server: danfo.node.server.Server } | undefined;\n\n        if (cmdline.scaffold) {\n          performScaffold();\n        }\n\n        if (cmdline.build) {\n          const startRootDir = npmLifecycleCurrentDirectory();\n          const trackingFileSystem = createFS(startRootDir);\n          const nonTrackingFileSystem = createFS(startRootDir);\n          nonTrackingFileSystem.stopWatching();\n\n          let firstBuild = true;\n          const fs = require('fs') as typeof import('fs');\n          danfo.build.projectBuilder({\n            projRoot:\n              cmdline.projRoot ||\n              (cmdline.sources?.length ? void 0 : startRootDir), // if neither sources nor project root specified, use current directory\n            trackingFileSystem,\n            sources: cmdline.sources || [],\n            outputPath: cmdline.outputPath,\n            watch: cmdline.watch,\n            onBuildStart: buildContext => {\n              if (firstBuild) {\n                if (cmdline.server) {\n                  const projectDirWithFallback = buildContext.projectDir || startRootDir;\n                  nonTrackingFileSystem.fs.basePath = projectDirWithFallback;\n                  serverUp = startServer(nonTrackingFileSystem.fs, projectDirWithFallback, buildContext.outputDirPath);\n                }\n                process.stdout.write(node.colors.cyan + 'Build...' + node.colors.reset);\n              }\n              else {\n                const changes: string[] = [];\n                if (buildContext.changes) {\n                  for (const ch of buildContext.changes) {\n                    if (ch) changes.push(ch);\n                  }\n                }\n                const maxChangeOneLine = 3;\n                const maxChangeCount = 5;\n                if (!changes.length) {\n                  process.stdout.write('\\n' + node.colors.cyan + 'Rebuild [unknown changes]...' + node.colors.reset);\n                }\n                else if (changes.length <= maxChangeOneLine) {\n                  const filenames: string[] = [];\n                  for (const ch of buildContext.changes!) {\n                    filenames.push(node.colors.brightCyan + danfo.build.getBaseName(ch).replace(/\\\\/g, '/')) + node.colors.reset;\n                  }\n                  const rebuildText = '\\n' + node.colors.cyan + 'Rebuild [' + node.colors.reset + filenames.join(node.colors.cyan + ', ' + node.colors.reset) + node.colors.cyan + ' changed]...' + node.colors.reset;\n                  process.stdout.write(rebuildText);\n                }\n                else {\n                  let rebuildText = '\\n' + node.colors.cyan + 'Rebuild [' + node.colors.brightCyan + buildContext.changes!.length + node.colors.cyan + ' changes]:' + node.colors.reset;\n                  for (let i = 0; i < maxChangeCount; i++) {\n                    const moreLast = i < changes.length && i === maxChangeCount - 1;\n                    const ch = buildContext.changes![moreLast ? buildContext.changes!.length - 1 : i];\n                    const relPath = trackingFileSystem.fs.getRelativePath(buildContext.projectDir || trackingFileSystem.fs.basePath, ch).replace(/\\\\/g, '/');\n                    const lastSlashPos = relPath.lastIndexOf('/');\n                    const lead = lastSlashPos >= 0 ? relPath.slice(0, lastSlashPos + 1) : '';\n                    const trail = lastSlashPos >= 0 ? relPath.slice(lastSlashPos + 1) : relPath;\n                    rebuildText += '\\n  ' + node.colors.cyan + '< ' + (moreLast ? '... ' : '') + lead + node.colors.brightCyan + trail + node.colors.reset;\n                  }\n                  rebuildText += '\\n' + node.colors.cyan + '  ...' + node.colors.reset;\n                  process.stdout.write(rebuildText);\n                }\n              }\n            },\n            onBuildFinish: buildContext => {\n              const projectDirWithFallback = buildContext.projectDir || startRootDir;\n              nonTrackingFileSystem.fs.basePath = projectDirWithFallback;\n              if (serverUp) {\n                serverUp.server.distDir = buildContext.outputDirPath;\n              }\n\n              if (firstBuild) {\n                if (buildContext.html && cmdline.server !== false)\n                  serverUp = startServer(nonTrackingFileSystem.fs, projectDirWithFallback, buildContext.outputDirPath);\n                \n                // TODO: whatever else (start browser maybe?)\n              }\n              \n              firstBuild = false;\n\n              let builtText = ' ' + node.colors.cyan + ((buildContext.buildTime / 100) | 0) / 10 + 's.' + node.colors.reset;\n              if (buildContext.errors.length) {\n                builtText += '\\n' + node.colors.red + '>> ' + (buildContext.errors.length === 1 ? 'ERROR' : buildContext.errors.length + ' ERRORS') + ' <<' + node.colors.reset;\n                for (const err of buildContext.errors) {\n                  if (typeof err.format === 'function') {\n                    builtText += '\\n' + err.format();\n                  }\n                  else {\n                    builtText += '\\n' + err.message;\n                  }\n                }\n              }\n\n              if (buildContext.emits.length) {\n                for (const em of buildContext.emits) {\n                  const path = (buildContext.projectDir ? trackingFileSystem.fs.getRelativePath(buildContext.projectDir, em.fullPath) : em.localPath)\n                    .replace(/\\\\/g, '/');\n\n                  if (!em.changedFrom) {\n                    builtText += '\\n' + node.colors.grey + '  > ' + path + ' (no change)' + node.colors.reset;\n                  }\n                  else {\n                    if (typeof em.changedFrom.content !== 'string') {\n                      builtText += '\\n  > ' + path + ' > NEW';\n                    }\n                    else {\n                      builtText += '\\n  > ' + path + ' > CHANGED' + node.colors.grey + ' AFTER ' + (((Date.now() - em.changedFrom.timestamp!) / 100) | 0) / 10 + 's' + node.colors.reset;\n                    }\n                    createParentDirectoryRecursive(em.fullPath);\n                    trackingFileSystem.fs.writeFile(em.fullPath, em.content as string);\n                  }\n                }\n              }\n\n              console.log(builtText);\n            }\n          });\n        }\n\n        // END of runAsync here\n\n        function startServer(fileSystem: FileSystemWithBinary, projDir: string, outputDirPath: string) {\n          if (serverUp) return serverUp;\n          const host = (cmdline.server ? cmdline.server.host : void 0) || 'localhost';\n          const port = (cmdline.server ? cmdline.server.port : void 0) || danfo.parsing.cmdline.derivePort(projDir);\n          const options: danfo.node.server.run.Options = {\n            distDir: outputDirPath,\n            fileSystem,\n            projectDir: cmdline.projRoot || '.',\n            host,\n            port\n          };\n          const server = danfo.node.server.run(options);\n\n          process.stdout.write(\n            ' ' + node.colors.brightBlue + ((cmdline.server ? cmdline.server.https : false) ? 'https://' : 'http://') + options.host + ':' + options.port + '/' + node.colors.reset\n          );\n\n          return { options, server };\n        }\n\n        function createParentDirectoryRecursive(filePath: string) {\n          const path = require('path') as typeof import('path');\n          const fs = require('fs') as typeof import('fs');\n\n          const dirPath = path.dirname(filePath);\n\n          if (fs.existsSync(dirPath)) return;\n          createParentDirectoryRecursive(dirPath)\n          fs.mkdirSync(dirPath);\n        }\n\n      }\n    }\n\n  }\n\n  function npmLifecycleCurrentDirectory() {\n    return (\n      process.env.INIT_CWD ||\n      (process.env.npm_lifecycle_event ?\n        (require('path') as typeof import('path')).resolve(__dirname, '../..') :\n        process.cwd()\n      )\n    );\n  }\n\n}","namespace danfo.node {\r\n\r\n  export const colors = {\r\n    grey: '\\x1b[90;1m\\x1b[38;5;238m',\r\n    red: '\\x1b[31m',\r\n    green: '\\x1b[32m',\r\n    yellow: '\\x1b[33m',\r\n    cyan: '\\x1b[36m\\x1b[38;5;30m',\r\n    brightGreen: '\\x1b[92m',\r\n    brightBlue: '\\x1b[94m',\r\n    brightCyan: '\\x1b[96m\\x1b[38;5;51m',\r\n    reset: '\\x1b[0m'\r\n  };\r\n\r\n}","namespace danfo.node {\r\n\r\n  export declare namespace formatBuildError {\r\n\r\n    type Options = {\r\n      typescriptForFormatting: typeof import('typescript');\r\n      fileSystem: { resolvePath(path: string): string };\r\n      projRoot: string;\r\n    }\r\n  }\r\n\r\n  export function formatBuildError(err: build.code.BuildError, { typescriptForFormatting, fileSystem, projRoot }: formatBuildError.Options) {\r\n    if (err.typescriptDetails) {\r\n      try {\r\n        if (!typescriptForFormatting)\r\n          typescriptForFormatting = require('typescript') as typeof import('typescript');\r\n\r\n        const formatted = typescriptForFormatting.formatDiagnosticsWithColorAndContext([err.typescriptDetails], {\r\n          getCanonicalFileName: file => fileSystem.resolvePath(file),\r\n          getCurrentDirectory: () => projRoot,\r\n          getNewLine: () => '\\n'\r\n        }).replace(/^\\n+/, '').replace(/\\n+$/, '');\r\n        return formatted;\r\n      }\r\n      catch (tsFormatError) { }\r\n    }\r\n\r\n    return err.code + ' ' + err.message;\r\n  }\r\n}","namespace danfo.node {\n  export function helpText() {\n    return '';\n  }\n}","namespace danfo.node {\n  export async function startBrowser(url: string) {\n\n  }\n}","namespace danfo.parsing.cmdline {\n  export function derivePort(projRoot: string): number {\n    return 4500 + Math.abs(derivePort.strHashCode(projRoot)) % 5000;\n  }\n\n  export namespace derivePort {\n\n    export function strHashCode(str: string) {\n      let sum = 127653294848;\n      for (let i = 0; i < str.length; i++) {\n        sum = ((sum << 5) - sum) + str.charCodeAt(i);\n        sum = sum & sum;\n      }\n      return sum;\n    }\n  }\n\n}","namespace danfo.parsing.cmdline {\n  export declare namespace parseCmdline {\n    type Cmdline = {\n      scaffold?: boolean;\n      server: HostAndPort | false | undefined;\n      startBrowser: boolean | undefined;\n      build: boolean;\n      watch: boolean | undefined;\n      dumpCmdLine: boolean;\n\n      sources?: string[];\n\n      knownArguments?: knownArguments;\n      errors?: string[];\n\n      projRoot?: string;\n\n      outputPath?: string;\n    }\n\n    type HostAndPort = {\n      https?: boolean;\n      host?: string;\n      port?: number;\n    }\n\n    type knownArguments = {\n      build?: boolean;\n      scaffold?: boolean;\n      serverAndPort?: { host?: string, port?: number } | false;\n      watch?: boolean;\n      help?: boolean;\n      version?: boolean;\n      outPath?: string;\n      projRoot?: string;\n      dumpCmdLine?: boolean;\n    }\n\n    type ProcessSubset = {\n      argv: string[];\n      env: {\n        npm_lifecycle_event?: string;\n        [name: string]: string | undefined\n      }\n    }\n  }\n\n  export function parseCmdline(process: parseCmdline.ProcessSubset): parseCmdline.Cmdline | 'worker' | undefined {\n    let argv = process.argv.slice();\n\n    if (/^node(\\.exe)?$/i.test(danfo.build.getBaseName(argv[0] || '')))\n      argv.shift();\n\n    if (/^danfo(\\.js)?$/i.test(danfo.build.getBaseName(argv[0])))\n      argv.shift();\n    else\n      return; // only run in command line mode when started as 'danfo'\n\n    if (argv.length === 1 && argv[0] === '--worker') return 'worker';\n\n    let argsParsed = parseCmdline.parseArgs(argv);\n\n    let projRoot = argsParsed.knownArguments?.projRoot;\n\n    if (process.env.npm_lifecycle_event === 'postinstall' || process.env.npm_lifecycle_event === 'install') {\n      // TODO: trigger check for scaffolding?\n      return resultNpmLifecycleDoNothing();\n    }\n    // else if (process.env.npm_lifecycle_event) {\n    //   console.log('npm_lifecycle_event ', process.env.npm_lifecycle_event);\n    //   return resultNpmLifecycleDoNothing();\n    // }\n\n    let printAndExit =\n      argsParsed.errors ||\n      (argsParsed.knownArguments && (argsParsed.knownArguments.help || argsParsed.knownArguments.version));\n\n    if (printAndExit) {\n      return {\n        projRoot,\n        scaffold: false,\n        server: void 0,\n        startBrowser: false,\n        build: false,\n        watch: false,\n        dumpCmdLine: argsParsed.knownArguments?.dumpCmdLine ?? false,\n        outputPath: argsParsed.knownArguments &&\n          argsParsed.knownArguments.outPath,\n  \n        sources: argsParsed.unknownArguments,\n        knownArguments: argsParsed.knownArguments,\n        errors: argsParsed.errors\n      };\n    }\n\n    if (argsParsed.unknownArguments?.length) {\n\n      return {\n        projRoot,\n        scaffold: false,\n        server: argsParsed.knownArguments?.serverAndPort,\n        startBrowser: true,\n        build: typeof argsParsed.knownArguments?.build === 'boolean' ? argsParsed.knownArguments.build : true,\n        watch: argsParsed.knownArguments?.watch,\n        dumpCmdLine: argsParsed.knownArguments?.dumpCmdLine ?? false,\n        outputPath: argsParsed.knownArguments &&\n          argsParsed.knownArguments.outPath,\n\n        sources: argsParsed.unknownArguments,\n        knownArguments: argsParsed.knownArguments,\n        errors: argsParsed.errors\n      }\n    }\n    else {\n\n      return {\n        projRoot,\n        scaffold: void 0,\n        server: argsParsed.knownArguments?.serverAndPort,\n        startBrowser: void 0,\n        build: typeof argsParsed.knownArguments?.build === 'boolean' ? argsParsed.knownArguments.build : true,\n        watch: argsParsed.knownArguments?.watch,\n        dumpCmdLine: argsParsed.knownArguments?.dumpCmdLine ?? false,\n        outputPath: argsParsed.knownArguments &&\n          argsParsed.knownArguments.outPath,\n\n        sources: argsParsed.unknownArguments,\n        knownArguments: argsParsed.knownArguments,\n        errors: argsParsed.errors\n      }\n    }\n\n\n    function resultNpmLifecycleDoNothing() {\n      return {\n        projRoot,\n        scaffold: false,\n        server: void 0,\n        startBrowser: false,\n        build: false,\n        watch: false,\n        dumpCmdLine: false,\n\n        emptyDirectory: false,\n        defaultTarget: false\n      };\n    }\n  }\n\n  export namespace parseCmdline {\n\n    const regexp_false = /^(false|no|not|off|\\-|disabled|disable)$/i;\n    const regexp_true = /^(true|yes|on|\\+|enabled|enable)$/i;\n\n    export function parseArgs(argv: string[]) {\n      let unknownArguments: string[] = [];\n      let knownArguments: parseCmdline.knownArguments | undefined;\n      let errors: string[] = [];\n\n      for (let i = 0; i < argv.length; i++) {\n        let arg = argv[i];\n\n        if (/^(--|-|\\/)?scaffold$/i.test(arg)) {\n          if (i + 1 < argv.length && /^true$/i.test(argv[i + 1])) {\n            if (!knownArguments) knownArguments = {};\n            knownArguments.scaffold = true;\n            i++;\n          }\n          else if (i + 1 < argv.length && /^false$/i.test(argv[i + 1])) {\n            if (!knownArguments) knownArguments = {};\n            knownArguments.scaffold = false;\n            i++;\n          }\n\n          if (!knownArguments) knownArguments = {};\n          knownArguments.scaffold = true;\n          continue;\n        }\n\n        let scaffoldArgMatch = /^(--|-|\\/)?scaffold(\\:|\\=)(true|false)$/i.exec(arg);\n        if (scaffoldArgMatch && /true/i.test(scaffoldArgMatch[3])) {\n          if (!knownArguments) knownArguments = {};\n          knownArguments.scaffold = true;\n          continue;\n        }\n        else if (scaffoldArgMatch && /false/i.test(scaffoldArgMatch[3])) {\n          if (!knownArguments) knownArguments = {};\n          knownArguments.scaffold = false;\n          continue;\n        }\n\n\n        let dumpCmdLine = /^(--|-|\\/)?(cmdline|dumpcmdline|dumpcmd|dmpcmd)$/i.exec(arg);\n        if (dumpCmdLine) {\n          if (!knownArguments) knownArguments = {};\n          knownArguments.dumpCmdLine = true;\n          continue;\n        }\n\n        let portArgMatch = /^(--|-|\\/)?(port|serve|server)$/i.exec(arg);\n        if (portArgMatch) {\n          let hostAndPort: Partial<parseCmdline.HostAndPort> | undefined;\n          let enabled = true;\n          if (i + 1 < argv.length && /^[^\\-\\/]$/i.test(argv[i + 1])) {\n            const parsedEnabled = parseCmdline.parseBoolean(argv[i + 1]);\n            if (typeof parsedEnabled === 'boolean') {\n              enabled = parsedEnabled;\n              i++;\n            }\n            else if ((hostAndPort = parseHostAndPort(argv[i + 1]))) {\n              if (!knownArguments) knownArguments = {};\n              knownArguments.serverAndPort = { ...knownArguments.serverAndPort, ...hostAndPort };\n              i++;\n            }\n          }\n          else if (/port/i.test(portArgMatch[2])) {\n            errors.push('port option requires numeric parameter');\n            continue;\n          }\n\n          if (!knownArguments) knownArguments = {};\n          if (!knownArguments.serverAndPort)\n            knownArguments.serverAndPort = enabled ? {} : false;\n          continue;\n        }\n\n        portArgMatch = /^(--|-|\\/)?(port|serve|server)(\\:|\\=)(.+)$/i.exec(arg);\n        if (portArgMatch) {\n          const enabled = parseCmdline.parseBoolean(portArgMatch[4]);\n          if (typeof enabled !== 'boolean') {\n            const hostAndPort = parseHostAndPort(portArgMatch[4]);\n            if (hostAndPort) {\n              if (!knownArguments) knownArguments = {};\n              knownArguments.serverAndPort = { ...knownArguments.serverAndPort, ...hostAndPort };\n              continue;\n            }\n            else {\n              errors.push('incorrect host/port parameter: ' + portArgMatch[4]);\n              continue;\n            }\n          }\n\n          if (!knownArguments) knownArguments = {};\n          if (!knownArguments.serverAndPort)\n            knownArguments.serverAndPort = enabled ? {} : false;\n          continue;\n        }\n\n        let watchMatch = /^(--|-|\\/)?(w|watch)$/i.exec(arg);\n        if (watchMatch) {\n          let watch = true;\n          if (i + 1 < argv.length && /^[^\\-\\/]$/i.test(argv[i + 1])) {\n            const parsedWatch = parseCmdline.parseBoolean(argv[i + 1]);\n            if (typeof parsedWatch === 'boolean') {\n              watch = parsedWatch;\n              i++;\n            }\n          }\n\n          if (!knownArguments) knownArguments = {};\n          knownArguments.watch = watch;\n          continue;\n        }\n\n        watchMatch = /^(--|-|\\/)?(nw|nowatch)$/i.exec(arg);\n        if (watchMatch) {\n          if (!knownArguments) knownArguments = {};\n          knownArguments.watch = false;\n          continue;\n        }\n\n        watchMatch = /^(--|-|\\/)?(w|watch)(\\:|\\=)([a-z\\+\\-]+)$/i.exec(arg);\n        if (watchMatch) {\n          const watchMatchArg = parseCmdline.parseBoolean(watchMatch[4]);\n          if (typeof watchMatchArg === 'boolean') {\n            if (!knownArguments) knownArguments = {};\n            knownArguments.watch = watchMatchArg;\n            continue;\n          }\n        }\n\n        let outputArgMatch = /^(--|-|\\/)?(o|out|output|outdir|dist)(\\:|\\=)?$/i.exec(arg);\n        if (outputArgMatch) {\n          if (i + 1 < argv.length) {\n            if (!knownArguments) knownArguments = {};\n            knownArguments.outPath = argv[i + 1];\n            i++;\n            continue;\n          }\n        }\n\n        outputArgMatch = /^(--|-|\\/)?(o|out|output|outdir|dist)(\\:|\\=)(.+)$/i.exec(arg);\n        if (outputArgMatch) {\n          if (!knownArguments) knownArguments = {};\n          knownArguments.outPath = outputArgMatch[4];\n          continue;\n        }\n\n        {\n          let projRootArgMatch = /^(--|-|\\/)?(p|proj|projRoot|projDir|root)(\\:|\\=)?$/i.exec(arg);\n          if (projRootArgMatch) {\n            if (i + 1 < argv.length) {\n              if (!knownArguments) knownArguments = {};\n              knownArguments.projRoot = argv[i + 1];\n              i++;\n              continue;\n            }\n          }\n\n          projRootArgMatch = /^(--|-|\\/)?(p|proj|projRoot|projDir|root)(\\:|\\=)(.+)$/i.exec(arg);\n          if (projRootArgMatch) {\n            if (!knownArguments) knownArguments = {};\n            knownArguments.projRoot = projRootArgMatch[4];\n            continue;\n          }\n        }\n\n        let buildArgMatch = /^(--|-|\\/)?(build)(\\:|\\=)?$/i.exec(arg);\n        if (buildArgMatch &&\n          // 'build' may plausibly be ussed as a directory name, so this option will only be applicable\n          // if used with suffix or prefix: '--build' or 'build= true' or '--build= true'\n          // but not 'build' nor 'build true'\n          (buildArgMatch[1] || buildArgMatch[3])) {\n          \n          const buildMatchBoolean = i + 1 < argv.length ? \n            parseCmdline.parseBoolean(argv[i + 1]) :\n            void 0;\n\n          if (typeof buildMatchBoolean === 'boolean') {\n            if (!knownArguments) knownArguments = {};\n            knownArguments.build = buildMatchBoolean;\n            i++;\n            continue;\n          }\n          else if (!buildArgMatch[3]) {\n            // '--build' wihout subsequent parameter implies build: true\n            if (!knownArguments) knownArguments = {};\n            knownArguments.build = true;\n          }\n        }\n\n        buildArgMatch = /^(--|-|\\/)?(build)(\\:|\\=)(.+)$/i.exec(arg);\n        if (buildArgMatch) {\n          const buildMatchBoolean = parseCmdline.parseBoolean(buildArgMatch[4]);\n          if (typeof buildMatchBoolean) {\n            if (!knownArguments) knownArguments = {};\n            knownArguments.build = buildMatchBoolean;\n            continue;\n          }\n        }\n\n        if (/^(--|-|\\/)?h(elp)?$/i.test(arg)) {\n          if (!knownArguments) knownArguments = {};\n          knownArguments.help = true;\n          continue;\n        }\n\n        if (/^(--|-|\\/)?v(er(sion)?)?$/i.test(arg)) {\n          if (!knownArguments) knownArguments = {};\n          knownArguments.version = true;\n          continue;\n        }\n\n        unknownArguments.push(arg);\n      }\n\n      return {\n        knownArguments,\n        unknownArguments: unknownArguments && unknownArguments.length && unknownArguments || void 0,\n        errors: errors && errors.length && errors || void 0\n      };\n    }\n\n    export function parseHostAndPort(hostAndPortStr: string): Partial<parseCmdline.HostAndPort> | undefined {\n      if (/^[0-9]+$/.test(hostAndPortStr))\n        return { host: void 0, port: Number(hostAndPortStr) };\n\n      let https: boolean | undefined;\n      const regexp_protocolLead = /^(http|https)\\:\\/*/i;\n      const protocolLeadMatch = regexp_protocolLead.exec(hostAndPortStr);\n      if (protocolLeadMatch) {\n        https = /https/i.test(protocolLeadMatch[1]);\n        hostAndPortStr = hostAndPortStr.slice(protocolLeadMatch[0].length);\n      }\n\n      const regexp_hostAndPortPattern = /^(.+)\\:([0-9]+)$/;\n      const hostAndPortPatternMatch = regexp_hostAndPortPattern.exec(hostAndPortStr);\n      if (hostAndPortPatternMatch)\n        return { https, host: hostAndPortPatternMatch[1], port: Number(hostAndPortPatternMatch[2]) };\n      else\n        return { https, host: hostAndPortStr };\n    }\n\n    export function deriveHostAndPort(hostAndPort: Partial<parseCmdline.HostAndPort> | boolean | undefined, projRoot: string): parseCmdline.HostAndPort | undefined {\n      if (!hostAndPort)\n        return void 0;\n\n      return {\n        https:\n          hostAndPort === true ? false :\n            hostAndPort.https || false,\n        host:\n          hostAndPort === true || !hostAndPort.host ? 'localhost' : hostAndPort.host,\n        port:\n          hostAndPort !== true && typeof hostAndPort.port === 'number' ? hostAndPort.port :\n            hostAndPort !== true && hostAndPort.https === true ? 443 :\n              hostAndPort !== true && hostAndPort.https === false ? 80 :\n                derivePort(projRoot)\n      };\n    }\n\n    export function hasHtmlExtension(fileName: string) {\n      return /[^\\\\]\\.html$/i.test(fileName);\n    }\n\n    export function parseBoolean(txt: string) {\n      if (regexp_false.test(txt))\n        return false;\n      else if (regexp_true.test(txt))\n        return true;\n    }\n\n  }\n\n}","namespace danfo.parsing.sourcemap {\r\n\r\n  export declare namespace combineMappings {\r\n\r\n    type MappingEntry = {\r\n      generatedLine: number;\r\n      generatedColumn: number;\r\n      mappings: string;\r\n      fileCount: number;\r\n      nameCount: number;\r\n    }\r\n\r\n  }\r\n\r\n  export function combineMappings(mappingsList: combineMappings.MappingEntry[]) {\r\n    const output = writer();\r\n\r\n    let veryFirstLine = true;\r\n    let prevCombinedFileCount = 0;\r\n    let prevCombinedNameCount = 0;\r\n    for (const entry of mappingsList) {\r\n      for (const input = reader(entry.mappings); input.read();) {\r\n        input.generatedLine += entry.generatedLine;\r\n        if (veryFirstLine) {\r\n          // for concatenated scripts, only the very first line of the first script is bumped\r\n          input.generatedColumn += entry.generatedColumn;\r\n          veryFirstLine = false;\r\n        }\r\n\r\n        // previous scripts' tables shift next scripts' offsets down\r\n        input.originalFile += prevCombinedFileCount;\r\n        if (input.originalName >= 0) input.originalName += prevCombinedNameCount;\r\n        \r\n        output.write(input);\r\n      }\r\n      \r\n      prevCombinedFileCount += entry.fileCount;\r\n      prevCombinedNameCount += entry.nameCount;\r\n    }\r\n\r\n    return output.text();\r\n  }\r\n\r\n}","namespace danfo.parsing.sourcemap {\r\n\r\n  export declare namespace concatenate {\r\n\r\n    type SourceSpan = {\r\n      fileName: string;\r\n      output: string;\r\n      sourcemap: { fileName: string, content: string };\r\n      resolvePath?(path: string): string;\r\n    }\r\n\r\n    type Options =\r\n      (\r\n        { sourcemapFileName: string; fileName?: string; } |\r\n        { sourcemapFileName?: string; fileName: string; }\r\n      ) &\r\n      {\r\n        extraFiles?: ExtraFile[];\r\n        preserveWhitespace?: boolean;\r\n      }\r\n\r\n    type ExtraFile = {\r\n      fileName: string;\r\n      content: string;\r\n    }\r\n\r\n  }\r\n\r\n  const regex_leadingLineHasNonWhitespace = /^[^\\S\\r\\n]*\\S/;\r\n  const regex_trailingLineHasNonWhitespace = /\\S[^\\S\\r\\n]*$/;\r\n  const regex_anyNonWhitespace = /\\S/;\r\n  const regex_TSorTSX = /\\.ts$|\\.tsx$/i;\r\n  const regex_MAP = /\\.map$/i;\r\n\r\n  export function concatenate(\r\n    { sourcemapFileName, fileName, extraFiles, preserveWhitespace }: concatenate.Options,\r\n    inputs: (Partial<concatenate.SourceSpan> | string | undefined)[]): concatenate.SourceSpan | string {\r\n\r\n    if (typeof sourcemapFileName === 'undefined') {\r\n      if (typeof fileName === 'undefined')\r\n        fileName = 'script.js';\r\n      sourcemapFileName = fileName.replace(regex_TSorTSX, '.js') + '.map';\r\n    }\r\n    else if (typeof fileName === 'undefined') {\r\n      fileName = sourcemapFileName.replace(regex_MAP, '');\r\n    }\r\n\r\n    if (typeof preserveWhitespace === 'undefined')\r\n      preserveWhitespace = false;\r\n\r\n    let contentCombined = '';\r\n    let emitOffsets: number[] = [];\r\n    for (let i = 0; i < inputs.length; i++) {\r\n      const entry = inputs[i];\r\n      if (!entry) continue;\r\n\r\n      if (typeof entry === 'string') {\r\n        contentCombined =\r\n          !contentCombined ? entry :\r\n            preserveWhitespace ? concatenate.ensureSingleNewLineSeparator(contentCombined, entry) :\r\n              concatenate.ensureDoubleNewLineSeparator(contentCombined, entry);\r\n        continue;\r\n      }\r\n\r\n      const entryOutput = entry.output || '';\r\n\r\n      const sourcemapMatch = concatenate.findSourcemapSuffix(entryOutput);\r\n      const appendContent = sourcemapMatch ? entryOutput.slice(0, sourcemapMatch.offset) : entryOutput;\r\n      contentCombined =\r\n        !contentCombined ? appendContent :\r\n          preserveWhitespace ? concatenate.ensureSingleNewLineSeparator(contentCombined, appendContent) :\r\n            concatenate.ensureDoubleNewLineSeparator(contentCombined, appendContent);\r\n\r\n      // offset needs calculation because newline may have been injected, or not\r\n      emitOffsets[i] = contentCombined.length - appendContent.length;\r\n    }\r\n\r\n    const combinedLineMap = parsing.lineMap(contentCombined);\r\n    type SourcemapWithOffsets = Sourcemap & combineMappings.MappingEntry & { entry: Partial<concatenate.SourceSpan> };\r\n    const sourcemapObjects: SourcemapWithOffsets[] = [];\r\n    for (let i = 0; i < inputs.length; i++) {\r\n      const entry = inputs[i];\r\n      if (!entry) continue;\r\n      if (typeof entry === 'string' || !entry.sourcemap) continue;\r\n\r\n      const offset = combinedLineMap.getLineAndCharacter(emitOffsets[i])!;\r\n\r\n      let sourcemapJson: SourcemapWithOffsets;\r\n      try {\r\n        sourcemapJson = JSON.parse(entry.sourcemap.content);\r\n      }\r\n      catch (sourcemapParseError) {\r\n        continue;\r\n      }\r\n      sourcemapJson.generatedLine = offset.ln - 1;\r\n      sourcemapJson.generatedColumn = offset.ch - 1;\r\n      sourcemapJson.fileCount = sourcemapJson.sources?.length || 0;\r\n      sourcemapJson.nameCount = sourcemapJson.names?.length || 0;\r\n      sourcemapJson.entry = entry;\r\n\r\n      sourcemapObjects.push(sourcemapJson);\r\n    }\r\n\r\n    if (!sourcemapObjects.length)\r\n      return contentCombined;\r\n    \r\n    const combinedMappings = combineMappings(sourcemapObjects);\r\n    const combinedSourcemap: Sourcemap = {\r\n      version: sourcemapObjects[0].version,\r\n      file: fileName,\r\n      sourceRoot: '',\r\n      sources: [],\r\n      names: [],\r\n      mappings: combinedMappings,\r\n      sourcesContent: []\r\n    };\r\n\r\n    for (const srcmap of sourcemapObjects) {\r\n      for (const s of srcmap.sources) {\r\n        let sourcePath = srcmap.sourceRoot ? srcmap.sourceRoot + '/' + s : s;\r\n        if (typeof srcmap?.entry.resolvePath === 'function')\r\n          sourcePath = srcmap.entry.resolvePath(sourcePath);\r\n\r\n        combinedSourcemap.sources.push(sourcePath);\r\n      }\r\n\r\n      for (const n of srcmap.names) {\r\n        combinedSourcemap.names.push(n);\r\n      }\r\n\r\n      for (let i = 0; i < Math.max(srcmap.sources.length, srcmap.sourcesContent.length); i++) {\r\n        combinedSourcemap.sourcesContent.push(srcmap.sourcesContent[i] || '');\r\n      }\r\n    }\r\n      \r\n\r\n    if (extraFiles && extraFiles.length) {\r\n      const existingFileCount = Math.max(combinedSourcemap.sources.length, combinedSourcemap.sourcesContent.length);\r\n      for (let i = 0; i < extraFiles.length; i++) {\r\n        const fi = extraFiles[i];\r\n        combinedSourcemap.sources[existingFileCount + i] = fi.fileName;\r\n        combinedSourcemap.sourcesContent[existingFileCount + i] = fi.content;\r\n      }\r\n    }\r\n\r\n    const combinedSourcemapString = JSON.stringify(combinedSourcemap);\r\n    contentCombined += '\\n//# sourceMappingURL=' + sourcemapFileName;\r\n    if (!preserveWhitespace)\r\n      contentCombined += '\\n';\r\n    return {\r\n      fileName,\r\n      output: contentCombined,\r\n      sourcemap: { fileName: sourcemapFileName, content: combinedSourcemapString }\r\n    };\r\n  }\r\n\r\n  export namespace concatenate {\r\n\r\n    const regex_anyNonWhitespace = /\\S/;\r\n    const regex_LFwhitespace_end = /\\n[^\\S\\n]*$/;\r\n    const regex_LFwhitespace_LFwhitespace_end = /\\n[^\\S\\n]*\\n[^\\S\\n]*$/;\r\n    const regex_start_LFwhitespace = /^\\n[^\\S\\n]*/;\r\n    const regex_start_LFwhitespace_LFwhitespace = /^\\n[^\\S\\n]*\\n[^\\S\\n]*/;\r\n    const regex_sourcemap = /(\\n\\s*)(\\/\\/#\\s*sourceMappingURL=)([^\\n]+?)(\\s*)$/;\r\n    const regex_any_nonNewLines = /[^\\n]/;\r\n\r\n    export function ensureSingleNewLineSeparator(text1: string, text2: string) {\r\n      if (!regex_any_nonNewLines.test(text1) || !regex_any_nonNewLines.test(text2))\r\n        return text1 + text2;\r\n\r\n      if (!text1 || !regex_anyNonWhitespace.test(text1))\r\n        return text1;\r\n\r\n      const leadCount =\r\n        regex_LFwhitespace_end.test(text1) ? 1 :\r\n          0;\r\n      \r\n      const trailCount =\r\n        regex_start_LFwhitespace.test(text2) ? 1 :\r\n          0;\r\n      \r\n      if (leadCount + trailCount === 0)\r\n        return text1 + '\\n' + text2;\r\n      else\r\n        return text1 + text2;\r\n    }\r\n\r\n\r\n    export function ensureDoubleNewLineSeparator(text1: string, text2: string) {\r\n      if (!regex_any_nonNewLines.test(text1) || !regex_any_nonNewLines.test(text2))\r\n        return text1 + text2;\r\n\r\n      if (!text1 || !regex_anyNonWhitespace.test(text1))\r\n        return text1;\r\n\r\n      const leadCount =\r\n        regex_LFwhitespace_LFwhitespace_end.test(text1) ? 2 :\r\n          regex_LFwhitespace_end.test(text1) ? 1 :\r\n            0;\r\n      \r\n      const trailCount =\r\n        regex_start_LFwhitespace_LFwhitespace.test(text2) ? 2 :\r\n          regex_start_LFwhitespace.test(text2) ? 1 :\r\n            0;\r\n      \r\n      if (leadCount + trailCount === 0)\r\n        return text1 + '\\n\\n' + text2;\r\n      else if (leadCount + trailCount === 1)\r\n        return text1 + '\\n' + text2;\r\n      else\r\n        return text1 + text2;\r\n    }\r\n\r\n    export function findSourcemapSuffix(text: string) {\r\n      const match = regex_sourcemap.exec(text);\r\n      if (match)\r\n        return {\r\n          offset: match.index,\r\n          wholeText: match[0],\r\n          leadWhitespace: match[1],\r\n          sourceMappingURLPrefix: match[2],\r\n          sourcemap: match[3],\r\n          trailWhitespace: match[4]\r\n        };\r\n    }\r\n\r\n  }\r\n}","namespace danfo.parsing.sourcemap {\r\n  \r\n  export type reader = Mapping & { read(): boolean };\r\n\r\n  export function reader(mappings: string) {\r\n\r\n    const numBuffer = [0, 0, 0, 0, 0, 0, 0, 0];\r\n\r\n    let decodeSpanStart = 0;\r\n    let pos = 0;\r\n    const current: Mapping = {\r\n      generatedLine: 0,\r\n      generatedColumn: 0,\r\n      originalLine: 0,\r\n      originalColumn: 0,\r\n      originalFile: 0,\r\n      originalName: -1\r\n    };\r\n\r\n    const result: Mapping & { read(): boolean } = {\r\n      generatedLine: 0,\r\n      generatedColumn: 0,\r\n      originalLine: 0,\r\n      originalColumn: 0,\r\n      originalFile: 0,\r\n      originalName: -1,\r\n      read\r\n    };\r\n\r\n    return result;\r\n\r\n    function read(): boolean {\r\n\r\n      for (; pos < mappings.length; pos++) {\r\n        const ch = mappings.charCodeAt(pos);\r\n        let parsedSpan = false;\r\n\r\n        if (ch === CharCodes.Semicolon) {\r\n          // new line indicator\r\n\r\n          // keep reading if semicolon starts text, or follows another semicolon or colon\r\n          if (pos > decodeSpanStart) {\r\n            decodeCopyVerify();\r\n            parsedSpan = true;\r\n          }\r\n\r\n          current.generatedLine++;\r\n          current.generatedColumn = 0;\r\n          decodeSpanStart = pos + 1;\r\n        }\r\n        else if (ch === CharCodes.Comma) {\r\n          // keep reading if colon starts text, or follows another semicolon or colon\r\n          if (pos > decodeSpanStart) {\r\n            decodeCopyVerify();\r\n            parsedSpan = true;\r\n          }\r\n\r\n          decodeSpanStart = pos + 1;\r\n        }\r\n\r\n        if (parsedSpan) {\r\n          pos++;\r\n          return true;\r\n        }\r\n      }\r\n\r\n      // end of text, check if a span is being read\r\n      if (pos > decodeSpanStart) {\r\n        decodeCopyVerify();\r\n        decodeSpanStart = pos + 1; // to terminate\r\n        return true;\r\n      }\r\n      else {\r\n        return false;\r\n      }\r\n    }\r\n\r\n    function decodeCopyVerify() {\r\n      decodeForMapping(mappings, decodeSpanStart, pos, numBuffer, current);\r\n      copyMapping(current, result);\r\n      verifyMapping(mappings, decodeSpanStart, pos, current);\r\n    }\r\n\r\n  }\r\n\r\n  function verifyMapping(mappings: string, start: number, end: number, mappingEntry: Mapping) {\r\n    if (mappingEntry.generatedColumn < 0\r\n      || mappingEntry.originalLine < 0\r\n      || mappingEntry.originalColumn < 0) {\r\n      throw new Error('Negative absolute value indicate corrupted source map: ' + [\r\n        mappingEntry.generatedColumn < 0 ? 'generatedColumn=' + mappingEntry.generatedColumn : '',\r\n        mappingEntry.originalLine < 0 ? 'originalLine=' + mappingEntry.originalLine : '',\r\n        mappingEntry.originalColumn < 0 ? 'originalColumn=' + mappingEntry.originalColumn : ''\r\n      ].filter(x => x).join(', ') +\r\n        ' at offset ' + start + ' with ' + JSON.stringify(mappings.slice(start, end)));\r\n    }\r\n  }\r\n\r\n  function decodeForMapping(mappings: string, start: number, end: number, numBuffer: number[], mappingEntry: Mapping) {\r\n    const bufLen = decodeVLQSpanToArray(mappings, start, end, numBuffer);\r\n    if (bufLen < 4) throw new Error('Incorrect encoded span, ' + bufLen + ' is too short: ' + mappings.slice(start, end) + '.');\r\n    if (bufLen > 5) throw new Error('Incorrect encoded span, ' + bufLen + ' is too long: ' + mappings.slice(start, end) + '.');\r\n\r\n    mappingEntry.generatedColumn += numBuffer[0];\r\n    mappingEntry.originalFile += numBuffer[1];\r\n    mappingEntry.originalLine += numBuffer[2];\r\n    mappingEntry.originalColumn += numBuffer[3];\r\n\r\n    // Need to carry the last name index even if it's not specified,\r\n    // because it's relative when it is used.\r\n    // For that, it's converted into a negative number (zero becomes -1, 1 becomes -2 etc.) \r\n    if (bufLen === 5) {\r\n      mappingEntry.originalName =\r\n        (mappingEntry.originalName < 0 ? -mappingEntry.originalName - 1 : mappingEntry.originalName)\r\n        + numBuffer[4];\r\n    }\r\n    else if (mappingEntry.originalName >= 0) {\r\n      mappingEntry.originalName = -mappingEntry.originalName - 1;\r\n    }\r\n  }\r\n\r\n  function copyMapping(from: Mapping, to: Mapping) {\r\n    to.generatedLine = from.generatedLine;\r\n    to.generatedColumn = from.generatedColumn;\r\n    to.originalFile = from.originalFile;\r\n    to.originalLine = from.originalLine;\r\n    to.originalName = from.originalName;\r\n  }\r\n\r\n  export namespace reader {\r\n\r\n    /** note $(?![\\r\\n])  at the end of regex, which matches the true EOF rather than just EOL */\r\n    const regex_sourcemapUrl = /\\/\\/[\\t ]*#[\\t ]*sourceMappingURL[\\t ]*=[\\t ]*(.+?)(\\s*)$(?![\\r\\n])/m;\r\n    const regex_embeddedDataPrefix = /^data\\:application\\/json\\;base64\\,/;\r\n\r\n    export declare type SourcemapAndReader = {\r\n      sourcemap: Sourcemap;\r\n      reader: reader;\r\n    };\r\n\r\n    export declare namespace findSourcemappingURL {\r\n      export type Result = {\r\n        url: string;\r\n        position: number;\r\n\r\n        embeddedSourcemap?: SourcemapAndReader;\r\n      }\r\n    }\r\n\r\n    export function findSourcemappingURL(scriptText: string): findSourcemappingURL.Result | undefined {\r\n      const match = scriptText && regex_sourcemapUrl.exec(scriptText);\r\n      if (!match) return void 0;\r\n      const url = match[1];\r\n\r\n      const embeddedDataPrefixMatch = regex_embeddedDataPrefix.exec(url);\r\n      if (embeddedDataPrefixMatch) {\r\n        const base64Data = url.slice(embeddedDataPrefixMatch.index + embeddedDataPrefixMatch[0].length);\r\n        try {\r\n          const embeddedSourcemap = fromSourceMap(danfo.parsing.atob(base64Data));\r\n          if (embeddedSourcemap) {\r\n            return {\r\n              url,\r\n              position: scriptText.length - match[2].length - url.length,\r\n              embeddedSourcemap\r\n            };\r\n          }\r\n        }\r\n        catch (error) {\r\n        }\r\n      }\r\n\r\n      return {\r\n        url,\r\n        position: scriptText.length - match[2].length - url.length\r\n      };\r\n    }\r\n\r\n    export function fromSourceMap(sourcemapContent: string): SourcemapAndReader | undefined {\r\n      if (!sourcemapContent) return void 0;\r\n      let sourcemap: Sourcemap;\r\n      try {\r\n        // TODO do basic sanity check pre-parse to bail out early\r\n        sourcemap = JSON.parse(sourcemapContent);\r\n      }\r\n      catch (error) {\r\n        return void 0;\r\n      }\r\n\r\n      if (!sourcemap || typeof sourcemap.mappings !== 'string') return void 0;\r\n      const theReader = reader(sourcemap.mappings);\r\n\r\n      return {\r\n        sourcemap,\r\n        reader: theReader\r\n      };\r\n    }\r\n  }\r\n}","namespace danfo.parsing.sourcemap {\r\n\r\n  const integerToChar = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=';\r\n  const charToInteger = 'i   j_`abcdefgh   k   +,-./0123456789:;<=>?@ABCD      EFGHIJKLMNOPQRSTUVWXYZ[\\\\]^';\r\n  const baseChar = 43;\r\n  \r\n  export function decodeVLQSpanToArray(string: string, start = 0, end = string.length, resultArray: number[]): number {\r\n    let shift = 0;\r\n    let value = 0;\r\n\r\n    let resultArrayOffset = 0;\r\n    for (let i = start; i < end; i += 1) {\r\n      const ch = string.charCodeAt(i);\r\n\r\n      let integer = charToInteger.charCodeAt(ch - baseChar) - baseChar;\r\n\r\n      if (!(integer>=0))\r\n        throw new Error('Invalid character \"' + string.charAt(i) + '\" at position ' + i + ': ' + string.slice(start, end) + '.');\r\n\r\n      const hasContinuationBit = integer & 32;\r\n\r\n      integer &= 31;\r\n      value += integer << shift;\r\n\r\n      if (hasContinuationBit) {\r\n        shift += 5;\r\n      } else {\r\n        const shouldNegate = value & 1;\r\n        value >>>= 1;\r\n\r\n        if (shouldNegate)\r\n          resultArray[resultArrayOffset] = value === 0 ? -0x80000000 : -value;\r\n        else\r\n          resultArray[resultArrayOffset] = value;\r\n        \r\n        resultArrayOffset++;\r\n\r\n        // reset\r\n        value = shift = 0;\r\n      }\r\n    }\r\n\r\n    return resultArrayOffset;\r\n  }\r\n\r\n  export function encodeVLQArray(value: number[], start?: number, end?: number): string;\r\n  export function encodeVLQArray(value: number[], start: number, end: number, result: { [byteIndex: number]: number }, offset: number): number;\r\n  export function encodeVLQArray(value: number[], start = 0, end = value.length, result?: { [byteIndex: number]: number }, offset?: number): string | number {\r\n    let resultStr = '';\r\n    let bufSize = 0;\r\n    for (let i = 0; i < end; i += 1) {\r\n      let num = value[i];\r\n\r\n      if (num < 0) num = (-num << 1) | 1;\r\n      else num <<= 1;\r\n\r\n      do {\r\n        let clamped = num & 31;\r\n        num >>>= 5;\r\n\r\n        if (num > 0) clamped |= 32;\r\n\r\n        if (result) result[offset! + bufSize] = integerToChar.charCodeAt(clamped);\r\n        else resultStr += integerToChar.charAt(clamped);\r\n        bufSize++;\r\n      } while (num > 0);\r\n    }\r\n\r\n    if (result)\r\n      return bufSize;\r\n    else\r\n      return resultStr;\r\n  }\r\n\r\n}","namespace danfo.parsing.sourcemap {\r\n\r\n  export function writer() {\r\n    const numBuffer = [0, 0, 0, 0, 0, 0, 0, 0];\r\n    const cache: string[] = [];\r\n\r\n    const current: Mapping = {\r\n      generatedLine: 0,\r\n      generatedColumn: 0,\r\n      originalLine: 0,\r\n      originalColumn: 0,\r\n      originalFile: 0,\r\n      originalName: -1\r\n    };\r\n\r\n    let resultText = typeof Buffer === 'undefined' ? '' :\r\n      typeof Buffer.alloc === 'function' ? Buffer.alloc(16) :\r\n        new Buffer(16);\r\n    // resultText = '';\r\n\r\n    let resultTextLength = 0; \r\n\r\n    const result = {\r\n      write,\r\n      text\r\n    };\r\n\r\n    return result;\r\n\r\n    function text() {\r\n      return typeof resultText === 'string' ? resultText :\r\n        resultText.toString('ascii', 0, resultTextLength);\r\n    }\r\n\r\n    function write(mapping: Mapping): void {\r\n      if (mapping.generatedLine < current.generatedLine)\r\n        throw new Error('Cannot go back on generated lines: ' + mapping.generatedLine + ' < ' + current.generatedLine + '.');\r\n      \r\n      for (let i = 0; i < mapping.generatedLine - current.generatedLine; i++) {\r\n        if (typeof resultText === 'string')\r\n          resultText += ';';\r\n        else\r\n          appendResultTextByte(CharCodes.Semicolon);\r\n        \r\n        // new line resets column\r\n        current.generatedColumn = 0;\r\n      }\r\n\r\n      if (!endsWithCharCode(CharCodes.Semicolon)) {\r\n        if (typeof resultText === 'string')\r\n          resultText += ',';\r\n        else\r\n          appendResultTextByte(CharCodes.Comma);\r\n      }\r\n\r\n      if (typeof resultText !== 'string' && resultTextLength + 6 > resultText.byteLength)\r\n        growResultTextBuffer();\r\n\r\n      let numLen = 4;\r\n      numBuffer[0] = mapping.generatedColumn - current.generatedColumn;\r\n      numBuffer[1] = mapping.originalFile - current.originalFile;\r\n      numBuffer[2] = mapping.originalLine - current.originalLine;\r\n      numBuffer[3] = mapping.originalColumn - current.originalColumn;\r\n\r\n      if (mapping.originalName >= 0) {\r\n        numLen = 5;\r\n        numBuffer[4] = mapping.originalName - (\r\n          current.originalName >= 0 ? current.originalName :\r\n            -current.originalName - 1 // encoded as negative (zero is -1, 1 is -2 and so on)\r\n        );\r\n      }\r\n\r\n      if (typeof resultText === 'string') {\r\n        resultText += encodeVLQArray(numBuffer, 0, numLen);\r\n      }\r\n      else {\r\n        resultTextLength += encodeVLQArray(numBuffer, 0, numLen, resultText, resultTextLength);\r\n      }\r\n\r\n      current.generatedLine = mapping.generatedLine;\r\n      current.generatedColumn = mapping.generatedColumn;\r\n      current.originalFile = mapping.originalFile;\r\n      current.originalLine = mapping.originalLine;\r\n      current.originalColumn = mapping.originalColumn;\r\n\r\n      if (mapping.originalName >= 0)\r\n        current.originalName = mapping.originalName;\r\n      else if (current.originalName >= 0)\r\n        current.originalName = -current.originalName - 1;\r\n    }\r\n\r\n    function allocBuffer(size: number): Buffer {\r\n      return typeof Buffer.alloc === 'function' ? Buffer.alloc(size) :\r\n        new Buffer(size);\r\n    }\r\n\r\n    function appendResultTextByte(b: number): void {\r\n      if ((resultText as Buffer).byteLength === resultTextLength)\r\n        growResultTextBuffer();\r\n      (resultText as Buffer)[resultTextLength] = b;\r\n      resultTextLength++;\r\n    }\r\n\r\n    function growResultTextBuffer(): void {\r\n      const newBuf = allocBuffer((resultText as Buffer).byteLength * 2);\r\n      (resultText as Buffer).copy(newBuf, 0, 0, (resultText as Buffer).length);\r\n      resultText = newBuf;\r\n    }\r\n\r\n    function endsWithCharCode(cd: number): boolean {\r\n      if (typeof resultText === 'string')\r\n        return !!resultText.length && resultText.charCodeAt(resultText.length - 1) === cd;\r\n      else\r\n        return !!resultText.byteLength && resultText[resultTextLength - 1] === cd;\r\n    }\r\n  }\r\n}","namespace danfo {\r\n\r\n  export namespace parsing {\r\n    export declare function atob(base64Encoded: string): string;\r\n  }\r\n\r\n  if (typeof atob === 'function') {\r\n    parsing.atob = atob;\r\n  }\r\n  else if (typeof Buffer === 'function') {\r\n    if (typeof Buffer.from === 'function') {\r\n      parsing.atob = polyfillWithBufferFrom();\r\n    }\r\n    else {\r\n      parsing.atob = polyfillWithBuffer();\r\n    }\r\n  }\r\n  else {\r\n    parsing.atob = polyfillFull();\r\n  }\r\n\r\n  function polyfillWithBuffer() {\r\n    return atob;\r\n\r\n    function atob(base64Encoded: string): string {\r\n      return new Buffer(base64Encoded, 'base64').toString('binary');\r\n    }\r\n  }\r\n\r\n  function polyfillWithBufferFrom() {\r\n    return atob;\r\n\r\n    function atob(base64Encoded: string): string {\r\n      return Buffer.from(base64Encoded, 'base64').toString('binary');\r\n    }\r\n  }\r\n\r\n  function polyfillFull() {\r\n    const charToInt = createCharToInt();\r\n    const whitespaces = [CharCodes.Space, CharCodes.TAB, CharCodes.CR, CharCodes.LF];\r\n\r\n    return atob;\r\n    \r\n    function createCharToInt() {\r\n      const charToIntStr = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/';\r\n      const charToIntArray: number[] = [];\r\n      for (let i = 0; i < charToIntStr.length; i++) {\r\n        charToIntArray.push(charToIntStr.charCodeAt(i));\r\n      }\r\n\r\n      return charToIntArray;\r\n    }\r\n\r\n    function atob(base64Encoded: string): string {\r\n      let result = '';\r\n      let acc = 0;\r\n      let count = 0;\r\n      for (let i = 0; i < base64Encoded.length; i++) {\r\n        const ch = base64Encoded.charCodeAt(i);\r\n        const bits = charToInt.indexOf(ch);\r\n\r\n        // skip whitespace and equal signs\r\n        // (allow equal signs in the middle because this is a limited-use polyfill)\r\n        if (bits < 0) {\r\n          if (ch === CharCodes.Equal || whitespaces.indexOf(ch) >= 0) continue;\r\n          else throw new Error('Incorrect character ' + base64Encoded.charAt(i) + ' at position ' + i + '.');\r\n        }\r\n\r\n        acc <<= 6;\r\n        acc |= bits;\r\n\r\n        count++;\r\n\r\n        if (count === 3) {\r\n          result += String.fromCharCode((acc & 0xff0000) >> 16);\r\n          result += String.fromCharCode((acc & 0xff00) >> 8);\r\n          result += String.fromCharCode(acc & 0xff);\r\n          acc = 0;\r\n          count = 0;\r\n        }\r\n      }\r\n\r\n      if (count) {\r\n        if (count === 2) result += String.fromCharCode((acc & 0xff00) >> 8);\r\n        result += String.fromCharCode(acc & 0xff);\r\n      }\r\n\r\n      return result;\r\n    }\r\n\r\n  }\r\n}","namespace danfo.parsing {\n\n  var entities: { [entity: string]: number } | undefined;\n\n  export function decodeEntities(text: string): string {\n    return text.replace(/&((#((\\d+)|x([\\da-fA-F]+)))|(\\w+));/g, (match, _all, _number, _digits, decimal, hex, word) => {\n      if (decimal) {\n        return String.fromCharCode(parseInt(decimal, 10));\n      }\n      else if (hex) {\n        return String.fromCharCode(parseInt(hex, 16));\n      }\n      else {\n        if (!entities) entities = createEntitiesMap(entitiesCompressed);\n        const ch = entities[word];\n        // If this is not a valid entity, then just use `match` (replace it with itself, i.e. don't replace)\n        return typeof ch === 'number' ? String.fromCharCode(ch) : match;\n      }\n    });\n  }\n\n  function createEntitiesMap(array: (number | string | undefined)[]) {\n    var result: { [entity: string]: number } = {};\n    var val = array[0] as number - 1;\n    for (var i = 1; i < array.length; i++) {\n      var x = array[i];\n      if (typeof x === 'number') {\n        val += x;\n        continue;\n      }\n\n      val++;\n      if (x)\n        result[x] = val;\n    }\n    return result;\n  }\n\n  const entitiesCompressed = [\n    34, \"quot\", , , , \"amp\", \"apos\",\n    20, \"lt\", , \"gt\",\n    97, \"nbsp\", \"iexcl\", \"cent\", \"pound\", \"curren\", \"yen\", \"brvbar\", \"sect\", \"uml\", \"copy\", \"ordf\", \"laquo\", \"not\", \"shy\", \"reg\", \"macr\", \"deg\", \"plusmn\", \"sup2\", \"sup3\", \"acute\", \"micro\", \"para\", \"middot\", \"cedil\", \"sup1\", \"ordm\", \"raquo\", \"frac14\", \"frac12\", \"frac34\", \"iquest\", \"Agrave\", \"Aacute\", \"Acirc\", \"Atilde\", \"Auml\", \"Aring\", \"AElig\", \"Ccedil\", \"Egrave\", \"Eacute\", \"Ecirc\", \"Euml\", \"Igrave\", \"Iacute\", \"Icirc\", \"Iuml\", \"ETH\", \"Ntilde\", \"Ograve\", \"Oacute\", \"Ocirc\", \"Otilde\", \"Ouml\", \"times\", \"Oslash\", \"Ugrave\", \"Uacute\", \"Ucirc\", \"Uuml\", \"Yacute\", \"THORN\", \"szlig\", \"agrave\", \"aacute\", \"acirc\", \"atilde\", \"auml\", \"aring\", \"aelig\", \"ccedil\", \"egrave\", \"eacute\", \"ecirc\", \"euml\", \"igrave\", \"iacute\", \"icirc\", \"iuml\", \"eth\", \"ntilde\", \"ograve\", \"oacute\", \"ocirc\", \"otilde\", \"ouml\", \"divide\", \"oslash\", \"ugrave\", \"uacute\", \"ucirc\", \"uuml\", \"yacute\", \"thorn\", \"yuml\",\n    82, \"OElig\", \"oelig\",\n    12, \"Scaron\", \"scaron\",\n    22, \"Yuml\",\n    25, \"fnof\",\n    307, \"circ\",\n    21, \"tilde\",\n    180, \"Alpha\", \"Beta\", \"Gamma\", \"Delta\", \"Epsilon\", \"Zeta\", \"Eta\", \"Theta\", \"Iota\", \"Kappa\", \"Lambda\", \"Mu\", \"Nu\", \"Xi\", \"Omicron\", \"Pi\", \"Rho\", , \"Sigma\", \"Tau\", \"Upsilon\", \"Phi\", \"Chi\", \"Psi\", \"Omega\",\n    7, \"alpha\", \"beta\", \"gamma\", \"delta\", \"epsilon\", \"zeta\", \"eta\", \"theta\", \"iota\", \"kappa\", \"lambda\", \"mu\", \"nu\", \"xi\", \"omicron\", \"pi\", \"rho\", \"sigmaf\", \"sigma\", \"tau\", \"upsilon\", \"phi\", \"chi\", \"psi\", \"omega\",\n    7, \"thetasym\", \"upsih\", , , , \"piv\",\n    7211, \"ensp\", \"emsp\",\n    5, \"thinsp\", , , \"zwnj\", \"zwj\", \"lrm\", \"rlm\", , , , \"ndash\", \"mdash\", , , , \"lsquo\", \"rsquo\", \"sbquo\", , \"ldquo\", \"rdquo\", \"bdquo\", , \"dagger\", \"Dagger\", \"bull\", , , , \"hellip\",\n    9, \"permil\", , \"prime\", \"Prime\",\n    5, \"lsaquo\", \"rsaquo\", , , , \"oline\",\n    5, \"frasl\",\n    103, \"euro\",\n    100, \"image\",\n    6, \"weierp\", , , , \"real\",\n    5, \"trade\",\n    18, \"alefsym\",\n    90, \"larr\", \"uarr\", \"rarr\", \"darr\", \"harr\",\n    32, \"crarr\",\n    26, \"lArr\", \"uArr\", \"rArr\", \"dArr\", \"hArr\",\n    43, \"forall\", , \"part\", \"exist\", , \"empty\", , \"nabla\", \"isin\", \"notin\", , \"ni\", , , , \"prod\", , \"sum\", \"minus\",\n    4, \"lowast\", , , \"radic\", , , \"prop\", \"infin\", , \"ang\",\n    6, \"and\", \"or\", \"cap\", \"cup\", \"int\",\n    8, \"there4\",\n    7, \"sim\",\n    8, \"cong\", , , \"asymp\",\n    23, \"ne\", \"equiv\", , , \"le\", \"ge\",\n    28, \"sub\", \"sup\", \"nsub\", , \"sube\", \"supe\",\n    13, \"oplus\", , \"otimes\",\n    13, \"perp\",\n    31, \"sdot\",\n    66, \"lceil\", \"rceil\", \"lfloor\", \"rfloor\",\n    29, \"lang\", \"rang\",\n    671, \"loz\",\n    149, \"spades\", , , \"clubs\", , \"hearts\", \"diams\"];\n\n}","namespace danfo.parsing {\r\n\r\n  export declare namespace lineMap {\r\n    type Output = {\r\n      getLineAndCharacter(pos: number): { ln: number, ch: number } | null\r\n    }\r\n  }\r\n\r\n  export function lineMap(text: string): lineMap.Output {\r\n    const textCopy = String(text);\r\n\r\n    return {\r\n      getLineAndCharacter\r\n    };\r\n\r\n    function getLineAndCharacter(pos: number): { ln: number, ch: number } | null {\r\n      if (pos < 0 || pos > textCopy.length)\r\n        return null;\r\n\r\n      let lineStartPos = 0;\r\n      let line = 1;\r\n      let currentPos = 0;\r\n      const lineBreakRegExp = /\\r\\n|\\n|\\r/gm;\r\n      while (true) {\r\n        const nextLineBreak = lineBreakRegExp.exec(textCopy);\r\n        if (!nextLineBreak)\r\n          return {\r\n            ln: line,\r\n            ch: pos - lineStartPos  + 1\r\n          };\r\n\r\n        if (nextLineBreak.index >= pos) {\r\n          return {\r\n            ln: line,\r\n            ch: pos - lineStartPos + 1\r\n          };\r\n        }\r\n\r\n        line++;\r\n        lineStartPos = nextLineBreak.index + nextLineBreak[0].length;\r\n      }\r\n    }\r\n  }\r\n\r\n}","namespace danfo.parsing {\n\n  export declare namespace parseHTML {\n\n    type ReferenceOrContent = {\n      tag: 'script' | 'style' | 'link';\n      type: 'css' | 'typescript' | 'javascript' | 'tsconfig' | string;\n\n      start: number;\n      length: number;\n      originalLeadLength: number;\n      originalTrailLength: number;\n      lead: string | null;\n      trail: string | null;\n\n      reference?: string;\n      content?: string;\n    }\n  }\n\n  export function parseHTML(html: string): parseHTML.ReferenceOrContent[] {\n\n    let elements: parseHTML.ReferenceOrContent[] = [];\n\n    let pos = 0;\n    while (pos < html.length - 7) { // 7 chars: < STY LE >\n\n      pos = html.indexOf('<', pos);\n\n      let firstLetter = html.charCodeAt(pos + 1); // next after <\n      if (firstLetter === CharCodes.Exclamation) {\n        if (html.charCodeAt(pos + 2) !== CharCodes.Dash) {\n          pos = html.indexOf('>', pos + 2);\n          if (pos < 0) break; // no angle close? finish\n          pos++; // skip angle close\n          continue;\n        }\n        else if (html.charCodeAt(pos + 3) === CharCodes.Dash) {\n          // fully formed HTML comment <!-- bla bla -->\n          pos = html.indexOf('-->', pos + 3);\n\n          if (pos < 0) break; // no close comment? finish\n          pos += 3; // skip close comment\n          continue;\n        }\n        else {\n          // partial HTML comment <!- bla bla ->\n          pos = html.indexOf('->', pos + 2);\n\n          if (pos < 0) break; // no close comment? finish\n          pos += 2; // skip close comment\n          continue;\n        }\n      }\n      else if (firstLetter === CharCodes.Slash) {\n        pos = html.indexOf('>', pos + 2);\n        if (pos < 0) break;\n        pos++;\n        continue;\n      }\n      else if (isAtoZ(firstLetter)) {\n        let elementEndPos = html.indexOf('>', pos + 3);\n        if (elementEndPos < 0) break;\n        elementEndPos++;\n\n        if (firstLetter === CharCodes.UPPER_L || firstLetter === CharCodes.lower_l) {\n          if (isElementNameAt(html, pos + 1, 'link')) {\n            processLinkElement(elementEndPos);\n            continue;\n          }\n        }\n        else if (firstLetter === CharCodes.UPPER_S || firstLetter === CharCodes.lower_s) {\n          if (isElementNameAt(html, pos + 1, 'script')) {\n            processScriptElement(elementEndPos);\n            continue;\n          }\n          else if (isElementNameAt(html, pos + 1, 'style')) {\n            processStyleElement(elementEndPos);\n            continue;\n          }\n        }\n\n        pos = elementEndPos;\n      }\n      else {\n        pos++;\n      }\n\n    }\n\n    return elements;\n\n    function enclosedInMatchedQuotes(start: number, end: number) {\n      const firstChar = html.charCodeAt(start);\n      if (firstChar === CharCodes.Quote || firstChar === CharCodes.Apostrophe) {\n        const lastChar = html.charCodeAt(end - 1);\n        if (lastChar === firstChar && end > start + 1) {\n          return true;\n        }\n      }\n\n      return false;\n    }\n\n    function processLinkElement(elementEndPos: number) {\n      let seek = pos + 6 /* < LINK */;\n      let lastRelPos = 0, lastRelEnd = 0, lastRelAttributePos = 0, lastRelAttributeEnd = 0;\n      let lastHrefPos = 0, lastHrefEnd = 0, lastHrefAttributePos = 0, lastHrefAttributeEnd = 0;\n\n      while (true) {\n        seek = findAttributeStart(html, seek, elementEndPos);\n        if (!seek)\n          break;\n\n        if (isAttributeAndEqualsAt(html, seek, 'rel')) {\n          const attributeEnd = findAttributeEnd(html, seek + 4 /* REL= */, elementEndPos - 1);\n          if (attributeEnd < 0) {\n            pos = elementEndPos;\n            break;\n          }\n\n          let relPos = seek + 4 /* REL= */;\n          let relEnd = attributeEnd;\n\n          if (enclosedInMatchedQuotes(relPos, relEnd)) {\n            relPos++;\n            relEnd--;\n          }\n\n          lastRelPos = relPos;\n          lastRelEnd = relEnd;\n          lastRelAttributePos = seek;\n          lastRelAttributeEnd = attributeEnd;\n\n          seek = attributeEnd;\n        }\n        else if (isAttributeAndEqualsAt(html, seek, 'href')) {\n          const attributeEnd = findAttributeEnd(html, seek + 5 /* HREF= */, elementEndPos - 1);\n          if (attributeEnd < 0) {\n            pos = elementEndPos;\n            break;\n          }\n\n          let hrefPos = seek + 5 /* HREF= */;\n          let hrefEnd = attributeEnd;\n          if (enclosedInMatchedQuotes(hrefPos, hrefEnd)) {\n            hrefPos++;\n            hrefEnd--;\n          }\n\n          lastHrefPos = hrefPos;\n          lastHrefEnd = hrefEnd;\n          lastHrefAttributePos = seek;\n          lastHrefAttributeEnd = attributeEnd;\n\n          seek = attributeEnd;\n        }\n        else {\n          const attributeEnd = findAttributeEnd(html, seek + 1 /* at least one letter attribute */, elementEndPos - 1);\n          if (attributeEnd < 0) {\n            pos = elementEndPos;\n            break;\n          }\n\n          seek = attributeEnd;\n        }\n      }\n\n      if (!lastRelPos || !lastHrefPos) return;\n\n      const rel = decodeEntities(html.slice(lastRelPos, lastRelEnd));\n      if (!/stylesheet/i.test(rel)) return;\n\n      const href = decodeEntities(html.slice(lastHrefPos, lastHrefEnd));\n\n      elements.push({\n        tag: 'link',\n        type: 'css',\n        start: pos, length: elementEndPos - pos,\n        reference: href,\n        originalLeadLength: elementEndPos - pos,\n        originalTrailLength: 0,\n        lead:\n          '<style' + sliceElementWithAttributeHoles(\n            html, pos + 5 /* < LINK */, elementEndPos,\n            lastRelAttributePos, lastRelAttributeEnd,\n            lastHrefAttributePos, lastHrefAttributeEnd),\n        trail: '</' + 'style' + '>'\n      });\n\n      pos = elementEndPos;\n    }\n\n    function processStyleElement(elementEndPos: number) {\n      let seekClose = elementEndPos;\n      let closeElementPos = 0;\n      let closeElementEnd = 0;\n      while (seekClose < html.length) {\n        closeElementPos = html.indexOf('</', seekClose); // may not be STYLE element end\n        if (closeElementPos < 0) break; // incomplete element, ignore\n\n        if (!isElementNameAt(html, closeElementPos + 2, 'style')) { // not STYLE element close - keep seeking\n          seekClose = closeElementPos + 2;\n          continue;\n        }\n\n        closeElementEnd = html.indexOf('>', closeElementPos + 7 /* </ STY LE */);\n        if (closeElementEnd > 0)\n          closeElementEnd++;\n        break;\n      }\n\n      if (closeElementEnd > 0) {\n        elements.push({\n          tag: 'style',\n          type: 'css',\n          start: pos, length: closeElementEnd - pos,\n          content: html.slice(elementEndPos, closeElementPos),\n          originalLeadLength: elementEndPos - pos,\n          originalTrailLength: closeElementEnd - closeElementPos,\n          lead: html.slice(pos, elementEndPos), trail: html.slice(closeElementPos, closeElementEnd)\n        });\n\n        pos = closeElementEnd;\n      }\n      else {\n        // STYLE not closed, finish\n        pos = html.length;\n      }\n    }\n\n    function processScriptElement(elementEndPos: number) {\n\n      let seek = pos + 7 /* < SCR IPT */;\n      let lastSrcPos = 0, lastSrcEnd = 0, lastSrcAttributePos = 0, lastSrcAttributeEnd = 0;\n      let lastTypePos = 0, lastTypeEnd = 0, lastTypeAttributePos = 0, lastTypeAttributeEnd = 0;\n\n      while (true) {\n        seek = findAttributeStart(html, seek, elementEndPos);\n        if (!seek)\n          break;\n\n        if (isAttributeAndEqualsAt(html, seek, 'src')) {\n          const attributeEnd = findAttributeEnd(html, seek + 4 /* SRC= */, elementEndPos - 1);\n          if (attributeEnd < 0) {\n            seek = elementEndPos;\n            break;\n          }\n\n          let srcPos = seek + 4 /* SRC= */;\n          let srcEnd = attributeEnd;\n          if (enclosedInMatchedQuotes(srcPos, srcEnd)) {\n            srcPos++;\n            srcEnd--;\n          }\n\n          lastSrcPos = srcPos;\n          lastSrcEnd = srcEnd;\n          lastSrcAttributePos = seek;\n          lastSrcAttributeEnd = attributeEnd;\n\n          seek = attributeEnd;\n        }\n        else if (isAttributeAndEqualsAt(html, seek, 'type')) {\n          const attributeEnd = findAttributeEnd(html, seek + 5 /* TYPE= */, elementEndPos - 1);\n          if (attributeEnd < 0) {\n            seek = elementEndPos;\n            break;\n          }\n\n          let typePos = seek + 5 /* TYPE= */;\n          let typeEnd = attributeEnd;\n          if (enclosedInMatchedQuotes(typePos, typeEnd)) {\n            typePos++;\n            typeEnd--;\n          }\n\n          lastTypePos = typePos;\n          lastTypeEnd = typeEnd;\n          lastTypeAttributePos = seek;\n          lastTypeAttributeEnd = attributeEnd;\n\n          seek = attributeEnd;\n        }\n        else {\n          const attributeEnd = findAttributeEnd(html, seek + 1 /* one letter attribute at least */, elementEndPos - 1);\n          if (attributeEnd < 0) {\n            seek = elementEndPos;\n            break;\n          }\n\n          seek = attributeEnd;\n        }\n      }\n\n      let src = lastSrcPos ? decodeEntities(html.slice(lastSrcPos, lastSrcEnd)) : null;\n      let type = lastTypePos ? decodeEntities(html.slice(lastTypePos, lastTypeEnd)) : null;\n\n\n      let seekClose = elementEndPos;\n      let closeElementPos = 0;\n      let closeElementEnd = 0;\n      while (seekClose < html.length) {\n        closeElementPos = html.indexOf('</', seekClose); // may not be SCRIPT element end\n        if (closeElementPos < 0) break; // incomplete element, ignore\n\n        if (!isElementNameAt(html, closeElementPos + 2, 'script')) { // not SCRIPT element close - keep seeking\n          seekClose = closeElementPos + 2;\n          continue;\n        }\n\n        closeElementEnd = html.indexOf('>', closeElementPos + 8 /* </ SCR IPT */);\n        if (closeElementEnd > 0)\n          closeElementEnd++;\n        break;\n      }\n\n      if (closeElementEnd > 0) {\n        if (type) {\n          if (parseHTML.isJavascriptType(type)) {\n            type = 'javascript';\n          }\n          else if (parseHTML.isTypeScriptType(type)) {\n            type = 'typescript';\n          }\n          else if (parseHTML.isTsconfigType(type)) {\n            type = 'tsconfig';\n          }\n        }\n        else {\n          if (src && parseHTML.hasTypeScriptFileExtension(src))\n            type = 'typescript';\n          else if (src && parseHTML.isTsconfigJsonFileName(src))\n            type = 'tsconfig';\n          else\n            type = 'javascript';\n        }\n\n        let lead = sliceElementWithAttributeHoles(\n          html, pos, elementEndPos,\n          lastSrcAttributePos, lastSrcAttributeEnd,\n          // exclude type attribute for typescript (it's translated into javascript)\n          type === 'typescript' || type === 'tsconfig' ? lastTypeAttributePos : 0,\n          type === 'typescript' || type === 'tsconfig' ? lastTypeAttributeEnd : 0);\n\n        if (src) {\n          elements.push({\n            tag: 'script',\n            type,\n            start: pos, length: closeElementEnd - pos,\n            reference: src,\n            originalLeadLength: elementEndPos - pos,\n            originalTrailLength: closeElementEnd - closeElementPos,\n            lead,\n            trail: html.slice(closeElementPos, closeElementEnd)\n          });\n        }\n        else {\n          elements.push({\n            tag: 'script',\n            type,\n            start: pos, length: closeElementEnd - pos,\n            content: html.slice(elementEndPos, closeElementPos),\n            originalLeadLength: elementEndPos - pos,\n            originalTrailLength: closeElementEnd - closeElementPos,\n            lead,\n            trail: html.slice(closeElementPos, closeElementEnd)\n          });\n        }\n\n        pos = closeElementEnd;\n      }\n      else {\n        // STYLE not closed, finish\n        pos = html.length;\n      }\n    }\n\n  }\n\n  function findAttributeEnd(html: string, pos: number, end: number): number {\n    if (end === pos) return -1;\n\n    let firstChar = html.charCodeAt(pos);\n\n    for (let i = pos + 1; i < end; i++) {\n      let ch = html.charCodeAt(i);\n      if (firstChar === CharCodes.Quote) {\n        if (ch === CharCodes.Quote) return i + 1;\n      }\n      else if (firstChar === CharCodes.Apostrophe) {\n        if (ch === CharCodes.Apostrophe) return i + 1;\n      }\n      else if (isWhitespace(ch)) {\n        return i;\n      }\n    }\n\n    return end;\n  }\n\n  function isWordAt(text: string, pos: number, wordLowercase: string): boolean {\n    for (let i = 0; i < wordLowercase.length; i++) {\n      let ch = text.charCodeAt(pos + i);\n      let expectChLower = wordLowercase.charCodeAt(i);\n      if (ch !== expectChLower && ch + CharCodes.MakeLower !== expectChLower) return false;\n    }\n\n    return true;\n  }\n\n  function isElementNameAt(html: string, pos: number, elementName: string): boolean {\n    if (!isWordAt(html, pos, elementName)) return false;\n    let afterWordCh = html.charCodeAt(pos + elementName.length);\n    if (isWhitespace(afterWordCh) || afterWordCh === CharCodes.AngleClose)\n      return true;\n    else\n      return false;\n  }\n\n  function isAttributeAndEqualsAt(html: string, pos: number, attrName: string) {\n    if (!isWordAt(html, pos, attrName)) return false;\n    let afterWordCh = html.charCodeAt(pos + attrName.length);\n    if (afterWordCh === CharCodes.Equal)\n      return true;\n    else\n      return false;\n  }\n\n  function isWhitespace(ch: number) {\n    return ch === CharCodes.Space ||\n      ch === CharCodes.CR ||\n      ch === CharCodes.LF ||\n      ch === CharCodes.TAB;\n  }\n\n  function isAtoZ(ch: number) {\n    return (ch >= CharCodes.UPPER_A && ch <= CharCodes.UPPER_Z) ||\n      (ch >= CharCodes.lower_a && ch <= CharCodes.lower_z);\n  }\n\n  function findAttributeStart(html: string, pos: number, end: number): number {\n    for (let i = pos; i < end; i++) {\n      let ch = html.charCodeAt(i);\n      while (isWhitespace(ch)) {\n        i++;\n        if (i >= end) return 0;\n        ch = html.charCodeAt(i);\n      }\n\n      if (isAtoZ(ch))\n        return i;\n    }\n\n    return 0;\n  }\n\n  function findAnyOf(text: string, pos: number, end: number, setOfChars: string) {\n    for (let i = pos; i < end; i++) {\n      let ch = text.charCodeAt(i);\n      for (let j = 0; j < setOfChars.length; j++) {\n        let match = setOfChars.charCodeAt(j);\n        if (ch === match)\n          return i;\n      }\n    }\n    return -1;\n  }\n\n  function sliceElementWithAttributeHoles(\n    html: string, pos: number, end: number,\n    attr1Pos: number, attr1End: number,\n    attr2Pos: number, attr2End: number) {\n\n    if (attr1Pos) {\n      while (attr1Pos > pos && isWhitespace(html.charCodeAt(attr1Pos - 1))) {\n        attr1Pos--;\n      }\n    }\n\n    if (attr2Pos) {\n      while (attr2Pos > pos && isWhitespace(html.charCodeAt(attr2Pos - 1))) {\n        attr2Pos--;\n      }\n    }\n\n    if (attr1Pos) {\n      if (attr2Pos) {\n        return attr1Pos < attr2Pos ?\n          html.slice(pos, attr1Pos) + html.slice(attr1End, attr2Pos) + html.slice(attr2End, end) :\n          html.slice(pos, attr2Pos) + html.slice(attr2End, attr1Pos) + html.slice(attr1End, end);\n      }\n      else {\n        return html.slice(pos, attr1Pos) + html.slice(attr1End, end);\n      }\n    }\n    else if (attr2Pos) {\n      return html.slice(pos, attr2Pos) + html.slice(attr2End, end);\n    }\n    else {\n      return html.slice(pos, end);\n    }\n  }\n\n  export namespace parseHTML {\n\n    const regex_javascriptType = /^\\s*(javascript|jscript|js|jsx)\\s*$/i;\n    const regex_typescriptType = /^\\s*(typescript|ts|tsx)\\s*$/i;\n    const regex_typescriptFileExtension = /\\.(ts|tsx)$/i;\n    const regex_tsconfigJsonFileName = /(^|\\\\|\\/)tsconfig\\.json$/i;\n    const regex_tsconfigJsonType = /^\\s*(tsconfig)\\s*$/i;\n\n    export function isJavascriptType(type: string) {\n      return regex_javascriptType.test(type);\n    }\n\n    export function isTypeScriptType(type: string) {\n      return regex_typescriptType.test(type);\n    }\n\n    export function hasTypeScriptFileExtension(file: string) {\n      return regex_typescriptFileExtension.test(file);\n    }\n\n    export function isTsconfigJsonFileName(file: string) {\n      return regex_tsconfigJsonFileName.test(file);\n    }\n\n    export function isTsconfigType(type: string) {\n      return regex_tsconfigJsonType.test(type);\n    }\n  }\n}","namespace danfo {\r\n  export declare function wscript(): void;\r\n\r\n  export namespace wscript {\r\n\r\n    for (const k in danfo.wscript) {\r\n      if (k in bootWScript) continue;\r\n\r\n      (bootWScript as any)[k] = (danfo.wscript as any)[k];\r\n    }\r\n    (danfo.wscript as any) = bootWScript;\r\n    (wscript as any) = bootWScript;\r\n\r\n\r\n    function bootWScript() {\r\n      wscript.fromConsole = /cscript(\\.exe)$/i.test(WScript.FullName);\r\n\r\n      const nodePath = findNode();\r\n      if (!nodePath) {\r\n        WScript.Echo(\r\n          'Node.JS not found\\n\\n' +\r\n          'WScript.Name ' + WScript.Name + '\\n' +\r\n          'WScript.FullName ' + WScript.FullName + '\\n' +\r\n          'WScript.ScriptName ' + WScript.ScriptName + '\\n' +\r\n          'WScript.ScriptFullName ' + WScript.ScriptFullName);\r\n        WScript.Quit(-1);\r\n        return;\r\n      }\r\n\r\n      if (wscript.fromConsole)\r\n        WScript.Echo('WScript: Restarting with \"' + nodePath + '\" \"' + WScript.ScriptFullName + '\"');\r\n\r\n      shell.runAndForget('\"' + nodePath + '\" \"' + WScript.ScriptFullName + '\"');\r\n    }\r\n\r\n  }\r\n\r\n\r\n  export namespace wscript {\r\n\r\n    export var fromConsole = false;\r\n\r\n  }\r\n\r\n}","namespace danfo.wscript {\r\n\r\n  export function findNode() {\r\n    const simpleWhereProbes = shell.run('cmd /c where node').replace(/^\\s*/, '').replace(/\\s*$/, '').split(/(\\r\\n)|\\r|\\n/g);\r\n    if (simpleWhereProbes.length && simpleWhereProbes[0])\r\n      return simpleWhereProbes[0];\r\n    \r\n    return null;\r\n  }\r\n\r\n}","namespace danfo.wscript.shell {\r\n\r\n  export function run(cmdline: string): string {\r\n    const wShell = WScript.CreateObject('WScript.Shell') as WshShell;\r\n    const process = wShell.Exec(cmdline);\r\n    while (process.Status === WshShell.WshStatus.WshRunning) {\r\n      WScript.Sleep(50);\r\n    }\r\n\r\n    const output = process.StdOut.ReadAll();\r\n    const err = process.StdErr.ReadAll();\r\n\r\n    return output ? (err ? output + '\\n' + err : output) : err;\r\n  }\r\n\r\n  export function runAndForget(cmdline: string): void {\r\n    const wShell = WScript.CreateObject('WScript.Shell') as WshShell;\r\n    const process = wShell.Run(cmdline, 10, false);\r\n  }\r\n}","namespace danfo {\n  export const versionStr = '0.3.0';\n}","if (typeof module !== 'undefined' && module &&\n  typeof require !== 'undefined' && require &&\n  typeof process !== 'undefined' && process) {\n\n  module.exports = danfo;\n\n  const isMainModule =\n    require.main ? require.main === module :\n      process.mainModule ? process.mainModule === module :\n        void 0;\n  \n  // node-like environment\n\n  if (isMainModule) {\n    global.danfo = danfo;\n    danfo.node();\n  }\n  else {\n    const mainModuleFilename = (require.main || process.mainModule)?.filename;\n    if (mainModuleFilename && /[\\/\\\\]bin[\\/\\\\]danfo(\\.[a-z]+)?$/.test(mainModuleFilename)) {\n      // started from bin/danfo, good enough\n      global.danfo = danfo;\n      danfo.node();\n    }\n    else {\n      // just run as a module, not a command-line tool\n    }\n  }\n}\nelse if (typeof WScript !== 'undefined') {\n    // TODO: if not main script, just ignore...\n    danfo.wscript();\n}\nelse if (typeof window !== 'undefined' && window) {\n  // run in browser main thread\n  // TODO: check why danfo is loaded in browser\n  window.danfo = danfo;\n  danfo.browser.startMain();\n}\nelse if (typeof self !== 'undefined' && self) {\n  // run in browser worker\n  // TODO: check why danfo is loaded in browser\n  self.danfo = danfo;\n  danfo.browser.startWorker();\n}","// @ts-check\r\n\r\n/** @type {{\r\n *  build: {\r\n *    code: {\r\n *      defineAmd():  ((moduleName: string, imports: string[], moduleBody: Function) => any)\r\n *      & { amd: boolean, require(moduleName: string): any }\r\n *    }\r\n *  }\r\n * }} */\r\nvar danfo;\r\n\r\n// @ts-ignore\r\nif (!danfo) danfo = { build: { code: {} } }; else if (!danfo.build) danfo.build = { code: {} }; else if (!danfo.build.code) danfo.build.code = {};\r\ndanfo.build.code.defineAmd = function defineAmd() {\r\n\r\n  /** @typedef {{ moduleName?: string, imports?: string[], exports?: any, moduleBody?: Function, initialized?: boolean }} ModuleInfo */\r\n\r\n  /** @type {ModuleInfo[]} */\r\n  const modules = [];\r\n\r\n  /** @type {{ [moduleName: string]: ModuleInfo }} */\r\n  const moduleByName = {};\r\n\r\n  /**\r\n   * @param {string=} moduleName\r\n   * @param {string[]=} imports\r\n   * @param {Function=} moduleBody\r\n   */\r\n  function define(moduleName, imports, moduleBody) {\r\n    if (!moduleBody) {\r\n      if (!imports) {\r\n        moduleBody = /** @type {*} */(moduleName);\r\n        moduleName = void 0;\r\n      }\r\n      else {\r\n        moduleBody = /** @type {*} */(imports);\r\n        imports = /** @type {*} */(moduleName);\r\n        moduleName = void 0;\r\n      }\r\n    }\r\n\r\n    const mod = {\r\n      moduleName,\r\n      imports,\r\n      moduleBody\r\n    };\r\n    if (typeof moduleName === 'string')\r\n      modules.push(moduleByName[moduleName] = mod);\r\n    else\r\n      modules.push(mod);\r\n  }\r\n  define.amd = true;\r\n\r\n  /**\r\n   * @param {ModuleInfo} modInfo \r\n   */\r\n  function define_loadModule(modInfo) {\r\n    modInfo.exports = {};\r\n    const args = [];\r\n    if (modInfo.imports) {\r\n      for (let i = 0; i < modInfo.imports.length; i++) {\r\n        const depModuleName = modInfo.imports[i];\r\n        if (depModuleName === 'require')\r\n          args.push(module_require);\r\n        else if (depModuleName === 'exports')\r\n          args.push(modInfo.exports);\r\n        else {\r\n          const depModDesc = moduleByName[depModuleName];\r\n          args.push(depModDesc && (\r\n            depModDesc.initialized ?\r\n              depModDesc.exports :\r\n              define_loadModule(depModDesc)\r\n          ));\r\n        }\r\n      }\r\n    }\r\n    modInfo.initialized = true;\r\n\r\n    const result = /** @type {Function} */(modInfo.moduleBody).apply(\r\n      // @ts-ignore\r\n      this,\r\n      args);\r\n\r\n    if (result) {\r\n      for (let k in result) {\r\n        modInfo.exports[k] = result[k];\r\n      }\r\n      modInfo.exports = result;\r\n    }\r\n\r\n    return modInfo.exports;\r\n\r\n    /**\r\n     * @param {string} moduleName\r\n     */\r\n    function module_require(moduleName) {\r\n      // TODO: relative path calc\r\n      return global_require(moduleName);\r\n    }\r\n  }\r\n\r\n  /**\r\n   * @param {string} moduleName\r\n   */\r\n  function global_require(moduleName) {\r\n\r\n    const modDesc = moduleByName && moduleByName[moduleName];\r\n\r\n    if (!modDesc) {\r\n      if (typeof require === 'function')\r\n        return require(moduleName);\r\n      else\r\n        throw new Error('Module not found: ' + moduleName + '.');\r\n    }\r\n\r\n    if (modDesc.initialized) return modDesc.exports;\r\n    return define_loadModule(modDesc)\r\n  }\r\n\r\n  define.require = global_require;\r\n\r\n  return define;\r\n}"]}