
            var __assign = (this && this.__assign) || function () {
                __assign = Object.assign || function(t) {
                    for (var s, i = 1, n = arguments.length; i < n; i++) {
                        s = arguments[i];
                        for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
                            t[p] = s[p];
                    }
                    return t;
                };
                return __assign.apply(this, arguments);
            };

            var __spreadArray = (this && this.__spreadArray) || function (to, from, pack) {
                if (pack || arguments.length === 2) for (var i = 0, l = from.length, ar; i < l; i++) {
                    if (ar || !(i in from)) {
                        if (!ar) ar = Array.prototype.slice.call(from, 0, i);
                        ar[i] = from[i];
                    }
                }
                return to.concat(ar || Array.prototype.slice.call(from));
            };

            var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
                function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
                return new (P || (P = Promise))(function (resolve, reject) {
                    function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
                    function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
                    function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
                    step((generator = generator.apply(thisArg, _arguments || [])).next());
                });
            };

            var __generator = (this && this.__generator) || function (thisArg, body) {
                var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;
                return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() { return this; }), g;
                function verb(n) { return function (v) { return step([n, v]); }; }
                function step(op) {
                    if (f) throw new TypeError("Generator is already executing.");
                    while (g && (g = 0, op[0] && (_ = 0)), _) try {
                        if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;
                        if (y = 0, t) op = [op[0] & 2, t.value];
                        switch (op[0]) {
                            case 0: case 1: t = op; break;
                            case 4: _.label++; return { value: op[1], done: false };
                            case 5: _.label++; y = op[1]; op = [0]; continue;
                            case 7: op = _.ops.pop(); _.trys.pop(); continue;
                            default:
                                if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }
                                if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }
                                if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }
                                if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }
                                if (t[2]) _.ops.pop();
                                _.trys.pop(); continue;
                        }
                        op = body.call(thisArg, _);
                    } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }
                    if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };
                }
            };

var danfo;
(function (danfo) {
    var browser;
    (function (browser) {
        function startMain() {
        }
        browser.startMain = startMain;
    })(browser = danfo.browser || (danfo.browser = {}));
})(danfo || (danfo = {}));
var danfo;
(function (danfo) {
    var browser;
    (function (browser) {
        function startWorker() {
        }
        browser.startWorker = startWorker;
    })(browser = danfo.browser || (danfo.browser = {}));
})(danfo || (danfo = {}));
var danfo;
(function (danfo) {
    var build;
    (function (build) {
        var bundle;
        (function (bundle) {
            function codeBundler(options) {
                var fileSystem = options.fileSystem;
                var codeBuilder = build.code.codeBuilder({
                    fileSystem: fileSystem,
                    precachedFixedSource: options.precachedFixedSource
                });
                return {
                    build: runBuild
                };
                function runBuild(inputs) {
                    var _a;
                    var resolvedProjectDirWithSlash = inputs.resolvedProjectDir.charCodeAt(inputs.resolvedProjectDir.length - 1) === 47 /* CharCodes.Slash */ ? inputs.resolvedProjectDir : inputs.resolvedProjectDir + '/';
                    var outputFile = inputs.outputFile;
                    var buildResults = codeBuilder.build({
                        resolvedProjectDir: inputs.resolvedProjectDir,
                        sources: inputs.sources,
                        handleSettings: handleSettings
                    });
                    if (!outputFile) {
                        if (inputs.sources.length === 1)
                            outputFile = resolvedProjectDirWithSlash + 'dist/' + build.getBaseName(inputs.sources[0].resolvedPath);
                        else
                            outputFile = resolvedProjectDirWithSlash + 'dist/index.js';
                    }
                    else {
                        outputFile = fileSystem.resolvePath(resolvedProjectDirWithSlash, outputFile);
                        if ((_a = fileSystem.stat(outputFile)) === null || _a === void 0 ? void 0 : _a.isDirectory)
                            outputFile = outputFile + '/index.js';
                    }
                    var concatenated = danfo.parsing.sourcemap.concatenate({ fileName: build.getBaseName(outputFile) }, buildResults.emits.map(function (em) {
                        return __assign(__assign({}, em), { resolvePath: function (path) { return path.replace(/\\/g, ''); } });
                    }));
                    return {
                        outputFile: outputFile,
                        output: typeof concatenated === 'string' ? concatenated : concatenated.output,
                        sourcemap: typeof concatenated === 'string' ? void 0 : concatenated.sourcemap,
                        errors: buildResults.errors,
                        imports: buildResults.imports
                    };
                    function handleSettings(settings) {
                        if (typeof outputFile === 'undefined') {
                            if (settings.out || settings.outFile) {
                                outputFile = settings.out || settings.outFile;
                            }
                            else if (settings.outDir) {
                                outputFile = fileSystem.resolvePath(resolvedProjectDirWithSlash, settings.outDir + '/index.js');
                            }
                        }
                        if (inputs.outputDir && !settings.outDir) {
                            return __assign(__assign({}, settings), { outFile: void 0, out: void 0, outDir: inputs.outputDir });
                        }
                        else {
                            return settings;
                        }
                    }
                }
            }
            bundle.codeBundler = codeBundler;
            (function (codeBundler) {
                var regex_typeScriptFileExtension = /\.(ts|tsx)$/i;
                var regex_jsonFileExtension = /\.json$/i;
                function hasTypeScriptFileExtension(file) {
                    return regex_typeScriptFileExtension.test(file);
                }
                codeBundler.hasTypeScriptFileExtension = hasTypeScriptFileExtension;
                function hasJsonFileExtension(file) {
                    return regex_jsonFileExtension.test(file);
                }
                codeBundler.hasJsonFileExtension = hasJsonFileExtension;
            })(codeBundler = bundle.codeBundler || (bundle.codeBundler = {}));
        })(bundle = build.bundle || (build.bundle = {}));
    })(build = danfo.build || (danfo.build = {}));
})(danfo || (danfo = {}));
var danfo;
(function (danfo) {
    var build;
    (function (build) {
        var code;
        (function (code) {
            function convertAmd(_a) {
                var ts = _a.ts, program = _a.program, checker = _a.checker, generateModuleName = _a.generateModuleName, resolveModuleName = _a.resolveModuleName;
                var typeChecker = checker || program.getTypeChecker();
                var defines = [];
                var modulesByName = {};
                var modules = [];
                return {
                    transform: transform,
                    defines: defines,
                    modules: modules
                };
                function transform(context) {
                    return transformSourceFile;
                    function transformSourceFile(sourceFileNode) {
                        var factory = context.factory;
                        var updatedStatements;
                        for (var i_1 = 0; i_1 < sourceFileNode.statements.length; i_1++) {
                            var statement = sourceFileNode.statements[i_1];
                            if (ts.isExpressionStatement(statement)) {
                                var amd = code.isAmdDefineCall(statement.expression, ts, typeChecker);
                                if (amd) {
                                    defines.push({
                                        sourceFile: sourceFileNode,
                                        amd: amd
                                    });
                                    var moduleName = generateModuleName(sourceFileNode.fileName);
                                    var mod = modulesByName[moduleName];
                                    if (!mod) {
                                        mod = modulesByName[moduleName] = { moduleName: moduleName };
                                        modules.push(mod);
                                    }
                                    statement = transformRequireCalls(statement, amd, moduleName) || statement;
                                    var exportedBy = (mod.exportedBy || (mod.exportedBy = []));
                                    if (exportedBy.indexOf(sourceFileNode.fileName) <= 0)
                                        exportedBy.push(sourceFileNode.fileName);
                                    var importsArrayArgument = amd.node.arguments[0];
                                    var updatedImportsArrayArgument = !importsArrayArgument || !ts.isArrayLiteralExpression(importsArrayArgument) ?
                                        void 0 :
                                        factory.updateArrayLiteralExpression(importsArrayArgument, importsArrayArgument.elements.map(function (el) {
                                            var moduleName = code.getPossibleStringLiteralValues(el, ts, typeChecker);
                                            if (typeof moduleName === 'string' && moduleName !== 'require' && moduleName !== 'exports') {
                                                var resolvedModuleName = resolveModuleName(sourceFileNode.fileName, moduleName);
                                                if (resolvedModuleName) {
                                                    var mod_1 = modulesByName[resolvedModuleName];
                                                    if (!mod_1) {
                                                        mod_1 = modulesByName[resolvedModuleName] = { moduleName: resolvedModuleName };
                                                        modules.push(mod_1);
                                                    }
                                                    var importedBy = (mod_1.importedBy || (mod_1.importedBy = []));
                                                    if (importedBy.indexOf(sourceFileNode.fileName) <= 0)
                                                        importedBy.push(sourceFileNode.fileName);
                                                }
                                                if (resolvedModuleName && resolvedModuleName !== moduleName)
                                                    return el;
                                            }
                                            return el;
                                        }));
                                    statement = factory.updateExpressionStatement(statement, factory.updateCallExpression(amd.node, amd.node.expression, amd.node.typeArguments, __spreadArray([
                                        factory.createStringLiteral(moduleName),
                                        updatedImportsArrayArgument || importsArrayArgument
                                    ], amd.node.arguments.slice(1), true)));
                                }
                            }
                            if (statement === sourceFileNode.statements[i_1]) {
                                statement = transformRequireCalls(statement) || statement;
                            }
                            if (statement !== sourceFileNode.statements[i_1]) {
                                if (!updatedStatements)
                                    updatedStatements = [];
                                updatedStatements[i_1] = statement;
                            }
                        }
                        if (updatedStatements) {
                            for (var i = 0; i < sourceFileNode.statements.length; i++) {
                                if (!updatedStatements[i])
                                    updatedStatements[i] = sourceFileNode.statements[i];
                            }
                            return factory.updateSourceFile(sourceFileNode, updatedStatements);
                        }
                        else {
                            return sourceFileNode;
                        }
                        function transformRequireCalls(node, amd, moduleName) {
                            var amdDefineImportSymbols;
                            var result = ts.visitEachChild(node, transformNode, context);
                            return result;
                            function transformNode(node) {
                                if (isRequireCall(node)) {
                                    var moduleName_1 = code.getPossibleStringLiteralValues(node.arguments[0], ts, typeChecker);
                                    if (typeof moduleName_1 === 'string') {
                                        var resolvedModuleName = resolveModuleName(sourceFileNode.fileName, moduleName_1);
                                        if (resolvedModuleName) {
                                            var mod = modulesByName[resolvedModuleName];
                                            if (!mod) {
                                                mod = modulesByName[resolvedModuleName] = { moduleName: resolvedModuleName };
                                                modules.push(mod);
                                            }
                                            var importedBy = (mod.importedBy || (mod.importedBy = []));
                                            if (importedBy.indexOf(sourceFileNode.fileName) <= 0)
                                                importedBy.push(sourceFileNode.fileName);
                                        }
                                        if (resolvedModuleName && resolvedModuleName !== moduleName_1)
                                            return factory.updateCallExpression(node, node.expression, node.typeArguments, [factory.createStringLiteral(resolvedModuleName)]);
                                    }
                                }
                                return ts.visitEachChild(node, transformNode, context);
                            }
                            function isRequireCall(node) {
                                if (ts.isCallExpression(node)
                                    && node.arguments.length === 1) {
                                    if (code.isGlobalName(node.expression, 'require', ts, typeChecker)) {
                                        return true;
                                    }
                                    else if (amd &&
                                        ts.isIdentifier(node.expression)
                                        && code.getPossibleNameString(node.expression, ts) === 'require') {
                                        var requireSymbol = typeChecker.getSymbolAtLocation(node.expression);
                                        if (!requireSymbol)
                                            return true; // undefined means global
                                        if (!amdDefineImportSymbols) {
                                            amdDefineImportSymbols = [];
                                            var signatures = typeChecker.getSignaturesOfType(typeChecker.getTypeAtLocation(amd.moduleBodyArgument), ts.SignatureKind.Call);
                                            for (var _i = 0, signatures_1 = signatures; _i < signatures_1.length; _i++) {
                                                var sig = signatures_1[_i];
                                                amdDefineImportSymbols = sig.getParameters();
                                            }
                                        }
                                        if (amdDefineImportSymbols.indexOf(requireSymbol) >= 0)
                                            return true;
                                    }
                                }
                                return false;
                            }
                        }
                    }
                }
            }
            code.convertAmd = convertAmd;
        })(code = build.code || (build.code = {}));
    })(build = danfo.build || (danfo.build = {}));
})(danfo || (danfo = {}));
var danfo;
(function (danfo) {
    var build;
    (function (build) {
        var code;
        (function (code) {
            function hoistHelpers(options) {
                var emitHelpers = [];
                return {
                    transform: transform,
                    emitHelpers: emitHelpers
                };
                function transform(context) {
                    return transformSourceFile;
                    function transformSourceFile(sourceFileNode) {
                        var fileNodeEmitHelpers = options.ts.getEmitHelpers(sourceFileNode);
                        if (fileNodeEmitHelpers) {
                            // removing will affect this same array instance,
                            // so iterate through a copy instead
                            fileNodeEmitHelpers = fileNodeEmitHelpers.slice();
                            for (var _i = 0, fileNodeEmitHelpers_1 = fileNodeEmitHelpers; _i < fileNodeEmitHelpers_1.length; _i++) {
                                var h = fileNodeEmitHelpers_1[_i];
                                emitHelpers.push({ fileName: sourceFileNode.fileName, emitHelper: h });
                                options.ts.removeEmitHelper(sourceFileNode, h);
                            }
                        }
                        return sourceFileNode;
                    }
                }
            }
            code.hoistHelpers = hoistHelpers;
        })(code = build.code || (build.code = {}));
    })(build = danfo.build || (danfo.build = {}));
})(danfo || (danfo = {}));
var danfo;
(function (danfo) {
    var build;
    (function (build) {
        var code;
        (function (code) {
            var keywords;
            (function (keywords) {
                /**
                 * A custom transformer supposed to manage the use of what's ES3 keywords but allowed in ES5.
                 */
                function transformKeywords(context, es3Keywords, ts) {
                    return transformSourceFile;
                    function transformSourceFile(sourceFileNode) {
                        var factory = context.factory;
                        var transformed = ts.visitEachChild(sourceFileNode, visitNodeReplaceES3Keywords, context);
                        if (!transformed) {
                            return sourceFileNode;
                        }
                        else {
                            return transformed;
                        }
                        function visitNodeReplaceES3Keywords(node) {
                            var nestedReplacements = ts.visitEachChild(node, visitNodeReplaceES3Keywords, context);
                            node = nestedReplacements || node;
                            if (ts.isPropertyAccessExpression(node) && ts.isIdentifier(node.name) && es3Keywords.indexOf(node.name.text) >= 0) {
                                var replacement = factory.createElementAccessExpression(node.expression, factory.createStringLiteral(node.name.text));
                                var mappedReplacement = ts.setTextRange(replacement, node);
                                return mappedReplacement;
                            }
                            else if (ts.isPropertyAccessExpression(node) && ts.isIdentifier(node.name) && es3Keywords.indexOf(node.name.text) >= 0) {
                                var replacement = factory.createPropertyAssignment(node.name.text, node.expression);
                                var mappedReplacement = ts.setTextRange(replacement, node);
                                return mappedReplacement;
                            }
                            return nestedReplacements;
                        }
                    }
                }
                keywords.transformKeywords = transformKeywords;
            })(keywords = code.keywords || (code.keywords = {}));
        })(code = build.code || (build.code = {}));
    })(build = danfo.build || (danfo.build = {}));
})(danfo || (danfo = {}));
var danfo;
(function (danfo) {
    var build;
    (function (build) {
        var code;
        (function (code) {
            var es3Keywords = [
                'default', 'delete', 'import', 'export', 'class',
                'break', 'for', 'new', 'true', 'with', 'continue', 'function',
                'null', 'typeof', 'else', 'if', 'return', 'var', 'false', 'in', 'this', 'while'
            ];
            function codeBuilder(options) {
                var fileSystem = options.fileSystem, precachedFixedSource = options.precachedFixedSource, debugState = options.debugState;
                var ts = code.importTypeScript();
                if (debugState)
                    debugState.ts = ts;
                // these variables would be re-populated on incremental rebuilds
                var inputs = {
                    sources: [],
                    resolvedProjectDir: '.'
                };
                var scriptInputs = [];
                if (debugState)
                    debugState.scriptInputs = scriptInputs;
                var baseSettings = createDefaultSettings();
                var settings = baseSettings;
                if (debugState)
                    debugState.settings = settings;
                var configSourcedFiles = [];
                if (debugState)
                    debugState.configSourcedFiles = configSourcedFiles;
                // memoizing results for repetitive requests during build
                // (will be re-populated before a rebuild starts)
                var cachedState = {};
                var fileCache = {};
                var cache = code.createKeyCache(cachedState, null);
                var buildState;
                var builder = {
                    build: triggerBuild
                };
                return builder;
                function resolveJoinPathInProject(path1, path2) {
                    var result = fileSystem.resolvePath(inputs.resolvedProjectDir, path1);
                    if (path2)
                        result = fileSystem.resolvePath(result, path2);
                    return result;
                }
                function getProjectRelativeFileName(path1, path2) {
                    var resolvedPath = resolveJoinPathInProject(path1, path2);
                    var relative = fileSystem.getRelativePath(inputs.resolvedProjectDir, resolvedPath);
                    return relative;
                }
                function promoteCaches(cachedState) {
                    var deleteEntryKeys = [];
                    for (var k in fileCache) {
                        var entry = fileCache[k];
                        if (entry && typeof entry.unusedCount === 'number') {
                            entry.unusedCount++;
                            if (entry.unusedCount > 3) {
                                deleteEntryKeys.push(k);
                            }
                        }
                    }
                    for (var _i = 0, deleteEntryKeys_1 = deleteEntryKeys; _i < deleteEntryKeys_1.length; _i++) {
                        var k_1 = deleteEntryKeys_1[_i];
                        delete fileCache[k_1];
                    }
                    return {};
                }
                function initializeBuildState() {
                    // serves as both ts.LanguageServiceHost and ts.ModuleResolutionHost
                    var langHost = {
                        getCompilationSettings: hostGetCompilationSettings,
                        getScriptFileNames: hostGetScriptFileNames,
                        getScriptVersion: hostGetScriptVersion,
                        getScriptSnapshot: hostGetScriptSnapshot,
                        getCurrentDirectory: hostGetCurrentDirectory,
                        getDirectories: hostGetDirectories,
                        getDefaultLibFileName: hostGetDefaultLibFileName,
                        fileExists: hostFileExists,
                        readFile: hostReadFile,
                        getCanonicalFileName: hostGetCanonicalFileName,
                        useCaseSensitiveFileNames: function () { return true; }
                    };
                    if (debugState)
                        debugState.languageServiceHost = langHost;
                    // two functions overridden, to cache lib.d.ts more aggressively (in tests)
                    var baseDocumentRegistry = ts.createDocumentRegistry(true /* useCaseSensitiveFileNames */, inputs.resolvedProjectDir /* currentDirectory */);
                    var documentRegistry = __assign(__assign({}, baseDocumentRegistry), { acquireDocument: cachedAcquireDocument, acquireDocumentWithKey: cachedAcquireDocumentWithKey });
                    if (debugState)
                        debugState.documentRegistry = documentRegistry;
                    var langService = ts.createLanguageService(langHost, documentRegistry, false /* syntaxOnly */);
                    if (debugState)
                        debugState.languageService = langService;
                    // TODO: resolve from actual TypeScript used (require.resolve?)
                    var tsLibPath = fileSystem.resolvePath(inputs.resolvedProjectDir, 'node_modules/typescript/lib');
                    if (debugState)
                        debugState.tsLibPath = tsLibPath;
                    var moduleResolutionCache = ts.createModuleResolutionCache(inputs.resolvedProjectDir, function (path) { return getProjectRelativeFileName(path); });
                    if (debugState)
                        debugState.moduleResolutionCache = moduleResolutionCache;
                    return {
                        langHost: langHost,
                        documentRegistry: documentRegistry,
                        langService: langService,
                        tsLibPath: tsLibPath,
                        moduleResolutionCache: moduleResolutionCache
                    };
                    function cachedAcquireDocument(fileName, compilationSettings, scriptSnapshot, version, scriptKind) {
                        if (precachedFixedSource) {
                            var resolvedFileName = fileSystem.resolvePath(inputs.resolvedProjectDir, fileName);
                            var entry = precachedFixedSource(resolvedFileName);
                            if (entry && entry.snapshot === scriptSnapshot)
                                return entry.source;
                        }
                        return baseDocumentRegistry.acquireDocument(fileName, compilationSettings, scriptSnapshot, version, scriptKind);
                    }
                    function cachedAcquireDocumentWithKey(fileName, path, compilationSettings, key, scriptSnapshot, version, scriptKind) {
                        if (precachedFixedSource) {
                            var resolvedFileName = fileSystem.resolvePath(inputs.resolvedProjectDir, fileName);
                            var entry = precachedFixedSource(resolvedFileName);
                            if (entry && entry.snapshot === scriptSnapshot)
                                return entry.source;
                        }
                        return baseDocumentRegistry.acquireDocumentWithKey(fileName, path, compilationSettings, key, scriptSnapshot, version, scriptKind);
                    }
                }
                function triggerBuild(newInputs) {
                    var _a;
                    if (!buildState)
                        buildState = initializeBuildState();
                    // TODO: promote relevant caches
                    cachedState = promoteCaches(cachedState);
                    inputs = newInputs;
                    cache = code.createKeyCache(cachedState, null);
                    scriptInputs = populateScriptFileNamesFromInputs();
                    if (debugState)
                        debugState.scriptInputs = scriptInputs;
                    // read and combine any tsconfig.json used as input
                    var tsCmdline = populateSettingsIncludingInputs(scriptInputs);
                    settings = (tsCmdline === null || tsCmdline === void 0 ? void 0 : tsCmdline.options) || baseSettings;
                    // override/manipulate settings, especially in case tsconfig is read from file system
                    if (typeof newInputs.handleSettings === 'function') {
                        var updatedSettings = newInputs.handleSettings(settings);
                        if (updatedSettings)
                            settings = updatedSettings;
                    }
                    if (debugState)
                        debugState.settings = settings;
                    if (tsCmdline === null || tsCmdline === void 0 ? void 0 : tsCmdline.fileNames) {
                        configSourcedFiles = tsCmdline.fileNames;
                        if (debugState)
                            debugState.configSourcedFiles = configSourcedFiles;
                    }
                    // TODO: validate if this is needed anyway?
                    buildState.moduleResolutionCache = ts.createModuleResolutionCache(newInputs.resolvedProjectDir, function (path) {
                        return getProjectRelativeFileName(path);
                    });
                    if (debugState)
                        debugState.moduleResolutionCache = buildState.moduleResolutionCache;
                    // These will be populated from inputs and outputs, including match one to another.
                    // That matching is important when multiple outputs need to be injected to corresponding places in HTML.
                    var bySource = {};
                    var byTarget = {};
                    var fileEntryList = [];
                    var program = buildState.langService.getProgram();
                    if (debugState)
                        debugState.program = program;
                    if (!program) {
                        // TODO: how can it get here???
                        return {
                            emits: [],
                            errors: [],
                            imports: []
                        };
                    }
                    // by now there may be more sources resolved by TypeScript itself
                    // (imports, triple-slash and whatnot)
                    populateSourcesFromProgram();
                    var hoistHelpersTransformer = code.hoistHelpers({ ts: ts });
                    var detectAmdDefinesTransformer = code.convertAmd({
                        ts: ts,
                        program: program,
                        generateModuleName: function (sourceFileName) { return getProjectRelativeFileName(sourceFileName); },
                        resolveModuleName: function (sourceFileName, moduleName) {
                            if (moduleName.charCodeAt(0) === 46 /* CharCodes.Dot */
                                || moduleName.charCodeAt(0) === 47 /* CharCodes.Slash */
                                || moduleName.charCodeAt(0) === 92 /* CharCodes.Backslash */)
                                return fileSystem.resolvePath(inputs.resolvedProjectDir, sourceFileName + '/../' + moduleName);
                            else if (moduleName.charCodeAt(0) === 126 /* CharCodes.Tilda */)
                                return fileSystem.resolvePath(inputs.resolvedProjectDir, moduleName);
                            else
                                return moduleName;
                        }
                    });
                    var codeBuilderResult = runEmit();
                    var externalImportList = [];
                    for (var _i = 0, _b = detectAmdDefinesTransformer.modules; _i < _b.length; _i++) {
                        var mod = _b[_i];
                        if (mod.importedBy && !mod.exportedBy) {
                            // TODO: resolve external import, if succeeded, process in a separate, relaxed language service
                            externalImportList.push({
                                reference: mod.moduleName
                            });
                        }
                    }
                    var buildResult = __assign(__assign({}, codeBuilderResult), { emits: __spreadArray([], codeBuilderResult.emits, true), imports: externalImportList });
                    if ((_a = detectAmdDefinesTransformer.defines) === null || _a === void 0 ? void 0 : _a.length) {
                        var preloadRootSources = [];
                        var preloadRootSourceNames = [];
                        for (var _c = 0, _d = newInputs.sources; _c < _d.length; _c++) {
                            var inp = _d[_c];
                            // TODO: handle directory (load index.js/ts)
                            for (var _e = 0, _f = detectAmdDefinesTransformer.defines; _e < _f.length; _e++) {
                                var defn = _f[_e];
                                if (defn.sourceFile.fileName === inp.resolvedPath) {
                                    var projRelativePath = getProjectRelativeFileName(inp.resolvedPath);
                                    if (preloadRootSourceNames.indexOf(projRelativePath) < 0) {
                                        preloadRootSourceNames.push(projRelativePath);
                                        preloadRootSources.push('define.require(' + JSON.stringify(projRelativePath) + ');');
                                    }
                                }
                            }
                        }
                        if (!code.defineAmdWrappedText)
                            code.defineAmdWrappedText = 'var define = (function() { return defineAmd();\n' + code.defineAmd + '\n})()';
                        var defineFunctionEmit = generateHelperEmitWithPerLineMaps({
                            name: '__define.js',
                            text: code.defineAmdWrappedText
                        });
                        buildResult.emits.unshift(defineFunctionEmit);
                        if (preloadRootSources.length) {
                            var moduleLoad = generateHelperEmitWithPerLineMaps({
                                name: '__moduleLoad.js',
                                text: preloadRootSources.join('\n')
                            });
                            moduleLoad.injectAfter = true;
                            buildResult.emits.push(moduleLoad);
                        }
                    }
                    return buildResult;
                    function populateScriptFileNamesFromInputs() {
                        var encounteredTsconfigs;
                        var allSources = [];
                        for (var _i = 0, _a = inputs.sources; _i < _a.length; _i++) {
                            var src = _a[_i];
                            if (src.type === 'html' || src.type === 'css' || !src.type)
                                continue;
                            if (src.type === 'tsconfig') {
                                (encounteredTsconfigs || (encounteredTsconfigs = [])).push(src);
                            }
                            else {
                                allSources.push(src);
                            }
                        }
                        if (encounteredTsconfigs && encounteredTsconfigs.length === 1)
                            allSources.unshift(encounteredTsconfigs[0]);
                        return allSources;
                        // TODO: do we need any special handling for packages?
                        // (especially when in node_modules?)
                        // function populateFromPackage(packageJsonPath: string) {
                        // }
                    }
                    function populateSourcesFromProgram() {
                        for (var _i = 0, _a = program.getSourceFiles(); _i < _a.length; _i++) {
                            var sourceFile = _a[_i];
                            var resolvedFileName = resolveJoinPathInProject(sourceFile.fileName);
                            var relativeFileName = getProjectRelativeFileName(resolvedFileName);
                            var entry = bySource[relativeFileName];
                            if (entry) {
                                if (!entry.source) {
                                    entry.source = {
                                        resolvedFileName: resolvedFileName,
                                        node: sourceFile
                                    };
                                }
                                entry.source.node = sourceFile;
                            }
                            else {
                                entry = {
                                    source: {
                                        resolvedFileName: resolvedFileName,
                                        node: sourceFile
                                    }
                                };
                                bySource[relativeFileName] = entry;
                                fileEntryList.push(entry);
                            }
                        }
                    }
                    function runEmit() {
                        var emitResult = program.emit(void 0 /* targetSourceFile */, onFileEmit, void 0 /* cancellationToken */, false /* emitOnlyDtsFiles */, {
                            before: [],
                            after: [
                                function (context) { return code.keywords.transformKeywords(context, es3Keywords, ts); },
                                hoistHelpersTransformer.transform,
                                detectAmdDefinesTransformer.transform
                            ],
                            afterDeclarations: []
                        } /* customTransformers */);
                        var errors = [];
                        for (var _i = 0, fileEntryList_1 = fileEntryList; _i < fileEntryList_1.length; _i++) {
                            var emit = fileEntryList_1[_i];
                            if (emit.source && emit.target) {
                                if (!/\bnode_modules\b/.test(emit.source.resolvedFileName)) {
                                    addDiagnosticErrors(program.getSyntacticDiagnostics(emit.source.node));
                                    addDiagnosticErrors(program.getSemanticDiagnostics(emit.source.node));
                                }
                            }
                        }
                        addDiagnosticErrors(program.getGlobalDiagnostics());
                        addDiagnosticErrors(program.getOptionsDiagnostics());
                        addDiagnosticErrors(emitResult.diagnostics);
                        // if (emitResult.emitSkipped) {
                        //   errors.push({
                        //     code: 'TS',
                        //     message: 'Emit was skipped by TypeScript build.'
                        //   });
                        // }
                        var emits = fileEntryList.map(function (entry) {
                            var _a;
                            if (entry.target) {
                                return {
                                    resolvedSourcePath: entry.source ? entry.source.resolvedFileName : (_a = entry.target) === null || _a === void 0 ? void 0 : _a.resolvedFileName,
                                    sourcemap: entry.target.sourcemap,
                                    typings: entry.target.typings,
                                    output: entry.target.output
                                };
                            }
                            else if (entry.source) {
                                // TODO: adjust this simple heuristic
                                // A lot of .d.ts typings files are actually taking part in a typical build process
                                // -- including standard lib.d.ts and huge react, node typings and such.
                                // These are not relevant and should not be included.
                                if (!/node_modules/.test(entry.source.resolvedFileName)) {
                                    var text = entry.source.node.getFullText();
                                    if (typeof text === 'string') {
                                        return generatePlainEmitWithEmptyFile(getProjectRelativeFileName(entry.source.resolvedFileName), text);
                                    }
                                }
                            }
                        }).filter(function (entry) { return entry; });
                        var namedHelpers = {};
                        var injectHelpers = processInjectedHelpers();
                        if (injectHelpers)
                            emits = __spreadArray(__spreadArray([], injectHelpers, true), emits, true);
                        return { emits: emits, errors: errors };
                        function processInjectedHelpers() {
                            var injectHelpers = [];
                            hoistHelpersTransformer.emitHelpers.sort(function (h1, h2) {
                                return (h1.emitHelper.priority || 0) - (h2.emitHelper.priority || 0) // sort by priority, then by name
                                    || (h1.emitHelper.name > h2.emitHelper.name ? +1 : h1.emitHelper.name < h2.emitHelper.name ? -1 : 0);
                            });
                            var emitHelpersOrdered = __spreadArray([], hoistHelpersTransformer.emitHelpers, true).sort(function (h1, h2) { return h1.fileName > h2.fileName ? +1 : h1.fileName < h2.fileName ? -1 : 0; });
                            for (var _i = 0, emitHelpersOrdered_1 = emitHelpersOrdered; _i < emitHelpersOrdered_1.length; _i++) {
                                var h = emitHelpersOrdered_1[_i];
                                if (namedHelpers[h.emitHelper.name])
                                    continue;
                                namedHelpers[h.emitHelper.name] = true;
                                injectHelpers.push(generateHelperEmitWithPerLineMaps(h.emitHelper));
                            }
                            return injectHelpers;
                        }
                        function addDiagnosticErrors(diagList) {
                            if (diagList) {
                                for (var _i = 0, diagList_1 = diagList; _i < diagList_1.length; _i++) {
                                    var diag = diagList_1[_i];
                                    if (diag.file && /\bnode_modules\b/i.test(diag.file.fileName))
                                        continue;
                                    errors.push(createErrorFromDiagnostic(diag));
                                }
                            }
                        }
                        function createErrorFromDiagnostic(diag) {
                            var err = {
                                resolvedSourcePath: diag.file ? diag.file.fileName : void 0,
                                code: 'TS' + String(diag.code),
                                message: typeof diag.messageText === 'string' ? diag.messageText : diag.messageText.messageText,
                                typescriptDetails: diag,
                                format: formatDiagnostic
                            };
                            return err;
                            function formatDiagnostic(overrideBaseDir) {
                                return danfo.node.formatBuildError(err, {
                                    typescriptForFormatting: ts,
                                    projRoot: overrideBaseDir ? fileSystem.resolvePath(inputs.resolvedProjectDir, overrideBaseDir) : inputs.resolvedProjectDir,
                                    fileSystem: fileSystem
                                });
                            }
                        }
                    }
                    /**
                     * Callback invoked by TypeScript on every file emitted.
                     * Note an important parameter here is `sourceFiles`, allowing to map an emitted output back to the original source file.
                     *
                     * It's usually 1 file, can be multiple when TypeScript's own bundling is in use (--outFile tsconfig parameter)
                     */
                    function onFileEmit(fileName, data, writeByteOrderMark, onError, sourceFiles) {
                        var resolvedFileName = resolveJoinPathInProject(inputs.resolvedProjectDir, fileName);
                        var relativeFileName = getProjectRelativeFileName(resolvedFileName);
                        var isTypings = codeBuilder.isTypingsFilename(resolvedFileName);
                        var isSourcemap = codeBuilder.isSourcemapFilename(resolvedFileName);
                        var isJavaScript = codeBuilder.hasJavascriptFileExtension(resolvedFileName);
                        if (!isTypings && !isSourcemap && !isJavaScript) {
                            if (sourceFiles) {
                                // TODO: that may be something intended?
                            }
                            else {
                                // TODO: that is likely junk or cache files
                            }
                            return;
                        }
                        var entry = byTarget[relativeFileName];
                        if (!entry) {
                            // find possible source file for this emit
                            if (sourceFiles) {
                                for (var _i = 0, sourceFiles_1 = sourceFiles; _i < sourceFiles_1.length; _i++) {
                                    var sourceFileEntry = sourceFiles_1[_i];
                                    var resolvedSourceFileName = resolveJoinPathInProject(inputs.resolvedProjectDir, sourceFileEntry.fileName);
                                    var relativeSourceFileName = getProjectRelativeFileName(resolvedSourceFileName);
                                    entry = bySource[relativeSourceFileName];
                                    // known source found
                                    if (entry)
                                        break;
                                }
                                if (!entry) {
                                    // source found, but not known, let's add it
                                    var useFirstSource = sourceFiles[0];
                                    if (useFirstSource) {
                                        var resolvedSourceFileName = resolveJoinPathInProject(inputs.resolvedProjectDir, useFirstSource.fileName);
                                        entry = {
                                            source: {
                                                resolvedFileName: resolvedSourceFileName,
                                                node: useFirstSource
                                            }
                                        };
                                        fileEntryList.push(entry);
                                    }
                                }
                            }
                            if (!entry) {
                                // source not found: this has to be an emit without original source
                                entry = {
                                    target: {
                                        resolvedFileName: resolvedFileName
                                    }
                                };
                                fileEntryList.push(entry);
                            }
                            byTarget[relativeFileName] = entry;
                        }
                        if (!entry.target) {
                            entry.target = {
                                resolvedFileName: resolvedFileName
                            };
                        }
                        if (isTypings)
                            entry.target.typings = { fileName: resolvedFileName, content: data };
                        else if (isSourcemap)
                            entry.target.sourcemap = { fileName: resolvedFileName, content: data };
                        else
                            entry.target.output = data;
                    }
                }
                function createDefaultSettings() {
                    var settings = ts.getDefaultCompilerOptions();
                    settings.jsx = ts.JsxEmit.React;
                    settings.checkJs = true;
                    settings.allowJs = true;
                    settings.sourceMap = true;
                    settings.inlineSources = true;
                    settings.module = ts.ModuleKind.AMD;
                    settings.moduleResolution = ts.ModuleResolutionKind.Node10;
                    settings.declaration = true;
                    settings.newLine = ts.NewLineKind.LineFeed;
                    settings.target = ts.ScriptTarget.ES5;
                    settings.skipDefaultLibCheck = true;
                    settings.resolveJsonModule = true;
                    // settings.lib = (settings.lib || []);
                    // // 'dom.iterable'
                    // // 'scripthost'
                    // // 'dom', 'webworker'
                    // for (const lib of ['esnext']) {
                    //   if (settings.lib.indexOf(lib) < 0)
                    //     settings.lib.push(lib);
                    // }
                    // settings.incremental = true;
                    // settings.composite = true;
                    // settings.tsBuildInfoFile = projectDir + '/.cache.tsbuildinfo';
                    settings.strict = true;
                    settings.outDir = inputs.resolvedProjectDir + '/dist';
                    return settings;
                }
                function populateSettingsIncludingInputs(sources) {
                    var result;
                    var _loop_1 = function (src) {
                        if (src.type === 'tsconfig') {
                            var cfgDir_1 = resolveJoinPathInProject(src.resolvedPath, '..');
                            var resolvedNormalizedPath_1 = getProjectRelativeFileName(src.resolvedPath);
                            var configJson = ts.readJsonConfigFile(resolvedNormalizedPath_1, function (filePath) { return fileSystem.readFile(filePath === resolvedNormalizedPath_1 ? src.resolvedPath : filePath); });
                            var host = {
                                useCaseSensitiveFileNames: true, // TODO: rely on underlying OS?
                                readDirectory: function () {
                                    var args = [];
                                    for (var _i = 0; _i < arguments.length; _i++) {
                                        args[_i] = arguments[_i];
                                    }
                                    return readDirectory.apply(void 0, __spreadArray([inputs.resolvedProjectDir, fileSystem], args, false));
                                },
                                fileExists: function (filePath) {
                                    var ex = !!fileSystem.stat(filePath === resolvedNormalizedPath_1 ?
                                        src.resolvedPath :
                                        fileSystem.resolvePath(cfgDir_1, filePath));
                                    return ex;
                                },
                                readFile: function (filePath) {
                                    var data = fileSystem.readFile(filePath === resolvedNormalizedPath_1 ?
                                        src.resolvedPath :
                                        fileSystem.resolvePath(cfgDir_1, filePath));
                                    return data;
                                }
                                // TODO: trace?(s: string): void
                            };
                            var parsedConfigJson = ts.parseJsonSourceFileConfigFileContent(configJson, host, cfgDir_1, result && result.options || baseSettings, src.resolvedPath);
                            // make all file paths absolute
                            if (parsedConfigJson.fileNames) {
                                for (var i = 0; i < parsedConfigJson.fileNames.length; i++) {
                                    parsedConfigJson.fileNames[i] = fileSystem.resolvePath(cfgDir_1, parsedConfigJson.fileNames[i]);
                                }
                            }
                            parsedConfigJson.fileNames = joinArrays(result === null || result === void 0 ? void 0 : result.fileNames, parsedConfigJson.fileNames);
                            parsedConfigJson.projectReferences = joinArrays(result === null || result === void 0 ? void 0 : result.projectReferences, parsedConfigJson.projectReferences);
                            // TODO: parsedConfigJson.wildcardDirectories
                            result = parsedConfigJson;
                        }
                    };
                    for (var _i = 0, sources_1 = sources; _i < sources_1.length; _i++) {
                        var src = sources_1[_i];
                        _loop_1(src);
                    }
                    return result;
                    function joinArrays(array1, array2) {
                        if (!array1)
                            return array2;
                        else if (!array2)
                            return array1;
                        else
                            return array1.concat(array2);
                    }
                }
                function getFileStatDirect(resolvedFileName) {
                    var stat = fileSystem.stat(resolvedFileName);
                    if (!stat || stat.isDirectory) {
                        var defaultLib = hostGetDefaultLibFileName(settings);
                        var parentDirPath = resolveJoinPathInProject(resolvedFileName, '..');
                        if (parentDirPath === defaultLib
                            || parentDirPath === resolveJoinPathInProject(defaultLib, '..')
                            || parentDirPath.toLowerCase() === defaultLib.toLowerCase()
                            || parentDirPath.toLowerCase() === resolveJoinPathInProject(defaultLib, '..').toLowerCase()) {
                            var libFileName = build.getBaseName(resolvedFileName);
                            var redirectToStandardLibPath = ts.resolveDefaultLibFromOfficial(libFileName);
                            if (redirectToStandardLibPath) {
                                stat = fileSystem.stat(redirectToStandardLibPath);
                            }
                        }
                    }
                    return stat;
                }
                function getFileContentDirect(resolvedFileName) {
                    var content = fileSystem.readFile(resolvedFileName);
                    if (typeof content !== 'string') {
                        var defaultLib = hostGetDefaultLibFileName(settings);
                        var parentDirPath = resolveJoinPathInProject(resolvedFileName, '..');
                        if (parentDirPath === defaultLib
                            || parentDirPath === resolveJoinPathInProject(defaultLib, '..')
                            || parentDirPath.toLowerCase() === defaultLib.toLowerCase()
                            || parentDirPath.toLowerCase() === resolveJoinPathInProject(defaultLib, '..').toLowerCase()) {
                            var libFileName = build.getBaseName(resolvedFileName);
                            var redirectToStandardLibPath = ts.resolveDefaultLibFromOfficial(libFileName);
                            if (redirectToStandardLibPath)
                                content = fileSystem.readFile(redirectToStandardLibPath);
                        }
                    }
                    return typeof content === 'string' ? content : null;
                }
                function getScriptSnapshotDirect(resolvedFileName) {
                    if (typeof precachedFixedSource === 'function') {
                        var entry = precachedFixedSource(resolvedFileName);
                        if (entry)
                            return entry.snapshot;
                    }
                    var fileContent = getFileContentDirect(resolvedFileName);
                    if (typeof fileContent !== 'string') {
                        var defaultLib = hostGetDefaultLibFileName(settings);
                        var parentDirPath = resolveJoinPathInProject(resolvedFileName, '..');
                        if (parentDirPath === defaultLib
                            || parentDirPath === resolveJoinPathInProject(defaultLib, '..')) {
                            var libFileName = build.getBaseName(resolvedFileName);
                            var redirectToStandardLibPath = ts.resolveDefaultLibFromOfficial(libFileName);
                            if (redirectToStandardLibPath) {
                                fileContent = getFileContentDirect(redirectToStandardLibPath);
                            }
                        }
                        return null;
                    }
                    return createScriptSnapshot(resolvedFileName, fileContent);
                }
                function getCachedFileEntry(resolvedFileName) {
                    var entry = cache.cachedOrPopulate({
                        cacheField: 'cachedFileEntries',
                        key: resolvedFileName,
                        populate: function () {
                            var _a, _b;
                            var stat = getFileStatDirect(resolvedFileName);
                            if (!stat) {
                                return fileCache[resolvedFileName] = {
                                    unusedCount: 0,
                                    version: 'missing'
                                };
                            }
                            var oldEntry = fileCache[resolvedFileName];
                            if (oldEntry && typeof oldEntry.unusedCount === 'number') {
                                if (((_a = oldEntry.stat) === null || _a === void 0 ? void 0 : _a.length) === (stat === null || stat === void 0 ? void 0 : stat.length) && ((_b = oldEntry.stat) === null || _b === void 0 ? void 0 : _b.timestamp) === (stat === null || stat === void 0 ? void 0 : stat.timestamp)) {
                                    oldEntry.unusedCount = 0;
                                    return oldEntry;
                                }
                            }
                            var content = getFileContentDirect(resolvedFileName) || undefined;
                            if (oldEntry && oldEntry.content === content) {
                                // timestamp changed, but content remained - retain everything
                                oldEntry.stat = stat;
                                oldEntry.unusedCount = 0;
                                return oldEntry;
                            }
                            var version = deriveFileVersionFromStat(stat);
                            var snapshot = getScriptSnapshotDirect(resolvedFileName) || undefined;
                            return fileCache[resolvedFileName] = {
                                unusedCount: 0,
                                stat: stat,
                                version: version,
                                content: content,
                                snapshot: snapshot
                            };
                        }
                    });
                    return entry.completed && entry.success && entry.result || null;
                }
                function getFileStat(resolvedFileName) {
                    var entry = cache.cachedOrPopulate({
                        cacheField: 'cachedFileStats',
                        key: resolvedFileName,
                        populate: function () {
                            var entry = getCachedFileEntry(resolvedFileName);
                            return (entry === null || entry === void 0 ? void 0 : entry.stat) || null;
                        }
                    });
                    return entry.completed && entry.success && entry.result || null;
                }
                function getFileContent(resolvedFileName) {
                    var entry = cache.cachedOrPopulate({
                        cacheField: 'cachedFileContent',
                        key: resolvedFileName,
                        populate: function () {
                            var entry = getCachedFileEntry(resolvedFileName);
                            return typeof (entry === null || entry === void 0 ? void 0 : entry.content) === 'string' ? entry.content : null;
                        }
                    });
                    return entry.completed && entry.success && entry.result || null;
                }
                function hostGetCompilationSettings() {
                    return settings;
                }
                function hostGetScriptFileNames() {
                    var entry = cache.cachedOrPopulate({
                        cacheField: 'cachedScriptFileNames',
                        populate: function () {
                            var sources = [];
                            for (var _i = 0, scriptInputs_1 = scriptInputs; _i < scriptInputs_1.length; _i++) {
                                var src = scriptInputs_1[_i];
                                if (src.type !== 'tsconfig') {
                                    sources.push(src.resolvedPath);
                                }
                            }
                            if (configSourcedFiles) {
                                for (var _a = 0, configSourcedFiles_1 = configSourcedFiles; _a < configSourcedFiles_1.length; _a++) {
                                    var src = configSourcedFiles_1[_a];
                                    var resolvedPath = resolveJoinPathInProject(src);
                                    // const relativePath = getProjectRelativeFileName(resolvedPath);
                                    sources.push(resolvedPath);
                                }
                            }
                            return sources;
                        }
                    });
                    return !entry.completed || !entry.success ? [] : entry.result;
                }
                function hostGetScriptVersion(fileName) {
                    var resolvedFileName = resolveJoinPathInProject(fileName);
                    if (typeof precachedFixedSource === 'function') {
                        var entry_1 = precachedFixedSource(resolvedFileName);
                        if (entry_1)
                            return 'precached';
                    }
                    var entry = getCachedFileEntry(resolvedFileName);
                    return (entry === null || entry === void 0 ? void 0 : entry.version) || 'cache-miss';
                }
                function deriveFileVersionFromStat(_a) {
                    var timestamp = _a.timestamp, length = _a.length;
                    return length + '@' + timestamp;
                }
                function hostFileExists(fileName) {
                    var resolvedFileName = resolveJoinPathInProject(fileName);
                    var stat = getFileStat(resolvedFileName);
                    return !!stat && !stat.isDirectory;
                }
                function hostGetScriptSnapshot(fileName) {
                    var resolvedFileName = resolveJoinPathInProject(fileName);
                    if (typeof precachedFixedSource === 'function') {
                        var entry_2 = precachedFixedSource(resolvedFileName);
                        if (entry_2)
                            return entry_2.snapshot;
                    }
                    var entry = cache.cachedOrPopulate({
                        cacheField: 'cacheScriptSnapshots',
                        key: resolvedFileName,
                        populate: function () {
                            var entry = getCachedFileEntry(resolvedFileName);
                            return (entry === null || entry === void 0 ? void 0 : entry.snapshot) || null;
                        }
                    });
                    if (entry.completed && entry.success)
                        return entry.result || void 0;
                    else
                        return void 0;
                }
                function hostReadFile(fileName) {
                    var resolvedFileName = resolveJoinPathInProject(fileName);
                    var fileContent = getFileContent(resolvedFileName);
                    return typeof fileContent === 'string' ? fileContent : void 0;
                }
                function hostGetCanonicalFileName(fileName) {
                    return getProjectRelativeFileName(fileName);
                }
                function hostGetCurrentDirectory() {
                    return inputs.resolvedProjectDir;
                }
                var emptyDirectoryList;
                function hostGetDirectories(dirPath) {
                    var resolvedDirPath = resolveJoinPathInProject(dirPath);
                    var entry = cache.cachedOrPopulate({
                        cacheField: 'getDirectoriesByPath',
                        key: resolvedDirPath,
                        populate: function () {
                            var dirs = fileSystem.readDirectory(resolvedDirPath);
                            return dirs || null;
                        }
                    });
                    return (entry.completed && entry.success ? entry.result : null) ||
                        emptyDirectoryList || (emptyDirectoryList = []);
                }
                function hostGetDefaultLibFileName(options) {
                    var entry = cache.cachedOrPopulate({
                        cacheField: 'cachedResolvedDefaultLibFileName',
                        populate: function () { return hostGetCanonicalFileName(fileSystem.resolvePath(buildState.tsLibPath, ts.getDefaultLibFileName(options))); }
                    });
                    return entry.completed && entry.success ? entry.result : 'lib.d.ts';
                }
                function createScriptSnapshot(resolvedFileName, fileContent) {
                    // TODO: implement getChangeRange?
                    return code.preciseScriptSnapshot(fileContent);
                }
            }
            code.codeBuilder = codeBuilder;
            (function (codeBuilder) {
                codeBuilder.DefaultImport = {};
                codeBuilder.StarImport = {};
                codeBuilder.RawImport = {};
                var regex_DTS = /\.d\.ts$/i;
                var regex_MAP = /\.map$/i;
                var regex_getFileExt = /^.*[^.\\/](\.[^.\\/]+)$/;
                var regex_javascriptFileExtension = /\.(js|jsx)$/i;
                function isTypingsFilename(fileName) { return regex_DTS.test(fileName); }
                codeBuilder.isTypingsFilename = isTypingsFilename;
                function isSourcemapFilename(fileName) { return regex_MAP.test(fileName); }
                codeBuilder.isSourcemapFilename = isSourcemapFilename;
                function getFileExtension(fileName) {
                    var ext = fileName.replace(regex_getFileExt, '$1');
                    if (ext === fileName) // failed to match the .ext regexp
                        return '';
                    else
                        return ext;
                }
                codeBuilder.getFileExtension = getFileExtension;
                function hasJavascriptFileExtension(file) {
                    return regex_javascriptFileExtension.test(file);
                }
                codeBuilder.hasJavascriptFileExtension = hasJavascriptFileExtension;
            })(codeBuilder = code.codeBuilder || (code.codeBuilder = {}));
            function shouldSkipDirectoryContentFromIteration(fName) {
                return fName === 'node_modules'
                    || fName === '.git'
                    || fName === '.DS_Store';
            }
            function readDirectory(projectDir, fileSystem, rootDir, extensions, excludes, includes, depth) {
                var result = [];
                readDirectoryRecursive(fileSystem.resolvePath(projectDir, rootDir), depth);
                return result;
                function readDirectoryRecursive(resolvedDirPath, moreDepth) {
                    var dirEntries = fileSystem.readDirectory(resolvedDirPath);
                    if (!dirEntries)
                        return;
                    var ownFiles = [];
                    dirEntries.sort();
                    for (var _i = 0, dirEntries_1 = dirEntries; _i < dirEntries_1.length; _i++) {
                        var entry = dirEntries_1[_i];
                        var stat = fileSystem.stat(entry);
                        if (!stat)
                            continue;
                        if (stat.isDirectory) {
                            readDirectoryRecursive(entry, typeof moreDepth === 'undefined' ? moreDepth : moreDepth - 1);
                        }
                        else if (!extensions || !extensions.length || extensions.indexOf(codeBuilder.getFileExtension(entry).toLowerCase()) >= 0) {
                            // TODO: handle excludes/includes
                            ownFiles.push(fileSystem.getRelativePath(rootDir, entry));
                        }
                    }
                    if (ownFiles.length) {
                        for (var i = 0; i < ownFiles.length; i++) {
                            result.push(ownFiles[i]);
                        }
                    }
                }
            }
            function createImportOriginEntry(resolvedSourcePath, node) {
                var sourceFile = node.getSourceFile();
                var start = sourceFile.getLineAndCharacterOfPosition(node.getStart());
                var lineStart = sourceFile.getPositionOfLineAndCharacter(start.line, 0);
                var lineEnd = sourceFile.getLineEndOfPosition(node.getStart());
                var lineText = sourceFile.getText().slice(lineStart, lineEnd);
                var nodeEndOrLineEnd = sourceFile.getLineAndCharacterOfPosition(Math.min(node.getEnd(), lineEnd));
                var importOrigin = {
                    resolvedSourcePath: resolvedSourcePath,
                    line: start.line,
                    character: start.character,
                    length: nodeEndOrLineEnd.character - start.character,
                    lineText: lineText
                };
                return importOrigin;
            }
            function generatePlainEmitWithEmptyFile(sourceName, text) {
                var sourcemap = {
                    version: 3,
                    file: sourceName,
                    sourceRoot: '',
                    sources: [sourceName],
                    names: [],
                    mappings: '',
                    sourcesContent: [text]
                };
                var sourcemapText = JSON.stringify(sourcemap);
                return {
                    resolvedSourcePath: sourceName,
                    output: '\n//# sourceMappingURL=' + sourceName + '.map',
                    sourcemap: sourcemapText
                };
            }
            function generateHelperEmitWithPerLineMaps(h) {
                var sourceName = h.name + '.js';
                var sourcePath = '__helpers/' + sourceName;
                var sourceContent = typeof h.text === 'string' ? h.text : h.text(function (nm) { return nm; });
                var sourcemap = {
                    version: 3,
                    file: sourceName,
                    sourceRoot: '',
                    sources: [sourcePath],
                    names: [],
                    mappings: '',
                    sourcesContent: [sourceContent]
                };
                var sourcemapWriter = danfo.parsing.sourcemap.writer();
                var linePos = 0;
                var mapping = {
                    generatedLine: 0,
                    generatedColumn: 0,
                    originalLine: 0,
                    originalColumn: 0,
                    originalFile: 0,
                    originalName: -1
                };
                while (linePos < sourceContent.length) {
                    var lineEnd = sourceContent.indexOf('\n', linePos);
                    if (lineEnd < 0)
                        lineEnd = sourceContent.length;
                    mapping.generatedLine++;
                    mapping.originalLine++;
                    sourcemapWriter.write(mapping);
                    linePos = lineEnd + 1;
                }
                sourcemap.mappings = sourcemapWriter.text();
                var sourcemapText = JSON.stringify(sourcemap);
                var sourcemapFileName = sourceName + '.map';
                return {
                    resolvedSourcePath: sourcePath,
                    output: sourceContent + '\n//# sourceMappingURL=' + sourcemapFileName,
                    sourcemap: { fileName: sourcemapFileName, content: sourcemapText }
                };
            }
        })(code = build.code || (build.code = {}));
    })(build = danfo.build || (danfo.build = {}));
})(danfo || (danfo = {}));
var danfo;
(function (danfo) {
    var build;
    (function (build) {
        var code;
        (function (code) {
            function findDependencies(args) {
                var program = args.program, resolutionHost = args.resolutionHost, resolutionCache = args.resolutionCache, ts = args.ts, sourceFile = args.sourceFile, transformationContext = args.transformationContext, exportCallback = args.exportCallback, dependencyCallback = args.dependencyCallback;
                var dependencies = {
                    transformed: sourceFile
                };
                var checker = program.getTypeChecker();
                dependencies.transformed = invokeTransformationOrSimpleVisitor();
                return dependencies;
                function invokeTransformationOrSimpleVisitor() {
                    var visitChildNodes;
                    if (typeof exportCallback !== 'function' && typeof dependencyCallback !== 'function') {
                        // use a simple visitor, without transforms
                        visitChildNodes = function (node, visitor) {
                            return ts.forEachChild(node, visitor);
                        };
                        visitDependencies(sourceFile) || sourceFile;
                    }
                    else if (transformationContext) {
                        // transform with a given transformation context
                        visitChildNodes = function (node, visitor) {
                            return ts.visitEachChild(node, visitor, transformationContext);
                        };
                        return visitDependencies(sourceFile) || sourceFile;
                    }
                    else {
                        // transform without a transformation context passed:
                        // by invoking `ts.transform` and passing a manufactured custom transformer,
                        // which will invoke the visitor we have
                        var transformResult = ts.transform(sourceFile, [
                            function (context) { return function (sourceFileNode) {
                                visitChildNodes = function (node, visitor) {
                                    return ts.visitEachChild(node, visitor, context);
                                };
                                return visitDependencies(sourceFileNode) || sourceFile;
                            }; }
                        ], program.getCompilerOptions());
                        transformResult.dispose();
                        return transformResult.transformed[0];
                    }
                }
                function visitDependencies(input) {
                    var processed = ts.forEachChild(input, visitDependencies) || input;
                    if (ts.isImportDeclaration(input)) {
                        // console.log('import declaration ' + ts.SyntaxKind[input.kind] + ' at ' + input.pos);
                        processed = includeImportDeclaration(input);
                    }
                    else if (ts.isImportEqualsDeclaration(input)) {
                        // console.log('import equals declaration ' + ts.SyntaxKind[input.kind] + ' at ' + input.pos);
                        // TODO: handle this weird old syntax
                    }
                    else if (code.isImportExpression(input, ts)) {
                        // console.log('import expression ' + ts.SyntaxKind[input.kind] + ' at ' + input.pos);
                        processed = includeImportExpression(input);
                    }
                    else if (code.isRequireExpression(input, ts, checker)) {
                        // console.log('require declaration ' + ts.SyntaxKind[input.kind] + ' at ' + input.pos);
                        processed = includeRequireDeclaration(input);
                    }
                    else if (ts.isExportAssignment(input)) {
                        processed = inlcudeExportAssignment(input);
                    }
                    else if (ts.isExportDeclaration(input)) {
                        processed = inlcudeExportDeclaration(input);
                    }
                    else if (code.isDeclarationWithModifier(input, ts.SyntaxKind.ExportKeyword, ts)) {
                        processed = includeDeclarationWithExportModifier(input);
                    }
                    else if (code.isModuleExportsAssignment(input, ts, checker)) {
                        processed = includeModuleExportsAssignment(input);
                    }
                    else if (code.isModuleExportsPropertyAssignment(input, ts, checker)) {
                        processed = includeModuleExportsPropertyAssignment(input);
                    }
                    else {
                        var amdDefine = code.isAmdDefineCall(input, ts, checker);
                        if (amdDefine) {
                            processed = includeAmdImportsExports(amdDefine);
                        }
                    }
                    if (processed !== input)
                        return processed;
                }
                function createDependency(import_, moduleNode, assignsTo, async) {
                    var reference = code.getPossibleStringLiteralValues(moduleNode, ts, checker);
                    var resolvedSourceFile;
                    if (typeof reference === 'string') {
                        var resolvedReference = ts.resolveModuleName(reference, import_.getSourceFile().fileName, program.getCompilerOptions(), resolutionHost, resolutionCache);
                        if (resolvedReference.resolvedModule
                            && resolvedReference.resolvedModule.resolvedFileName) {
                            resolvedSourceFile = program.getSourceFile(resolvedReference.resolvedModule.resolvedFileName);
                        }
                    }
                    var dep = {
                        async: async,
                        dynamic: typeof reference !== 'string',
                        importNode: import_,
                        moduleNode: moduleNode,
                        assignsTo: assignsTo,
                        reference: reference,
                        sourceFile: sourceFile,
                        resolvedSourceFile: resolvedSourceFile
                    };
                    if (!dependencies.imports)
                        dependencies.imports = [dep];
                    else
                        dependencies.imports.push(dep);
                    if (typeof dependencyCallback === 'function') {
                        var converted = dependencyCallback(dep);
                        if (converted) {
                            return converted;
                        }
                    }
                }
                function includeImportDeclaration(node) {
                    return createDependency(node, node.moduleSpecifier, getImportDeclarationAssigns(node), 
                    /* async */ false);
                }
                function getImportDeclarationAssigns(node) {
                    var assignsTo;
                    if (node.importClause) {
                        if (node.importClause.name) {
                            assignsTo = {
                                defaultTarget: node.importClause.name
                            };
                        }
                        if (node.importClause.namedBindings) {
                            if (ts.isNamedImports(node.importClause.namedBindings)) {
                                var named = [];
                                for (var _i = 0, _a = node.importClause.namedBindings.elements; _i < _a.length; _i++) {
                                    var bin = _a[_i];
                                    named.push({
                                        sourceName: bin.name.text,
                                        target: bin.propertyName || bin.name
                                    });
                                }
                                if (!assignsTo)
                                    assignsTo = { named: named };
                                else
                                    assignsTo.named = named;
                            }
                            else if (ts.isNamespaceImport(node.importClause.namedBindings)) {
                                if (!assignsTo)
                                    assignsTo = {
                                        starTarget: node.importClause.namedBindings.name
                                    };
                                else
                                    assignsTo.starTarget = node.importClause.namedBindings.name;
                            }
                        }
                    }
                    return assignsTo;
                }
                function includeImportExpression(node) {
                    return createDependency(node, node.arguments[0], getExpressionAssigns(node), 
                    /* async */ true);
                }
                function includeRequireDeclaration(node) {
                    return createDependency(node, node.arguments[0], getExpressionAssigns(node), 
                    /* async */ false);
                }
                function getExpressionAssigns(node) {
                    if (ts.isVariableDeclaration(node.parent) && node.parent.initializer === node) {
                        return { starTarget: node.parent.name };
                    }
                    // TODO: detect other expressions
                }
                function inlcudeExportAssignment(node) {
                    return createExport({
                        exportNode: node,
                        kind: 'exportsAssignment',
                        defaultExport: node
                    });
                }
                function inlcudeExportDeclaration(node) {
                    if (node.exportClause) {
                        if (ts.isNamespaceExport(node.exportClause)) {
                            var name_1 = code.getPossibleNameString(node.exportClause.name, ts);
                            if (typeof name_1 === 'string') {
                                return createExport({
                                    exportNode: node,
                                    kind: 'exportStatement',
                                    namedExports: [{
                                            name: name_1,
                                            exportedAs: node
                                        }]
                                });
                            }
                        }
                        else {
                            var namedExports = [];
                            for (var _i = 0, _a = node.exportClause.elements; _i < _a.length; _i++) {
                                var el = _a[_i];
                                var name_2 = code.getPossibleNameString(el.name, ts);
                                if (typeof name_2 === 'string')
                                    namedExports.push({
                                        name: name_2,
                                        exportedAs: el
                                    });
                            }
                            return createExport({
                                exportNode: node,
                                kind: 'exportStatement',
                                namedExports: namedExports
                            });
                        }
                    }
                }
                function includeDeclarationWithExportModifier(node) {
                    var isDefault = code.isDeclarationWithModifier(node, ts.SyntaxKind.DefaultKeyword, ts);
                    var nameNode = isDefault ? void 0 : node.name;
                    var name = nameNode && code.getPossibleNameString(nameNode, ts);
                    return createExport({
                        exportNode: node,
                        kind: 'exportStatement',
                        defaultExport: isDefault ? node : void 0,
                        namedExports: typeof name === 'string' ? [{
                                name: name,
                                exportedAs: node
                            }] : void 0
                    });
                }
                function includeModuleExportsAssignment(node) {
                    var name = code.getPossibleNameString(node.name, ts);
                    if (typeof name === 'string')
                        return createExport({
                            exportNode: node,
                            wholeModuleBody: node,
                            kind: 'exportsAssignment',
                            namedExports: [{
                                    name: name,
                                    exportedAs: node.initializer
                                }]
                        });
                }
                function includeModuleExportsPropertyAssignment(node) {
                    var name = code.getPossibleNameString(node.name, ts);
                    if (typeof name === 'string')
                        return createExport({
                            exportNode: node,
                            kind: 'exportsAssignment',
                            namedExports: [{
                                    name: name,
                                    exportedAs: node.initializer
                                }]
                        });
                }
                function includeAmdImportsExports(amdDefine) {
                    if (amdDefine.moduleName) {
                        createExport({
                            exportNode: amdDefine.node,
                            wholeModuleBody: amdDefine.moduleBodyArgument,
                            kind: 'amd',
                            moduleNameOverride: amdDefine.moduleName
                        });
                    }
                    if (amdDefine.imports && amdDefine.imports.length) {
                        createDependency(amdDefine.moduleBodyArgument.parent, amdDefine.moduleBodyArgument, {
                            named: amdDefine.imports
                        }, false);
                    }
                    return void 0;
                }
                function createExport(exportElement) {
                    if (!dependencies.exports)
                        dependencies.exports = [exportElement];
                    else
                        dependencies.exports.push(exportElement);
                    if (typeof exportCallback === 'function') {
                        var converted = exportCallback(exportElement);
                        if (converted) {
                            return converted;
                        }
                    }
                }
            }
            code.findDependencies = findDependencies;
        })(code = build.code || (build.code = {}));
    })(build = danfo.build || (danfo.build = {}));
})(danfo || (danfo = {}));
var danfo;
(function (danfo) {
    var build;
    (function (build) {
        var code;
        (function (code) {
            function importTypeScript() {
                var ts = require('typescript');
                ts.resolveDefaultLibFromOfficial = resolveDefaultLibFromOfficial;
                return ts;
                function resolveDefaultLibFromOfficial(libFileName) {
                    try {
                        var libPath = require.resolve('typescript/lib/' + libFileName);
                        return libPath;
                    }
                    catch (error) { }
                }
            }
            code.importTypeScript = importTypeScript;
        })(code = build.code || (build.code = {}));
    })(build = danfo.build || (danfo.build = {}));
})(danfo || (danfo = {}));
var danfo;
(function (danfo) {
    var build;
    (function (build) {
        var code;
        (function (code) {
            function createKeyCache(cacheOwner, promiseWrap) {
                return {
                    cachedOrPopulate: cachedOrPopulate
                };
                function cachedOrPopulate(_a) {
                    var cacheField = _a.cacheField, key = _a.key, populate = _a.populate;
                    var cache = cacheOwner[cacheField];
                    if (!cache && typeof key === 'string') {
                        cache = {};
                        cacheOwner[cacheField] = cache;
                    }
                    var entry = (typeof key === 'string' ? cache[key] : cache);
                    if (entry) {
                        if (!entry.completed && entry.initial)
                            entry.initial = false;
                        return entry;
                    }
                    var newEntry = {
                        completed: false,
                        initial: true,
                        reset: reset
                    };
                    if (typeof key === 'string')
                        cache[key] = newEntry;
                    else
                        cacheOwner[cacheField] = newEntry;
                    try {
                        var populateResult = populate();
                        var populateResultPromise = populateResult;
                        if (populateResult && typeof populateResultPromise.then === 'function') {
                            var wrappedPromise = typeof promiseWrap === 'function' ?
                                promiseWrap(populateResultPromise) :
                                populateResultPromise;
                            wrappedPromise.then(function (result) {
                                var populatedEntry = {
                                    completed: true,
                                    success: true,
                                    result: result,
                                    reset: reset
                                };
                                if (typeof key === 'string')
                                    cache[key] = populatedEntry;
                                else
                                    cacheOwner[cacheField] = populatedEntry;
                            }, function (error) {
                                var populatedFail = {
                                    completed: true,
                                    success: false,
                                    error: error,
                                    reset: reset
                                };
                                if (typeof key === 'string')
                                    cache[key] = populatedFail;
                                else
                                    cacheOwner[cacheField] = populatedFail;
                            });
                            return newEntry;
                        }
                        else {
                            var populatedEntry = {
                                completed: true,
                                success: true,
                                result: populateResult,
                                reset: reset
                            };
                            if (typeof key === 'string')
                                cache[key] = populatedEntry;
                            else
                                cacheOwner[cacheField] = populatedEntry;
                            return populatedEntry;
                        }
                    }
                    catch (error) {
                        var populatedFail = {
                            completed: true,
                            success: false,
                            error: error,
                            reset: reset
                        };
                        if (typeof key === 'string')
                            cache[key] = populatedFail;
                        else
                            cacheOwner[cacheField] = populatedFail;
                        return populatedFail;
                    }
                    function reset() {
                        delete cacheOwner[cacheField];
                    }
                }
            }
            code.createKeyCache = createKeyCache;
        })(code = build.code || (build.code = {}));
    })(build = danfo.build || (danfo.build = {}));
})(danfo || (danfo = {}));
var danfo;
(function (danfo) {
    var build;
    (function (build) {
        var code;
        (function (code) {
            function preciseScriptSnapshot(text) {
                return new PreciseScriptSnapshot(text);
            }
            code.preciseScriptSnapshot = preciseScriptSnapshot;
            var PreciseScriptSnapshot = /** @class */ (function () {
                function PreciseScriptSnapshot(text) {
                    this.text = text;
                }
                PreciseScriptSnapshot.prototype.getText = function (start, end) {
                    return this.text.slice(start, end);
                };
                PreciseScriptSnapshot.prototype.getLength = function () {
                    return this.text.length;
                };
                PreciseScriptSnapshot.prototype.getChangeRange = function (oldSnapshot) {
                    if (oldSnapshot === this)
                        return {
                            span: {
                                start: this.text.length,
                                length: 0
                            },
                            newLength: 0
                        };
                    var oldSnapshotText = oldSnapshot.text;
                    if (typeof oldSnapshotText !== 'string')
                        return void 0;
                    var leadMatchLength, trailMatchLength;
                    for (leadMatchLength = 0; leadMatchLength < this.text.length && leadMatchLength < oldSnapshotText.length; leadMatchLength++) {
                        if (this.text.charCodeAt(leadMatchLength) !== oldSnapshotText.charCodeAt(leadMatchLength))
                            break;
                    }
                    for (trailMatchLength = 0; trailMatchLength < this.text.length - leadMatchLength && trailMatchLength < oldSnapshotText.length - leadMatchLength; trailMatchLength++) {
                        if (this.text.charCodeAt(this.text.length - 1 - trailMatchLength) !== oldSnapshotText.charCodeAt(oldSnapshotText.length - 1 - trailMatchLength))
                            break;
                    }
                    return {
                        span: {
                            start: leadMatchLength,
                            length: oldSnapshotText.length - leadMatchLength - trailMatchLength
                        },
                        newLength: this.text.length - leadMatchLength - trailMatchLength
                    };
                };
                return PreciseScriptSnapshot;
            }());
        })(code = build.code || (build.code = {}));
    })(build = danfo.build || (danfo.build = {}));
})(danfo || (danfo = {}));
var danfo;
(function (danfo) {
    var build;
    (function (build) {
        var code;
        (function (code) {
            function isAmdDefineCall(node, ts, checker) {
                var typeChecker = typeof checker.getTypeChecker === 'function' ?
                    checker.getTypeChecker() :
                    checker;
                if (ts.isCallExpression(node)
                    && isGlobalName(node.expression, 'define', ts, typeChecker)
                    && node.arguments.length >= 2 && node.arguments.length <= 3) {
                    var factoryArgument = node.arguments[node.arguments.length - 1];
                    var factorySignature = getPossibleFunctionArguments(factoryArgument, ts, typeChecker);
                    if (factorySignature) {
                        if (!factorySignature)
                            return void 0; // function should be the last parameter to define(...)
                        if (node.arguments.length === 2) {
                            var firstArgumentStringValues = getPossibleStringLiteralValues(node.arguments[0], ts, typeChecker);
                            if (firstArgumentStringValues) {
                                if (typeof firstArgumentStringValues === 'string')
                                    return {
                                        node: node,
                                        moduleName: firstArgumentStringValues,
                                        imports: [],
                                        moduleBodyArgument: factoryArgument
                                    };
                                else
                                    return void 0; // if first argument is of string type, its value should be statically known
                            }
                            var firstArgumentArrayValues = getPossibleStringArrayValues(node.arguments[0], ts, typeChecker);
                            if (firstArgumentArrayValues) {
                                var imports = [];
                                for (var i = 0; i < firstArgumentArrayValues.length; i++) {
                                    imports.push({
                                        sourceName: firstArgumentArrayValues[i],
                                        target: i < factorySignature.length && factorySignature[i].kind ?
                                            factorySignature[i] :
                                            void 0
                                    });
                                }
                                if (imports.length) {
                                    return {
                                        node: node,
                                        imports: imports,
                                        moduleBodyArgument: factoryArgument
                                    };
                                }
                            }
                        }
                        else if (node.arguments.length === 3) {
                            var firstArgumentStringValues = getPossibleStringLiteralValues(node.arguments[0], ts, typeChecker);
                            if (typeof firstArgumentStringValues === 'string') {
                                var secondArgumentArrayValues = getPossibleStringArrayValues(node.arguments[1], ts, typeChecker);
                                if (secondArgumentArrayValues) {
                                    var imports = [];
                                    for (var i = 0; i < secondArgumentArrayValues.length; i++) {
                                        imports.push({
                                            sourceName: secondArgumentArrayValues[i],
                                            target: i < factorySignature.length && factorySignature[i].kind ?
                                                factorySignature[i] :
                                                void 0
                                        });
                                    }
                                    return {
                                        node: node,
                                        moduleName: firstArgumentStringValues,
                                        imports: imports.length ? imports : void 0,
                                        moduleBodyArgument: factoryArgument
                                    };
                                }
                            }
                        }
                    }
                }
                return void 0;
            }
            code.isAmdDefineCall = isAmdDefineCall;
            function isGlobalName(node, name, ts, checker) {
                var typeChecker = typeof checker.getTypeChecker === 'function' ?
                    checker.getTypeChecker() :
                    checker;
                return isGlobalNameWorker(node, name, [], ts, typeChecker);
            }
            code.isGlobalName = isGlobalName;
            function isGlobalNameWorker(node, name, visitedNodes, ts, checker) {
                var fnSymbol = checker.getSymbolAtLocation(node);
                if (!fnSymbol)
                    return ts.isIdentifier(node) && node.text === name;
                var declArray = fnSymbol.getDeclarations();
                if (!declArray || !declArray.length)
                    return fnSymbol.name === name;
                for (var _i = 0, declArray_1 = declArray; _i < declArray_1.length; _i++) {
                    var decl = declArray_1[_i];
                    if (ts.isVariableDeclaration(decl)) {
                        if (decl.initializer) {
                            return invokeRecursivePredicateEscapeCycles(isGlobalNameWorker, decl.initializer, name, visitedNodes, ts, checker);
                        }
                        // check if global scope?
                        if (isVariableGlobalScope(decl, ts) && ts.isIdentifier(decl.name)) {
                            return decl.name.text === name;
                        }
                        // console.log('variable decl: ', ts.SyntaxKind[decl.kind], decl);
                        return false;
                    }
                    else if (ts.isParameter(decl)) {
                        // parameter can be defaulted to global symbol - check
                        if (decl.initializer) {
                            if (invokeRecursivePredicateEscapeCycles(isGlobalNameWorker, decl.initializer, name, visitedNodes, ts, checker))
                                return true;
                        }
                        // or it could be IIFE, check arguments then
                        var fnExpr = decl.parent;
                        if (ts.isFunctionExpression(fnExpr)) {
                            var fnInvok = getIIFEInvocation(fnExpr, ts);
                            if (fnInvok) {
                                var paramIndex = fnExpr.parameters.indexOf(decl);
                                var invokParam = fnInvok.arguments[paramIndex];
                                if (invokParam) {
                                    return invokeRecursivePredicateEscapeCycles(isGlobalNameWorker, invokParam, name, visitedNodes, ts, checker);
                                }
                            }
                        }
                        return false;
                    }
                }
                return false;
            }
            function invokeRecursivePredicateEscapeCycles(predicate, item, arg, visited, s1, s2) {
                if (visited) {
                    if (visited.indexOf(item))
                        return false;
                    visited.push(item);
                }
                else {
                    visited = [item];
                }
                return predicate(item, arg, visited, s1, s2);
            }
            function isVariableGlobalScope(variable, ts) {
                return ts.isSourceFile(variable.parent.parent.parent);
            }
            code.isVariableGlobalScope = isVariableGlobalScope;
            function getIIFEInvocation(fnExpr, ts) {
                var fnCurrent = fnExpr;
                for (var i = 0; fnCurrent.parent && i < 5; i++) { // max check depth
                    if (ts.isCallExpression(fnCurrent.parent) && fnCurrent.parent.expression === fnCurrent)
                        return fnCurrent.parent;
                    if (!ts.isParenthesizedExpression(fnCurrent.parent))
                        return;
                    fnCurrent = fnCurrent.parent;
                }
            }
            code.getIIFEInvocation = getIIFEInvocation;
            function isDeclarationWithModifier(node, modifier, ts) {
                var withModifiers = node;
                if (withModifiers.modifiers) {
                    for (var _i = 0, _a = withModifiers.modifiers; _i < _a.length; _i++) {
                        var mod = _a[_i];
                        if (mod.kind === modifier)
                            return true;
                    }
                }
                return false;
            }
            code.isDeclarationWithModifier = isDeclarationWithModifier;
            /** module.exports = ... */
            function isModuleExportsAssignment(node, ts, checker) {
                if (ts.isPropertyAssignment(node)
                    && ts.isIdentifier(node.parent)
                    && isGlobalName(node.parent, 'module', ts, checker)
                    && getPossibleNameString(node.name, ts) === 'exports') {
                    return true;
                }
                return false;
            }
            code.isModuleExportsAssignment = isModuleExportsAssignment;
            /** module.exports.xxxxx = ... */
            function isModuleExportsPropertyAssignment(node, ts, checker) {
                if (ts.isBinaryExpression(node)
                    && node.operatorToken.kind === ts.SyntaxKind.EqualsToken
                    && ts.isPropertyAccessExpression(node.parent)
                    && node.parent.parent
                    && ts.isIdentifier(node.parent.parent)
                    && isGlobalName(node.parent.parent, 'module', ts, checker)
                    && getPossibleNameString(node.parent.name, ts) === 'export') {
                    return true;
                }
                return false;
            }
            code.isModuleExportsPropertyAssignment = isModuleExportsPropertyAssignment;
            function getPossibleNameString(node, ts) {
                if (ts.isIdentifier(node))
                    return node.text;
                if (ts.isStringLiteralLike(node)) // TODO: handle escapes?
                    return node.text;
                if (ts.isNumericLiteral(node)) // TODO: normalize?
                    return node.text;
            }
            code.getPossibleNameString = getPossibleNameString;
            function isRequireExpression(node, ts, checker) {
                return ts.isCallExpression(node) && isGlobalName(node.expression, 'require', ts, checker);
            }
            code.isRequireExpression = isRequireExpression;
            function isImportExpression(node, ts) {
                return ts.isCallExpression(node) && node.expression.kind === ts.SyntaxKind.ImportKeyword;
            }
            code.isImportExpression = isImportExpression;
            function getPossibleFunctionArguments(node, ts, checker) {
                if (ts.isFunctionExpression(node))
                    return node.parameters;
                var typeChecker = typeof checker.getTypeChecker === 'function' ?
                    checker.getTypeChecker() :
                    checker;
                var expressionType = typeChecker.getTypeAtLocation(node);
                var callSignatures = expressionType.getCallSignatures();
                var longestSignature = callSignatures[0];
                for (var i = 1; i < callSignatures.length; i++) {
                    if (callSignatures[i].parameters.length > longestSignature.parameters.length)
                        longestSignature = callSignatures[i];
                }
                return longestSignature ? longestSignature.parameters : null;
            }
            code.getPossibleFunctionArguments = getPossibleFunctionArguments;
            function getPossibleStringLiteralValues(expression, ts, checker) {
                if (ts.isStringLiteralLike(expression))
                    return expression.text;
                var typeChecker = typeof checker.getTypeChecker === 'function' ?
                    checker.getTypeChecker() :
                    checker;
                var expressionType = typeChecker.getTypeAtLocation(expression);
                return getPossibleStringLiteralValuesOfType(expressionType);
            }
            code.getPossibleStringLiteralValues = getPossibleStringLiteralValues;
            function getPossibleStringLiteralValuesOfType(type) {
                if (type.isStringLiteral()) {
                    return type.value;
                }
                if (type.isUnion()) {
                    var unionTypeValues = [];
                    var hasNull = false;
                    for (var _i = 0, _a = type.types; _i < _a.length; _i++) {
                        var uniType = _a[_i];
                        var values = getPossibleStringLiteralValuesOfType(uniType);
                        if (typeof values === 'string')
                            unionTypeValues.push(values);
                        else if (values && values.length)
                            unionTypeValues = unionTypeValues.concat(values);
                    }
                    return !unionTypeValues.length ? null : unionTypeValues.length === 1 ? unionTypeValues[0] : unionTypeValues;
                }
                return null;
            }
            code.getPossibleStringLiteralValuesOfType = getPossibleStringLiteralValuesOfType;
            function getPossibleStringArrayValues(node, ts, checker) {
                var typeChecker = typeof checker.getTypeChecker === 'function' ?
                    checker.getTypeChecker() :
                    checker;
                if (ts.isArrayLiteralExpression(node)) {
                    var strings = [];
                    for (var _i = 0, _a = node.elements; _i < _a.length; _i++) {
                        var el = _a[_i];
                        var elString = getPossibleStringLiteralValues(el, ts, checker);
                        if (typeof elString === 'string')
                            strings.push(elString);
                        else
                            break;
                    }
                    return strings;
                }
            }
            code.getPossibleStringArrayValues = getPossibleStringArrayValues;
        })(code = build.code || (build.code = {}));
    })(build = danfo.build || (danfo.build = {}));
})(danfo || (danfo = {}));
var danfo;
(function (danfo) {
    var build;
    (function (build) {
        var css;
        (function (css) {
            function cssBuilder(file, content) {
            }
            css.cssBuilder = cssBuilder;
        })(css = build.css || (build.css = {}));
    })(build = danfo.build || (danfo.build = {}));
})(danfo || (danfo = {}));
var danfo;
(function (danfo) {
    var build;
    (function (build) {
        var html;
        (function (html) {
            var regex_LF_withPossibleTrailingWhitespace_thenEOF = /\n\s*$/;
            var regex_leadingLineHasNonWhitespace = /^[^\S\r\n]*\S/;
            var regex_trailingLineHasNonWhitespace = /\S[^\S\r\n]*$/;
            function htmlBuilder(_a) {
                var fileSystem = _a.fileSystem, precachedFixedSnapshots = _a.precachedFixedSource;
                var htmlFile;
                var resolvedHtmlFilePath;
                var resolvedProjectDir;
                var onDemandCodeBuilder;
                var processEntries = [];
                var builder = {
                    build: buildHtml
                };
                return builder;
                function buildHtml(inputs) {
                    htmlFile = inputs.htmlFile;
                    resolvedProjectDir = inputs.resolvedProjectDir;
                    resolvedHtmlFilePath = htmlFile.resolvedPath;
                    var htmlContent = fileSystem.readFile(resolvedHtmlFilePath);
                    if (typeof htmlContent !== 'string')
                        return {
                            htmlEmit: void 0,
                            errors: [{
                                    code: 'No file',
                                    message: 'File cannot be read from ' + resolvedHtmlFilePath,
                                    resolvedSourcePath: resolvedHtmlFilePath
                                }]
                        };
                    var htmlParsed = danfo.parsing.parseHTML(htmlContent);
                    var errors = [];
                    processEntries = htmlParsed.map(function (parsed) {
                        var entry = {
                            parsed: parsed
                        };
                        return entry;
                    });
                    extractAndProcessCssEntries();
                    var codeSources = [];
                    var codeEntriesByResolvedPath = {};
                    var htmlContentLineMap;
                    for (var _i = 0, processEntries_1 = processEntries; _i < processEntries_1.length; _i++) {
                        var entry = processEntries_1[_i];
                        if (!entry.parsed || !htmlBuilder.isCompileScriptType(entry.parsed.type))
                            continue;
                        var content = entry.parsed.content;
                        var resolvedPath = void 0;
                        if (typeof content !== 'string' && typeof entry.parsed.reference === 'string') {
                            // reference is relative to the HTML file directory
                            resolvedPath = fileSystem.resolvePath(htmlFile.resolvedPath + '/../' + entry.parsed.reference);
                            var entryStat = fileSystem.stat(resolvedPath);
                            if (!entryStat) {
                                errors.push({
                                    code: 'File not found',
                                    message: 'Cannot read referenced file ' + resolvedPath + '.'
                                });
                            }
                            else if (entryStat.isDirectory) {
                                entry.isDirectory = true;
                                var dirContent = danfo.build.populateSourceStructure({
                                    projectPath: inputs.resolvedProjectDir,
                                    fileSystem: fileSystem,
                                    sources: [resolvedPath]
                                });
                                for (var _a = 0, _b = dirContent.sources; _a < _b.length; _a++) {
                                    var dirEntry = _b[_a];
                                    codeSources.push(dirEntry);
                                }
                            }
                            else {
                                content = fileSystem.readFile(resolvedPath);
                            }
                        }
                        if (typeof content === 'string') {
                            if (typeof resolvedPath !== 'string') {
                                resolvedPath = generateSyntheticFilePath(entry.parsed);
                                entry.syntheticResolvedFileName = resolvedPath;
                            }
                            codeEntriesByResolvedPath[resolvedPath] = entry;
                            if (entry.parsed.type === 'tsconfig')
                                entry.isTsConfig = true;
                            codeSources.push({
                                resolvedPath: resolvedPath,
                                type: entry.parsed.type,
                                stat: inputs.htmlFile.stat,
                                span: {
                                    content: content,
                                    start: entry.parsed.start + entry.parsed.originalLeadLength,
                                    length: entry.parsed.length - entry.parsed.originalLeadLength - entry.parsed.originalTrailLength
                                }
                            });
                        }
                    }
                    var unresolvedImports;
                    var externalEmits;
                    for (var _c = 0, _d = inputs.otherFiles; _c < _d.length; _c++) {
                        var src = _d[_c];
                        codeSources.push(src);
                    }
                    if (codeSources.length) {
                        var builtCode = runCodeBuilder({
                            resolvedProjectDir: inputs.resolvedProjectDir,
                            sources: codeSources,
                            handleSettings: function (settings) {
                                settings.outDir = inputs.outputDirPath;
                                return settings;
                            }
                        });
                        if (builtCode.imports) {
                            // TODO: handle imports?
                            unresolvedImports = builtCode.imports;
                        }
                        if (builtCode.errors) {
                            for (var _e = 0, _f = builtCode.errors; _e < _f.length; _e++) {
                                var err = _f[_e];
                                errors.push(err);
                            }
                        }
                        if (builtCode.emits) {
                            for (var _g = 0, _h = builtCode.emits; _g < _h.length; _g++) {
                                var emit = _h[_g];
                                var entry = codeEntriesByResolvedPath[emit.resolvedSourcePath];
                                if (!entry) {
                                    if (!externalEmits)
                                        externalEmits = [];
                                    externalEmits.push(emit);
                                }
                                else {
                                    entry.emitted = {
                                        output: emit.output,
                                        sourcemap: emit.sourcemap
                                    };
                                }
                            }
                        }
                    }
                    var _j = combineEmits(htmlContent, processEntries, externalEmits), htmlEmit = _j.htmlEmit, resources = _j.resources;
                    return {
                        htmlEmit: htmlEmit,
                        resources: resources,
                        errors: errors,
                        unresolvedImports: (unresolvedImports === null || unresolvedImports === void 0 ? void 0 : unresolvedImports.length) ? unresolvedImports : void 0
                    };
                    function extractAndProcessCssEntries() {
                        for (var _i = 0, processEntries_2 = processEntries; _i < processEntries_2.length; _i++) {
                            var entry = processEntries_2[_i];
                            if (!entry.parsed || entry.parsed.type !== 'css')
                                continue;
                            var content = entry.parsed.content;
                            if (typeof content !== 'string' && typeof entry.parsed.reference === 'string') {
                                // local to the directory containing HTML file
                                var resolvedFileName = fileSystem.resolvePath(htmlFile.resolvedPath + '/../' + entry.parsed.reference);
                                content = fileSystem.readFile(resolvedFileName);
                                if (typeof content !== 'string') {
                                    errors.push({
                                        code: 'File not found',
                                        message: 'Cannot read referenced file ' + resolvedFileName + '.'
                                    });
                                }
                            }
                            if (typeof content === 'string') {
                                var processedCSS = processCSS(content);
                                entry.emitted = {
                                    output: processedCSS
                                };
                            }
                        }
                    }
                    function generateSyntheticFilePath(parsed) {
                        if (!htmlContentLineMap)
                            htmlContentLineMap = danfo.parsing.lineMap(htmlContent);
                        var contentStart = parsed.start + parsed.originalLeadLength;
                        var firstContentChar = htmlContent.charCodeAt(contentStart);
                        if (firstContentChar === 10) {
                            contentStart++;
                        }
                        else if (firstContentChar === 13) {
                            var secondContentChar = htmlContent.charCodeAt(contentStart + 1);
                            if (secondContentChar === 10)
                                contentStart += 2;
                            else
                                contentStart++;
                        }
                        var lnch = htmlContentLineMap.getLineAndCharacter(contentStart);
                        var reference = htmlFile.resolvedPath + '.L' + lnch.ln +
                            (lnch.ch > 1 ? '-' + lnch.ch : '') +
                            (parsed.type === 'typescript' ? '.tsx' : '.js');
                        return reference;
                    }
                    function processCSS(rawCSS) {
                        // TODO: build css
                        return rawCSS;
                    }
                }
                function runCodeBuilder(inputs) {
                    if (!onDemandCodeBuilder)
                        onDemandCodeBuilder = build.code.codeBuilder({
                            fileSystem: __assign(__assign({}, fileSystem), { readFile: overrideReadFile, stat: overrideStat }),
                            precachedFixedSource: precachedFixedSnapshots
                        });
                    return onDemandCodeBuilder.build(inputs);
                    function getSyntheticFile(resolvedFilePath) {
                        for (var _i = 0, processEntries_3 = processEntries; _i < processEntries_3.length; _i++) {
                            var entry = processEntries_3[_i];
                            if (entry.syntheticResolvedFileName === resolvedFilePath && typeof entry.parsed.content === 'string')
                                return entry;
                        }
                    }
                    function overrideReadFile(filePath) {
                        var resolvedFilePath = fileSystem.resolvePath(resolvedProjectDir, filePath);
                        var entry = getSyntheticFile(resolvedFilePath);
                        if (entry)
                            return entry.parsed.content;
                        return fileSystem.readFile(filePath);
                    }
                    function overrideStat(filePath) {
                        var _a;
                        var resolvedFilePath = fileSystem.resolvePath(resolvedProjectDir, filePath);
                        var entry = getSyntheticFile(resolvedFilePath);
                        if (entry) {
                            return {
                                isDirectory: false,
                                timestamp: ((_a = htmlFile.stat) === null || _a === void 0 ? void 0 : _a.timestamp) || 0,
                                length: entry.parsed.content.length
                            };
                        }
                        return fileSystem.stat(filePath);
                    }
                }
                function combineEmits(htmlContent, processEntries, allExternalEmits) {
                    var htmlEmit = '';
                    var resources;
                    var lastChunkEnd = 0;
                    var injectAfterList;
                    var injectExternalEmitsIntoNextScript;
                    if (allExternalEmits) {
                        for (var _i = 0, allExternalEmits_1 = allExternalEmits; _i < allExternalEmits_1.length; _i++) {
                            var em = allExternalEmits_1[_i];
                            if (em.injectAfter) {
                                if (!injectAfterList)
                                    injectAfterList = [];
                                injectAfterList.push(em);
                            }
                            else {
                                if (!injectExternalEmitsIntoNextScript)
                                    injectExternalEmitsIntoNextScript = [];
                                injectExternalEmitsIntoNextScript.push(em);
                            }
                        }
                    }
                    for (var i = 0; i < processEntries.length; i++) {
                        var entry = processEntries[i];
                        addEntry(entry, i === processEntries.length - 1);
                    }
                    if (lastChunkEnd < htmlContent.length) {
                        htmlEmit += htmlContent.slice(lastChunkEnd);
                    }
                    return { htmlEmit: htmlEmit, resources: resources };
                    function needsNewLineInjection(entry) {
                        var leadText = htmlContent.slice(Math.max(0, entry.parsed.start - 15), entry.parsed.start);
                        return !leadText || regex_LF_withPossibleTrailingWhitespace_thenEOF.test(leadText);
                    }
                    function addEntry(entry, last) {
                        var _a;
                        var emitResult;
                        if (typeof ((_a = entry.emitted) === null || _a === void 0 ? void 0 : _a.output) === 'string')
                            emitResult = getEmittedEntryContent(entry, last);
                        else if (entry.isTsConfig)
                            emitResult = getTsConfigEntryContent(entry);
                        else if (entry.isDirectory)
                            emitResult = getDirectoryEntryContent(entry);
                        if (emitResult) {
                            htmlEmit +=
                                htmlContent.slice(lastChunkEnd, entry.parsed.start) +
                                    (entry.parsed.lead || '') +
                                    emitResult.output +
                                    (entry.parsed.trail || '');
                            lastChunkEnd = entry.parsed.start + entry.parsed.length;
                            addEntrySourcemap(entry, emitResult.sourcemap);
                        }
                    }
                    function getEmittedEntryContent(entry, last) {
                        var _a;
                        if (typeof ((_a = entry.emitted) === null || _a === void 0 ? void 0 : _a.output) !== 'string')
                            return; // this should be redundant
                        var injectGraciousNewLines = needsNewLineInjection(entry);
                        var shouldInjectExternalEmits = (injectExternalEmitsIntoNextScript || (last && injectAfterList)) &&
                            (!entry.parsed.type || htmlBuilder.isCompileScriptType(entry.parsed.type));
                        if (shouldInjectExternalEmits) {
                            var emits = __spreadArray(__spreadArray(__spreadArray([], (!injectExternalEmitsIntoNextScript ? [] : __spreadArray([
                                injectGraciousNewLines ? '\n' : ''
                            ], injectExternalEmitsIntoNextScript, true)), true), [
                                entry.emitted
                            ], false), (!(last && injectAfterList) ? [] :
                                injectAfterList), true);
                            injectExternalEmitsIntoNextScript = void 0;
                            if (last)
                                injectAfterList = void 0;
                            return combineExternalEmits(entry, emits);
                        }
                        if (entry.emitted.sourcemap && injectGraciousNewLines)
                            return surroundNewLinesAdjustSourcemap(entry.emitted.output, entry.emitted.sourcemap, entry);
                        else if (injectGraciousNewLines)
                            return { output: wrapNewLines(entry.emitted.output) };
                        else
                            return { output: entry.emitted.output, sourcemap: entry.emitted.sourcemap };
                    }
                    function surroundNewLinesAdjustSourcemap(output, sourcemap, entry) {
                        var needsLead = regex_leadingLineHasNonWhitespace.test(output);
                        var needsTrail = regex_trailingLineHasNonWhitespace.test(output);
                        if (!needsLead && !needsTrail) {
                            return { output: output, sourcemap: sourcemap };
                        }
                        if (needsLead) {
                            var sourcemapJson = void 0;
                            try {
                                sourcemapJson = JSON.parse(sourcemap.content);
                            }
                            catch (parseSourcemapError) {
                                return { output: output, sourcemap: sourcemap };
                            }
                            sourcemapJson.mappings = danfo.parsing.sourcemap.combineMappings([{
                                    generatedLine: 1,
                                    generatedColumn: 0,
                                    fileCount: 0,
                                    nameCount: 0,
                                    mappings: sourcemapJson.mappings
                                }]);
                            sourcemap = {
                                fileName: sourcemap.fileName,
                                content: JSON.stringify(sourcemapJson)
                            };
                        }
                        return {
                            output: (needsLead ? '\n' : '') + output + (needsTrail ? '\n' : ''),
                            sourcemap: sourcemap
                        };
                    }
                    function wrapNewLines(content) {
                        var needsLead = regex_leadingLineHasNonWhitespace.test(content);
                        var needsTrail = regex_trailingLineHasNonWhitespace.test(content);
                        if (!needsLead && needsTrail)
                            return content;
                        else
                            return (needsLead ? '\n' : '') + content + (needsTrail ? '\n' : '');
                    }
                    function getTsConfigEntryContent(entry) {
                        var injectGraciousNewLines = needsNewLineInjection(entry);
                        var output = (injectGraciousNewLines ? '\n' : '') +
                            '/* ' + entry.parsed.reference + ' */';
                        if (typeof entry.parsed.content === 'string') {
                            output =
                                '/* ' + (entry.parsed.reference || 'embedded tsconfig.json') +
                                    '\n' + entry.parsed.content.replace(/\*\//g, '*\\/') + '*/';
                        }
                        else {
                            if (typeof entry.parsed.reference === 'string') {
                                var originalContent = fileSystem.readFile(fileSystem.resolvePath(resolvedProjectDir, entry.parsed.reference));
                                if (typeof originalContent === 'string')
                                    output =
                                        '/* ' + entry.parsed.reference +
                                            '\n' + originalContent.replace(/\*\//g, '*\\/') + '*/';
                            }
                        }
                        if (injectExternalEmitsIntoNextScript) {
                            if (injectExternalEmitsIntoNextScript) {
                                var emits = __spreadArray([output], injectExternalEmitsIntoNextScript, true);
                                injectExternalEmitsIntoNextScript = void 0;
                                return combineExternalEmits(entry, emits);
                            }
                        }
                        return { output: output };
                    }
                    function getDirectoryEntryContent(entry) {
                        var injectGraciousNewLines = needsNewLineInjection(entry);
                        var header = (injectGraciousNewLines ? '\n' : '') +
                            '/* ' + (entry.parsed.reference || 'directory') + ' */';
                        if (injectExternalEmitsIntoNextScript) {
                            var emits = __spreadArray([header], injectExternalEmitsIntoNextScript, true);
                            injectExternalEmitsIntoNextScript = void 0;
                            return combineExternalEmits(entry, emits);
                        }
                        return { output: header + (injectGraciousNewLines ? '\n' : '') };
                    }
                    function addEntrySourcemap(entry, sourcemap) {
                        var _a;
                        if (sourcemap === void 0) { sourcemap = (_a = entry.emitted) === null || _a === void 0 ? void 0 : _a.sourcemap; }
                        if (sourcemap) {
                            (resources || (resources = [])).push({
                                name: sourcemap.fileName,
                                content: sourcemap.content
                            });
                        }
                    }
                    function combineExternalEmits(entry, externalEmits) {
                        var result = danfo.parsing.sourcemap.concatenate({ fileName: build.getBaseName(entry.syntheticResolvedFileName || entry.parsed.reference) }, externalEmits);
                        return typeof result === 'string' ? { output: result } : result;
                    }
                }
            }
            html.htmlBuilder = htmlBuilder;
            (function (htmlBuilder) {
                var regex_compileScriptType = /javascript|typescript|json|tsconfig|directory/i;
                function isCompileScriptType(type) {
                    return regex_compileScriptType.test(type);
                }
                htmlBuilder.isCompileScriptType = isCompileScriptType;
            })(htmlBuilder = html.htmlBuilder || (html.htmlBuilder = {}));
        })(html = build.html || (build.html = {}));
    })(build = danfo.build || (danfo.build = {}));
})(danfo || (danfo = {}));
var danfo;
(function (danfo) {
    var build;
    (function (build) {
        var regex_basename = /^.*[\/\\]([^\/\\]+)$/;
        var regex_basenameCleanup = /[\/\\]+/g;
        // const regex_slash = /\//g;
        // const regex_backslash = /\\/g;
        function getBaseName(path) {
            if (!path)
                return path;
            return path.replace(regex_basename, '$1').replace(regex_basenameCleanup, '');
        }
        build.getBaseName = getBaseName;
        // export function getRelativePath(resolvedBaseDir: string, resolvedFileName: string) {
        //   const baseDelimiter = detectDelimiter(resolvedBaseDir);
        //   const fileDelimiter = detectDelimiter(resolvedFileName);
        //   if (resolvedBaseDir === resolvedFileName)
        //     return '.';
        //   // if it's strictly nested
        //   if (resolvedFileName.indexOf(resolvedBaseDir) === 0 // path starts with base dir
        //     // but also need to make guard against situation like /basedir and /basedirlong/file,
        //     // where it's just textual match but not directory match
        //     && (resolvedBaseDir.charCodeAt(resolvedBaseDir.length - 1) === baseDelimiter
        //       || resolvedFileName.charCodeAt(resolvedBaseDir.length) === fileDelimiter)) {
        //     let result = resolvedFileName.slice(
        //       resolvedBaseDir.length +
        //       (resolvedFileName.charCodeAt(resolvedBaseDir.length) === fileDelimiter ? 1 : 0));
        //     if (fileDelimiter !== baseDelimiter)
        //       result = fileDelimiter === CharCodes.Slash ? result.replace(regex_slash, '\\') : result.replace(regex_backslash, '/');
        //   }
        //   const resolvedFileNameParts = resolvedFileName.split(fileDelimiter === CharCodes.Slash ? '/' : '\\');
        //   const resolvedProjectDirParts = resolvedBaseDir.split(baseDelimiter === CharCodes.Slash ? '/' : '\\');
        //   const result: string[] = [];
        //   for (let i = 0; i < Math.max(resolvedFileNameParts.length, resolvedProjectDirParts.length); i++) {
        //     if (!result.length && resolvedFileNameParts[i] === resolvedProjectDirParts[i])
        //       continue;
        //     if (i < resolvedProjectDirParts.length)
        //       result.unshift('..');
        //     if (i < resolvedFileNameParts.length)
        //       result.push(resolvedFileNameParts[i]);
        //   }
        //   if (result.length)
        //     return result.join(baseDelimiter === CharCodes.Slash ? '/' : '\\');
        //   else
        //     return '.';
        // }
        // function detectDelimiter(resolvedPath: string) {
        //   // Windows absolute paths start with a letter C:\file.txt or a back-slash \\desktop\share\file.txt
        //   // however C:/file.txt is also allowed
        //   // Linux absolute paths start with a forward-slash: /usr/bin/file.txt
        //   if (resolvedPath.charCodeAt(0) === CharCodes.Slash) return CharCodes.Slash;
        //   if (resolvedPath.length >= 3 &&
        //     resolvedPath.charCodeAt(1) === CharCodes.Colon &&
        //     resolvedPath.charCodeAt(2) === CharCodes.Slash) return CharCodes.Slash;
        //   else return CharCodes.Backslash;
        // }
    })(build = danfo.build || (danfo.build = {}));
})(danfo || (danfo = {}));
var danfo;
(function (danfo) {
    var build;
    (function (build) {
        function populateSourceStructure(options) {
            var topLevelEntryList = [];
            var topLevelEntriesByResolvedPath = {};
            var _a = verifyProjectPath(options.fileSystem, options.projectPath), projectDir = _a.projectDir, projectTopLevelEntry = _a.projectTopLevelEntry;
            if (projectTopLevelEntry)
                topLevelEntryList.push(projectTopLevelEntry);
            populateTopLevelEntries(options.fileSystem, projectDir, options.sources, addTopLevelEntry);
            var rootDirs = [];
            for (var _i = 0, topLevelEntryList_1 = topLevelEntryList; _i < topLevelEntryList_1.length; _i++) {
                var entry = topLevelEntryList_1[_i];
                if (entry.directoryPath) {
                    rootDirs.push(entry.directoryPath);
                }
            }
            if (!projectDir) {
                projectDir = resolveProjectDirFromRootDirs(rootDirs);
                if (projectDir)
                    lateResolveProjRelatives(options.fileSystem, projectDir, topLevelEntryList);
            }
            var missing;
            var sourceList = [];
            var topLevelHTML = false;
            var topLevelTsconfig = false;
            var topLevelPackage = false;
            for (var _b = 0, topLevelEntryList_2 = topLevelEntryList; _b < topLevelEntryList_2.length; _b++) {
                var topLevelEntry = topLevelEntryList_2[_b];
                if (topLevelEntry.type === 'missing' || topLevelEntry.type === 'unresolved-proj-relative') {
                    var missingEntry = {
                        resolvedPath: topLevelEntry.resolvedPath,
                        originalSourcePath: topLevelEntry.originalSourcePath
                    };
                    if (!missing)
                        missing = [missingEntry];
                    else
                        missing.push(missingEntry);
                }
                else if (topLevelEntry.type === 'file') {
                    var type = populateSourceStructure.inferSourceFileTypeFromExtension(topLevelEntry.originalSourcePath);
                    sourceList.push({
                        resolvedPath: topLevelEntry.resolvedPath,
                        originalSourcePath: topLevelEntry.originalSourcePath,
                        type: type,
                        stat: topLevelEntry.stat
                    });
                    if (type === 'html')
                        topLevelHTML = true;
                    else if (type === 'tsconfig')
                        topLevelTsconfig = true;
                    else if (type === 'package')
                        topLevelPackage = true;
                }
                else if (topLevelEntry.type === 'dir') {
                    var sourceFileEntries = [];
                    populateDir(topLevelEntry.resolvedPath, rootDirs.length === 1 ? 2 /* DirType.OnlyRoot */ : 1 /* DirType.Root */, projectDir || topLevelEntry.resolvedPath /* baseDirPath */, sourceFileEntries);
                    sourceList.push({
                        type: 'root-dir',
                        sourceFileEntries: sourceFileEntries
                    });
                }
            }
            var result = {
                projectDir: projectDir,
                sources: [],
                missing: missing
            };
            for (var _c = 0, sourceList_1 = sourceList; _c < sourceList_1.length; _c++) {
                var sourceEntry = sourceList_1[_c];
                if (sourceEntry.type === 'root-dir') {
                    for (var _d = 0, _e = sourceEntry.sourceFileEntries; _d < _e.length; _d++) {
                        var sourceFileEntry = _e[_d];
                        if (sourceFileEntry.type === 'html') {
                            if (topLevelHTML)
                                continue;
                            topLevelHTML = true;
                        }
                        else if (sourceFileEntry.type === 'tsconfig') {
                            if (topLevelTsconfig)
                                continue;
                            topLevelTsconfig = true;
                        }
                        else if (sourceFileEntry.type === 'package') {
                            if (topLevelPackage)
                                continue;
                            topLevelPackage = true;
                        }
                        result.sources.push(sourceFileEntry);
                    }
                }
                else {
                    result.sources.push(sourceEntry);
                }
            }
            return result;
            function addTopLevelEntry(topLevelEntry) {
                var existingTopLevelEntry = topLevelEntriesByResolvedPath[topLevelEntry.resolvedPath];
                if (existingTopLevelEntry) {
                    if (!existingTopLevelEntry.originalSourcePath && topLevelEntry.originalSourcePath)
                        existingTopLevelEntry.originalSourcePath = topLevelEntry.originalSourcePath;
                    if (!existingTopLevelEntry.directoryPath && topLevelEntry.directoryPath)
                        existingTopLevelEntry.directoryPath = topLevelEntry.directoryPath;
                }
                else {
                    topLevelEntriesByResolvedPath[topLevelEntry.resolvedPath] = topLevelEntry;
                    topLevelEntryList.push(topLevelEntry);
                }
            }
            function populateDir(dirPath, dirType, baseDirPath, populateSourceList) {
                var dirFileList = options.fileSystem.readDirectory(dirPath);
                if (!dirFileList)
                    return;
                dirFileList.sort();
                var subdirectoryList;
                var fileSourceList = [];
                var indexHTMLs;
                var otherCandidateHTMLs;
                var tsconfigs;
                var packages;
                for (var _i = 0, dirFileList_1 = dirFileList; _i < dirFileList_1.length; _i++) {
                    var file = dirFileList_1[_i];
                    var resolvedPath = options.fileSystem.resolvePath(dirPath, file);
                    var baseName = build.getBaseName(resolvedPath);
                    // don't even touch those .git entries, no point creating watch entries on them
                    if (regex_excludeDirectory.test(baseName))
                        continue;
                    var stat = options.fileSystem.stat(resolvedPath);
                    if (!stat)
                        continue;
                    if (stat.isDirectory) {
                        if (!subdirectoryList)
                            subdirectoryList = [{ resolvedPath: resolvedPath, stat: stat }];
                        else
                            subdirectoryList.push({ resolvedPath: resolvedPath, stat: stat });
                        continue;
                    }
                    var type = populateSourceStructure.inferSourceFileTypeFromExtension(resolvedPath);
                    if (dirType === 1 /* DirType.Root */ || dirType === 2 /* DirType.OnlyRoot */) {
                        if (type === 'html' || type === 'tsconfig' || type === 'package') {
                            // look out for project-level 'root' index.html and tsconfig.json
                            var source = {
                                resolvedPath: resolvedPath,
                                type: type,
                                stat: stat
                            };
                            fileSourceList.push(source);
                            if (type === 'html') {
                                var baseName_1 = build.getBaseName(resolvedPath);
                                if (regex_fileName_indexHTML.test(baseName_1)) {
                                    if (!indexHTMLs)
                                        indexHTMLs = [source];
                                    else
                                        indexHTMLs.push(source);
                                }
                                else if (regex_fileName_candidateHTML.test(baseName_1)) {
                                    if (!otherCandidateHTMLs)
                                        otherCandidateHTMLs = [source];
                                    else
                                        otherCandidateHTMLs.push(source);
                                }
                            }
                            else if (type === 'tsconfig') {
                                if (!tsconfigs)
                                    tsconfigs = [source];
                                else
                                    tsconfigs.push(source);
                            }
                            else if (type === 'package') {
                                if (!packages)
                                    packages = [source];
                                else
                                    packages.push(source);
                            }
                            continue;
                        }
                    }
                    if (type === 'javascript' || type === 'typescript') {
                        fileSourceList.push({
                            resolvedPath: resolvedPath,
                            type: type,
                            stat: stat
                        });
                    }
                }
                if (dirType === 2 /* DirType.OnlyRoot */) {
                    var codeFileCount = 0;
                    for (var _a = 0, fileSourceList_1 = fileSourceList; _a < fileSourceList_1.length; _a++) {
                        var f = fileSourceList_1[_a];
                        if (f.type === 'typescript' || f.type === 'javascript') {
                            codeFileCount++;
                        }
                        else if (f.type === 'html') {
                            var htmlCandidateBaseName = build.getBaseName(f.resolvedPath);
                            if (regex_fileName_indexHTML.test(htmlCandidateBaseName) || regex_fileName_candidateHTML.test(htmlCandidateBaseName))
                                codeFileCount++;
                        }
                    }
                    if (!codeFileCount && (subdirectoryList === null || subdirectoryList === void 0 ? void 0 : subdirectoryList.length)) {
                        // if the root dir has no source files, and has 'src' or 'sources' directory,
                        // only search that directory and ignore other sibling subdirectories
                        //
                        // [myproj]
                        //    [data] ... ignore ...
                        //    [src]  ... YES, COMPILE THIS
                        //    [test] ... ignore ...
                        //
                        var sourcesDirs = [];
                        for (var _b = 0, subdirectoryList_1 = subdirectoryList; _b < subdirectoryList_1.length; _b++) {
                            var subdir = subdirectoryList_1[_b];
                            if (regex_dirName_src.test(build.getBaseName(subdir.resolvedPath)))
                                sourcesDirs.push(subdir.resolvedPath);
                        }
                        if (sourcesDirs.length === 1) {
                            populateDir(sourcesDirs[0], 1 /* DirType.Root */, baseDirPath, populateSourceList);
                            return;
                        }
                    }
                }
                if (subdirectoryList) {
                    for (var _c = 0, subdirectoryList_2 = subdirectoryList; _c < subdirectoryList_2.length; _c++) {
                        var subdir = subdirectoryList_2[_c];
                        var exclude = options.exclude;
                        if (typeof exclude === 'function') {
                            var relativeDirectoryPath = options.fileSystem.getRelativePath(baseDirPath, subdir.resolvedPath);
                            if (exclude(subdir.resolvedPath, relativeDirectoryPath, subdir.stat))
                                continue;
                        }
                        populateDir(subdir.resolvedPath, 0 /* DirType.Any */, baseDirPath, populateSourceList);
                    }
                }
                for (var _d = 0, fileSourceList_2 = fileSourceList; _d < fileSourceList_2.length; _d++) {
                    var file = fileSourceList_2[_d];
                    if (file.type === 'html') {
                        var includeAsHTML = ((indexHTMLs === null || indexHTMLs === void 0 ? void 0 : indexHTMLs.length) === 1 && indexHTMLs[0] === file)
                            || (!indexHTMLs && (otherCandidateHTMLs === null || otherCandidateHTMLs === void 0 ? void 0 : otherCandidateHTMLs.length) === 1 && otherCandidateHTMLs[0] === file);
                        if (!includeAsHTML)
                            continue;
                    }
                    else if (file.type === 'tsconfig') {
                        var includeAsTsconfig = (tsconfigs === null || tsconfigs === void 0 ? void 0 : tsconfigs.length) === 1;
                        if (!includeAsTsconfig)
                            continue;
                    }
                    else if (file.type === 'package') {
                        var includeAsPackage = (packages === null || packages === void 0 ? void 0 : packages.length) === 1;
                        if (!includeAsPackage)
                            continue;
                    }
                    var exclude = options.exclude;
                    if (typeof exclude === 'function') {
                        var relativePath = projectDir ? options.fileSystem.getRelativePath(projectDir, file.resolvedPath) : file.resolvedPath;
                        if (exclude(file.resolvedPath, relativePath, file.stat))
                            continue;
                    }
                    populateSourceList.push(file);
                }
            }
        }
        build.populateSourceStructure = populateSourceStructure;
        function lateResolveProjRelatives(fileSystem, projectDir, topLevelEntries) {
            for (var _i = 0, topLevelEntries_1 = topLevelEntries; _i < topLevelEntries_1.length; _i++) {
                var entry = topLevelEntries_1[_i];
                if (entry.type === 'unresolved-proj-relative') {
                    entry.resolvedPath = fileSystem.resolvePath(projectDir, entry.resolvedPath);
                    entry.stat = fileSystem.stat(entry.resolvedPath);
                    if (!entry.stat) {
                        entry.type = 'missing';
                    }
                    else {
                        if (entry.stat.isDirectory) {
                            entry.type = 'dir';
                            entry.directoryPath = entry.resolvedPath;
                        }
                        else {
                            entry.type = 'file';
                            entry.directoryPath = fileSystem.resolvePath(entry.resolvedPath, '..');
                        }
                    }
                }
            }
        }
        function verifyProjectPath(fileSystem, projectPath) {
            var projectDir = projectPath;
            var projectTopLevelEntry;
            if (projectDir) {
                var originalSourcePath = projectDir;
                var resolvedPath = fileSystem.resolvePath(projectDir);
                var stat = fileSystem.stat(projectDir);
                if (!stat) {
                    projectDir = void 0;
                    projectTopLevelEntry = {
                        originalSourcePath: originalSourcePath,
                        resolvedPath: resolvedPath,
                        type: 'missing'
                    };
                }
                else {
                    if (stat.isDirectory) {
                        projectTopLevelEntry = {
                            originalSourcePath: originalSourcePath,
                            resolvedPath: resolvedPath,
                            type: 'dir',
                            directoryPath: resolvedPath,
                            stat: stat
                        };
                    }
                    else {
                        projectDir = fileSystem.resolvePath(projectDir, '..');
                        projectTopLevelEntry = {
                            originalSourcePath: originalSourcePath,
                            resolvedPath: resolvedPath,
                            type: 'file',
                            directoryPath: projectDir,
                            stat: stat
                        };
                    }
                }
            }
            return { projectDir: projectDir, projectTopLevelEntry: projectTopLevelEntry };
        }
        function populateTopLevelEntries(fileSystem, projectDir, sources, addTopLevelEntry) {
            for (var _i = 0, sources_2 = sources; _i < sources_2.length; _i++) {
                var originalSourcePath = sources_2[_i];
                var resolvedPath = void 0;
                var stripLeadingAtSlash = originalSourcePath.replace(regex_stripLeadingAtSlash, '');
                if (stripLeadingAtSlash !== originalSourcePath) {
                    if (!projectDir) {
                        addTopLevelEntry({
                            originalSourcePath: originalSourcePath,
                            resolvedPath: stripLeadingAtSlash,
                            type: 'unresolved-proj-relative'
                        });
                        continue;
                    }
                    resolvedPath = fileSystem.resolvePath(projectDir, stripLeadingAtSlash);
                }
                else {
                    resolvedPath = fileSystem.resolvePath(originalSourcePath);
                }
                var stat = fileSystem.stat(resolvedPath);
                if (!stat) {
                    addTopLevelEntry({
                        originalSourcePath: originalSourcePath,
                        resolvedPath: resolvedPath,
                        type: 'missing'
                    });
                    continue;
                }
                if (stat.isDirectory) {
                    addTopLevelEntry({
                        originalSourcePath: originalSourcePath,
                        resolvedPath: resolvedPath,
                        type: 'dir',
                        directoryPath: resolvedPath,
                        stat: stat
                    });
                }
                else {
                    var directoryPath = fileSystem.resolvePath(resolvedPath, '..');
                    addTopLevelEntry({
                        originalSourcePath: originalSourcePath,
                        resolvedPath: resolvedPath,
                        type: 'file',
                        directoryPath: directoryPath,
                        stat: stat
                    });
                }
            }
        }
        (function (populateSourceStructure) {
            function inferSourceFileTypeFromExtension(path) {
                var extMatch = regex_ext.exec(path);
                var ext = extMatch && extMatch[1] || '';
                var type = inferSourceFileTypeFromExtensionLowercase(ext) || inferSourceFileTypeFromExtensionLowercase(ext.toLowerCase());
                if (type === 'json') {
                    var baseName = build.getBaseName(path);
                    if (regex_fileName_tsconfigJSON.test(baseName))
                        return 'tsconfig';
                    else if (regex_fileName_packageJSON.test(baseName))
                        return 'package';
                }
                return type;
            }
            populateSourceStructure.inferSourceFileTypeFromExtension = inferSourceFileTypeFromExtension;
            function inferSourceFileTypeFromExtensionLowercase(ext) {
                switch (ext) {
                    case 'js':
                    case 'jsx':
                        return 'javascript';
                    case 'ts':
                    case 'tsx':
                        return 'typescript';
                    case 'css':
                        return 'css';
                    case 'html':
                    case 'htm':
                        return 'html';
                    case 'json':
                        return 'json';
                }
            }
        })(populateSourceStructure = build.populateSourceStructure || (build.populateSourceStructure = {}));
        function resolveProjectDirFromRootDirs(rootDirs) {
            if (!rootDirs.length)
                return;
            return rootDirs[0];
        }
        var regex_ext = /\.([^\.\\\/]+)$/;
        var regex_fileName_indexHTML = /^index\.htm(l?)$/i;
        var regex_fileName_candidateHTML = /^default.htm(l?)$/i;
        var regex_fileName_tsconfigJSON = /^tsconfig\.json$/i;
        var regex_fileName_packageJSON = /^package\.json$/i;
        var regex_excludeDirectory = /(^|\\|\/|\:)(node_modules|\.git|\.DS_Store)$/i;
        var regex_dirName_src = /^(src|source|sources)$/i;
        var regex_stripLeadingAtSlash = /^\@[\\\/]+/;
    })(build = danfo.build || (danfo.build = {}));
})(danfo || (danfo = {}));
var danfo;
(function (danfo) {
    var build;
    (function (build) {
        function projectBuilder(options) {
            var htmlBuilderInstance;
            var bundlerInstance;
            var firstBuild = true;
            if (options.watch !== false)
                options.trackingFileSystem.onChanges = handleChanges;
            var resolvedOutputDirPath = getOutputDirPath(options.outputPath);
            var preciseEmitPaths;
            var excludeOutputCheck = function (dirPath) {
                return (preciseEmitPaths ?
                    preciseEmitPaths.indexOf(dirPath) >= 0 :
                    dirPath.indexOf(resolvedOutputDirPath) === 0);
            };
            buildOrRebuild();
            firstBuild = false;
            function getOutputDirPath(outputPath) {
                var probePath = options.trackingFileSystem.fs.resolvePath(outputPath || 'dist');
                var stat = options.trackingFileSystem.fs.stat(probePath);
                if (!stat || stat.isDirectory)
                    return probePath;
                else
                    return options.trackingFileSystem.fs.resolvePath(probePath, '..');
            }
            function handleChanges(allChanges) {
                if (allChanges) {
                    var anyRealChanges = void 0;
                    for (var _i = 0, allChanges_1 = allChanges; _i < allChanges_1.length; _i++) {
                        var ch = allChanges_1[_i];
                        if (!excludeOutputCheck(ch)) {
                            if (!anyRealChanges)
                                anyRealChanges = [ch];
                            else
                                anyRealChanges.push(ch);
                        }
                    }
                    if (!anyRealChanges)
                        return;
                    else
                        allChanges = anyRealChanges;
                }
                buildOrRebuild({ allChanges: allChanges });
            }
            function buildOrRebuild(reason) {
                var sourceStructure = build.populateSourceStructure({
                    fileSystem: options.trackingFileSystem.fs,
                    projectPath: options.projRoot,
                    sources: options.sources,
                    exclude: excludeOutputCheck
                });
                if (!options.outputPath)
                    resolvedOutputDirPath = getOutputDirPath(sourceStructure.projectDir ? options.trackingFileSystem.fs.resolvePath(sourceStructure.projectDir, 'dist') : void 0);
                var html;
                for (var _i = 0, _a = sourceStructure.sources; _i < _a.length; _i++) {
                    var srcEntry = _a[_i];
                    if (srcEntry.type === 'html') {
                        html = srcEntry;
                        break;
                    }
                }
                if (typeof options.onBuildStart === 'function')
                    options.onBuildStart(__assign(__assign({}, sourceStructure), { outputDirPath: resolvedOutputDirPath, changes: reason && reason.allChanges, html: !!html }));
                if (html) {
                    buildForHtml(sourceStructure, html);
                }
                else {
                    if (firstBuild && typeof options.watch !== 'boolean') {
                        // no need for watching, if neither asked nor can infer from the presence of HTML
                        options.trackingFileSystem.stopWatching();
                    }
                    buildForJS(sourceStructure);
                }
            }
            function buildForJS(sourceStructure) {
                if (!bundlerInstance)
                    bundlerInstance = danfo.build.bundle.codeBundler({
                        fileSystem: options.trackingFileSystem.fs
                    });
                var buildStart = Date.now();
                var bundleBuildResult = bundlerInstance.build({
                    outputDir: resolvedOutputDirPath,
                    resolvedProjectDir: sourceStructure.projectDir || options.projRoot,
                    sources: sourceStructure.sources
                });
                if (bundleBuildResult.outputFile)
                    resolvedOutputDirPath = options.trackingFileSystem.fs.resolvePath(resolvedOutputDirPath, bundleBuildResult.outputFile + '/..');
                var emits = [];
                if (bundleBuildResult.outputFile) {
                    if (bundleBuildResult.output)
                        emits.push(createEmit(bundleBuildResult.outputFile, bundleBuildResult.output));
                    if (bundleBuildResult.sourcemap)
                        emits.push(createEmit(bundleBuildResult.sourcemap.fileName, bundleBuildResult.sourcemap.content));
                    if (bundleBuildResult.typings)
                        emits.push(createEmit(bundleBuildResult.typings.fileName, bundleBuildResult.typings.content));
                }
                var errors = concatWithMissingFileErrors(bundleBuildResult.errors, sourceStructure);
                var buildTime = Date.now() - buildStart;
                var buildResult = __assign(__assign({}, sourceStructure), { success: !!bundleBuildResult.outputFile, outputDirPath: resolvedOutputDirPath, buildTime: buildTime, html: false, emits: emits, unresolvedImports: bundleBuildResult.imports, errors: errors });
                preciseEmitPaths = emits.map(function (em) { return em.fullPath; });
                if (typeof options.onBuildFinish === 'function')
                    options.onBuildFinish(buildResult);
            }
            function buildForHtml(sourceStructure, htmlEntry) {
                if (!htmlBuilderInstance)
                    htmlBuilderInstance = danfo.build.html.htmlBuilder({
                        fileSystem: options.trackingFileSystem.fs,
                        precachedFixedSource: options.precachedFixedSource
                    });
                var buildStart = Date.now();
                var htmlBuildResults = htmlBuilderInstance.build({
                    resolvedProjectDir: sourceStructure.projectDir,
                    htmlFile: htmlEntry,
                    otherFiles: sourceStructure.sources,
                    outputDirPath: resolvedOutputDirPath
                });
                var outputHtmlPath;
                if (options.outputPath) {
                    var probePath = options.trackingFileSystem.fs.resolvePath(options.outputPath);
                    var stat = options.trackingFileSystem.fs.stat(probePath);
                    if (!stat || stat.isDirectory) {
                        outputHtmlPath = options.trackingFileSystem.fs.resolvePath(options.outputPath, build.getBaseName(htmlEntry.resolvedPath));
                    }
                    else {
                        outputHtmlPath = probePath;
                    }
                }
                else {
                    outputHtmlPath = options.trackingFileSystem.fs.resolvePath(resolvedOutputDirPath, build.getBaseName(htmlEntry.resolvedPath));
                }
                var emits = [];
                if (htmlBuildResults.htmlEmit)
                    emits.push(createEmit(outputHtmlPath, htmlBuildResults.htmlEmit));
                if (htmlBuildResults.resources) {
                    for (var _i = 0, _a = htmlBuildResults.resources; _i < _a.length; _i++) {
                        var res = _a[_i];
                        var resPath = options.trackingFileSystem.fs.resolvePath(resolvedOutputDirPath, res.name);
                        emits.push(createEmit(resPath, res.content));
                    }
                }
                var errors = concatWithMissingFileErrors(htmlBuildResults.errors, sourceStructure);
                var buildTime = Date.now() - buildStart;
                var buildResult = __assign(__assign({}, sourceStructure), { success: typeof htmlBuildResults.htmlEmit === 'string', outputDirPath: resolvedOutputDirPath, buildTime: buildTime, html: true, emits: emits, unresolvedImports: htmlBuildResults.unresolvedImports, errors: errors });
                preciseEmitPaths = emits.map(function (em) { return em.fullPath; });
                if (typeof options.onBuildFinish === 'function')
                    options.onBuildFinish(buildResult);
            }
            function createEmit(fullPath, content) {
                var localPath = options.trackingFileSystem.fs.getRelativePath(resolvedOutputDirPath, fullPath).replace(/\\/g, '/');
                if (/^\//.test(localPath))
                    localPath = localPath.slice(1);
                var currentStat = options.trackingFileSystem.fs.stat(fullPath);
                if (!currentStat || currentStat.isDirectory) {
                    return {
                        localPath: localPath,
                        fullPath: fullPath,
                        content: content,
                        changedFrom: {}
                    };
                }
                var currentContent = options.trackingFileSystem.fs.readFile(fullPath);
                return content === currentContent ?
                    {
                        localPath: localPath,
                        fullPath: fullPath,
                        content: content
                    }
                    : {
                        localPath: localPath,
                        fullPath: fullPath,
                        content: content,
                        changedFrom: {
                            timestamp: currentStat.timestamp,
                            content: currentContent
                        }
                    };
            }
        }
        build.projectBuilder = projectBuilder;
        function concatWithMissingFileErrors(errors, sourceStructure) {
            var _a;
            if ((_a = sourceStructure.missing) === null || _a === void 0 ? void 0 : _a.length) {
                errors = __spreadArray([], errors, true);
                for (var _i = 0, _b = sourceStructure.missing; _i < _b.length; _i++) {
                    var miss = _b[_i];
                    errors.push({
                        code: 'MISS',
                        message: 'Cannot find file ' + (miss.originalSourcePath || miss.resolvedPath),
                        resolvedSourcePath: miss.originalSourcePath || miss.resolvedPath
                    });
                }
            }
            return errors;
        }
    })(build = danfo.build || (danfo.build = {}));
})(danfo || (danfo = {}));
var danfo;
(function (danfo) {
    var node;
    (function (node) {
        function performScaffold() {
        }
        node.performScaffold = performScaffold;
    })(node = danfo.node || (danfo.node = {}));
})(danfo || (danfo = {}));
var danfo;
(function (danfo) {
    var node;
    (function (node) {
        var server;
        (function (server_1) {
            var extensionContentTypes;
            (function (extensionContentTypes) {
                extensionContentTypes.html = 'text/html';
                extensionContentTypes.gif = 'image/gif';
                extensionContentTypes.jpg = 'image/jpeg';
                extensionContentTypes.js = 'application/javascript';
            })(extensionContentTypes = server_1.extensionContentTypes || (server_1.extensionContentTypes = {}));
            function run(options) {
                var http = require('http');
                var URL = require('url');
                var srv = http.createServer({}, requestListener);
                srv.listen(typeof options.port === 'number' ? options.port : 8080);
                var resolvedDistDir = options.fileSystem.resolvePath(options.distDir);
                var server = {
                    distDir: options.distDir,
                    close: closeServer
                };
                return server;
                function closeServer() {
                    srv.close();
                }
                function requestListener(req, res) {
                    return __awaiter(this, void 0, void 0, function () {
                        var parsedUrl, path, resolvedPath, stat, resolvedIndexPath, indexStat, error_1;
                        return __generator(this, function (_a) {
                            switch (_a.label) {
                                case 0:
                                    _a.trys.push([0, 9, 11, 12]);
                                    resolvedDistDir = options.fileSystem.resolvePath(server.distDir);
                                    parsedUrl = URL.parse('http://' + req.headers.host + req.url);
                                    path = (parsedUrl.path || '/').replace(/^\//, '');
                                    resolvedPath = options.fileSystem.resolvePath(resolvedDistDir, path);
                                    if (!(resolvedPath.indexOf(resolvedDistDir) !== 0)) return [3 /*break*/, 2];
                                    return [4 /*yield*/, reject404(req, res, parsedUrl, resolvedPath, 'Request trying to escape beyond home directory.')];
                                case 1:
                                    _a.sent();
                                    return [2 /*return*/];
                                case 2:
                                    stat = options.fileSystem.stat(resolvedPath);
                                    if (!!stat) return [3 /*break*/, 4];
                                    return [4 /*yield*/, reject404(req, res, parsedUrl, resolvedPath)];
                                case 3:
                                    _a.sent();
                                    return [2 /*return*/];
                                case 4:
                                    if (stat.isDirectory) {
                                        resolvedIndexPath = options.fileSystem.resolvePath(resolvedPath, 'index.html');
                                        indexStat = options.fileSystem.stat(resolvedIndexPath);
                                        if (indexStat && !indexStat.isDirectory) {
                                            resolvedPath = resolvedIndexPath;
                                            stat = indexStat;
                                        }
                                    }
                                    if (!stat.isDirectory) return [3 /*break*/, 6];
                                    return [4 /*yield*/, renderDirectoryList(req, res, parsedUrl, resolvedPath)];
                                case 5:
                                    _a.sent();
                                    return [3 /*break*/, 8];
                                case 6: return [4 /*yield*/, renderFile(req, res, parsedUrl, resolvedPath)];
                                case 7:
                                    _a.sent();
                                    _a.label = 8;
                                case 8: return [3 /*break*/, 12];
                                case 9:
                                    error_1 = _a.sent();
                                    return [4 /*yield*/, wrapRequestError(error_1, req, res)];
                                case 10:
                                    _a.sent();
                                    return [3 /*break*/, 12];
                                case 11:
                                    if (typeof req.destroy === 'function' && !req.destroyed)
                                        req.destroy();
                                    if (typeof res.destroyed === 'function' && !res.destroyed)
                                        res.destroy();
                                    return [7 /*endfinally*/];
                                case 12: return [2 /*return*/];
                            }
                        });
                    });
                }
                function renderFile(req, res, parsedUrl, resolvedFilePath) {
                    return __awaiter(this, void 0, void 0, function () {
                        var buffer, ext, contentType;
                        return __generator(this, function (_a) {
                            switch (_a.label) {
                                case 0:
                                    buffer = options.fileSystem.readFile(resolvedFilePath, 'binary');
                                    if (!!buffer) return [3 /*break*/, 2];
                                    return [4 /*yield*/, reject404(req, res, parsedUrl, resolvedFilePath)];
                                case 1:
                                    _a.sent();
                                    return [2 /*return*/];
                                case 2:
                                    res.statusCode = 200;
                                    res.statusMessage = 'OK';
                                    ext = resolvedFilePath.split('.').reverse().filter(function (part) { return part; })[0];
                                    contentType = extensionContentTypes[ext];
                                    if (contentType) {
                                        res.setHeader('Content-Type', contentType);
                                    }
                                    console.log(node.colors.green + 'HTTP 200 ' + req.method + ' ' + resolvedFilePath + node.colors.reset +
                                        node.colors.brightGreen + ' ' + (contentType || ext) + ' ' + buffer.length + node.colors.reset +
                                        node.colors.green + ' byte' + (buffer.length === 1 ? '' : 's') + node.colors.reset);
                                    return [4 /*yield*/, new Promise(function (resolve) {
                                            return res.end(buffer, resolve);
                                        })];
                                case 3:
                                    _a.sent();
                                    return [2 /*return*/];
                            }
                        });
                    });
                }
                function renderDirectoryList(req, res, parsedUrl, resolvedDirPath) {
                    return __awaiter(this, void 0, void 0, function () {
                        var dirList, dirRenderHTML;
                        return __generator(this, function (_a) {
                            switch (_a.label) {
                                case 0:
                                    dirList = options.fileSystem.readDirectory(resolvedDirPath);
                                    if (!!dirList) return [3 /*break*/, 2];
                                    return [4 /*yield*/, reject404(req, res, parsedUrl, resolvedDirPath)];
                                case 1:
                                    _a.sent();
                                    return [2 /*return*/];
                                case 2:
                                    console.log(node.colors.green + 'HTTP 200 ' + req.method + ' ' + parsedUrl.path + ' -> ' + resolvedDirPath + node.colors.reset +
                                        node.colors.brightGreen + dirList.length + node.colors.reset +
                                        node.colors.green + (dirList.length === 1 ? ' entry' : 'entries') + node.colors.reset);
                                    res.statusCode = 200;
                                    res.statusMessage = 'OK';
                                    dirRenderHTML = '<html><head><title>' + resolvedDistDir + ': ' + dirList.length + ' file' + (dirList.length === 1 ? '' : 's') + '</title></head>' +
                                        '<body>' +
                                        '<h2>' + resolvedDistDir + ': ' + dirList.length + ' file' + (dirList.length === 1 ? '' : 's') + '</h2>' +
                                        '<ul>' +
                                        (resolvedDirPath === resolvedDistDir ?
                                            '' :
                                            '<li><a href="..">..</a>') +
                                        dirList.map(function (entry) {
                                            var baseName = danfo.build.getBaseName(entry);
                                            return '<li><a href="' + baseName + '">' + baseName + '</a>';
                                        }).join('\n') +
                                        '</ul>' +
                                        '</body></html>';
                                    return [4 /*yield*/, endRequestWithHTML(res, dirRenderHTML)];
                                case 3:
                                    _a.sent();
                                    return [2 /*return*/];
                            }
                        });
                    });
                }
                function reject404(req, res, parsedUrl, resolvedPath, additionalMessage) {
                    return __awaiter(this, void 0, void 0, function () {
                        var errorMessage;
                        return __generator(this, function (_a) {
                            switch (_a.label) {
                                case 0:
                                    res.statusCode = 404;
                                    errorMessage = typeof additionalMessage === 'string' ?
                                        additionalMessage + ' for ' + resolvedPath :
                                        'File not found: ' + resolvedPath;
                                    res.statusMessage = errorMessage;
                                    console.log(node.colors.green + 'HTTP ' + node.colors.reset + node.colors.red + '404 ' + node.colors.reset + node.colors.green + req.method + ' ' + parsedUrl.path + ' -> ' + resolvedPath + node.colors.reset +
                                        (additionalMessage ? ' ' + node.colors.brightGreen + additionalMessage + node.colors.reset : ''));
                                    return [4 /*yield*/, endRequestWithHTML(res, '<html><head><title>' + errorMessage + '</title><head><body>' +
                                            '<h2 style="color: firebrick">' + errorMessage + '</h2>' +
                                            'at ' + Date() +
                                            '</body></html>')];
                                case 1:
                                    _a.sent();
                                    return [2 /*return*/];
                            }
                        });
                    });
                }
                function endRequestWithHTML(res, html, contentType) {
                    if (contentType === void 0) { contentType = 'text/html'; }
                    return __awaiter(this, void 0, void 0, function () {
                        return __generator(this, function (_a) {
                            switch (_a.label) {
                                case 0:
                                    try {
                                        res.setHeader('Content-Type', contentType);
                                    }
                                    catch (error) { /* ignore content type failure */ }
                                    return [4 /*yield*/, new Promise(function (resolve) { return res.end(html, resolve); })];
                                case 1:
                                    _a.sent();
                                    return [2 /*return*/];
                            }
                        });
                    });
                }
                function wrapRequestError(error, req, res) {
                    return __awaiter(this, void 0, void 0, function () {
                        var errorMessage, secondaryError_1;
                        return __generator(this, function (_a) {
                            switch (_a.label) {
                                case 0:
                                    _a.trys.push([0, 2, 3, 4]);
                                    if (req.destroyed || res.destroyed)
                                        return [2 /*return*/];
                                    errorMessage = error && error.message ? String(error.message) :
                                        error ? String(error) :
                                            'Internal failure';
                                    res.statusCode = 500;
                                    res.statusMessage = errorMessage;
                                    console.log(node.colors.green + 'HTTP ' + node.colors.reset + node.colors.red + '500 ' + node.colors.reset + node.colors.green + req.method + ' ' + req.url + node.colors.reset +
                                        node.colors.brightGreen + ' ' + errorMessage + node.colors.reset);
                                    return [4 /*yield*/, endRequestWithHTML(res, '<html><head><title>' + errorMessage + '</title><head><body>' +
                                            '<h2 style="color: firebrick">' + errorMessage + '</h2>' +
                                            'at ' + Date() +
                                            '</body></html>')];
                                case 1:
                                    _a.sent();
                                    return [3 /*break*/, 4];
                                case 2:
                                    secondaryError_1 = _a.sent();
                                    return [3 /*break*/, 4];
                                case 3:
                                    if (typeof req.destroy === 'function' && !req.destroyed)
                                        req.destroy(error);
                                    if (typeof res.destroyed === 'function' && !res.destroyed)
                                        res.destroy(error);
                                    return [7 /*endfinally*/];
                                case 4: return [2 /*return*/];
                            }
                        });
                    });
                }
            }
            server_1.run = run;
        })(server = node.server || (node.server = {}));
    })(node = danfo.node || (danfo.node = {}));
})(danfo || (danfo = {}));
var danfo;
(function (danfo) {
    var node;
    (function (node) {
        function doNothing() { }
        function createFS(rootDir, options) {
            var changesTimeoutMS = 50;
            var recurringMissingCheckTimeoutMS = 10000;
            var fs = options && options.fs || require('fs');
            if (options && !options.fs)
                options.fs = fs;
            var path = options && options.path || require('path');
            if (options && !options.path)
                options.path = path;
            var needsWatching = true;
            var session = createSession();
            var fsWithChanges = {
                fs: {
                    basePath: path.resolve(rootDir),
                    readDirectory: readDirectory,
                    readFile: readFile,
                    getRelativePath: getRelativePath,
                    resolvePath: resolvePath,
                    stat: stat,
                    writeFile: writeFile
                },
                next: next,
                stopWatching: stopWatching
            };
            return fsWithChanges;
            function stopWatching() {
                if (!needsWatching)
                    return;
                needsWatching = false;
                if (session.watchingMap) {
                    for (var k in session.watchingMap) {
                        var entry = session.watchingMap[k];
                        if (entry && typeof entry.close === 'function')
                            entry.close();
                    }
                    session.watchingMap = {};
                }
                if (session.recurringMissingCheckTimeout) {
                    clearTimeout(session.recurringMissingCheckTimeout);
                    session.recurringMissingCheckTimeout = void 0;
                }
            }
            function createSession() {
                return {
                    watchingMap: {},
                    allChangesList: [],
                    onChangesTimeout: null,
                    recurringMissingCheckTimeout: null
                };
            }
            function readDirectory(dirPath) {
                var resolvedFullDirPath = resolvePath(dirPath);
                watchPath(resolvedFullDirPath);
                try {
                    var dirFiles = fs.readdirSync(resolvedFullDirPath);
                    var resolvedResults = [];
                    for (var _i = 0, dirFiles_1 = dirFiles; _i < dirFiles_1.length; _i++) {
                        var f = dirFiles_1[_i];
                        var res = path.normalize(path.resolve(resolvedFullDirPath, f));
                        resolvedResults.push(res);
                    }
                    return resolvedResults;
                }
                catch (noAccessOrDoesNotExist) {
                }
            }
            function readFile(filePath, encoding) {
                var resolvedFullPath = resolvePath(filePath);
                watchPath(resolvedFullPath);
                try {
                    if (encoding === 'binary')
                        return fs.readFileSync(resolvedFullPath);
                    var buf = fs.readFileSync(resolvedFullPath, { encoding: encoding });
                    return buf.toString(encoding || 'utf8');
                }
                catch (noAccessOrDoesNotExist) { }
            }
            function writeFile(filePath, data, encoding) {
                var resolvedFullPath = resolvePath(filePath);
                fs.writeFileSync(resolvedFullPath, data, encoding);
                unwatchPathOnWrite(filePath, data.length);
            }
            function getRelativePath(resolvedBaseDir, resolvedFileName) {
                return path.relative(resolvedBaseDir, resolvedFileName);
            }
            function resolvePath(path1, path2) {
                // note a forced normalize is required (is it only on some versions?)
                var resolvedPath = path.normalize(path2 ? path.resolve(fsWithChanges.fs.basePath, path1, path2) :
                    path.resolve(fsWithChanges.fs.basePath, path1));
                return resolvedPath;
            }
            function stat(filePath) {
                var resolvedFullPath = resolvePath(filePath);
                var stat = watchPath(resolvedFullPath);
                // console.log('stat(', filePath, ') ', stat);
                return stat;
            }
            function next() {
                if (!needsWatching)
                    return;
                if (session.onChangesTimeout) {
                    clearTimeout(session.onChangesTimeout);
                    session.onChangesTimeout = null;
                }
                for (var resolveFullPath in session.watchingMap) {
                    var entry = session.watchingMap[resolveFullPath];
                    if (entry && typeof entry.close === 'function') {
                        try {
                            entry.close();
                        }
                        catch (_a) { }
                    }
                }
                session = createSession();
            }
            function deriveTimestamp(fsStat) {
                var timestampM = statTimestamp(fsStat.mtimeMs, fsStat.mtime);
                var timestampC = statTimestamp(fsStat.ctimeMs, fsStat.ctime);
                var timestampBirth = statTimestamp(fsStat.birthtimeMs, fsStat.birthtime);
                return Math.max(timestampM, timestampC, timestampBirth);
            }
            function statTimestamp(xtimeMs, xtime) {
                if (typeof xtimeMs === 'number')
                    return xtimeMs;
                else if (xtime && typeof xtime.getTime === 'function')
                    return xtime.getTime();
                return null;
            }
            function watchPath(resolvedFullPath, refreshStat) {
                if (!needsWatching) {
                    try {
                        return statDirect(resolvedFullPath);
                    }
                    catch (_a) {
                        return;
                    }
                }
                var existingWatchingEntry = session.watchingMap[resolvedFullPath];
                if (existingWatchingEntry) {
                    if (!refreshStat && existingWatchingEntry.latestStat && !existingWatchingEntry.changed)
                        return existingWatchingEntry.latestStat;
                    try {
                        var currentStat_1 = statDirect(resolvedFullPath);
                        if (currentStat_1 && !existingWatchingEntry.latestStat)
                            existingWatchingEntry.latestStat = currentStat_1;
                        return currentStat_1;
                    }
                    catch (_b) {
                        watchNoteMissing(resolvedFullPath);
                        return;
                    }
                }
                var currentStat;
                var fsWatcher;
                var entry;
                try {
                    currentStat = statDirect(resolvedFullPath);
                    fsWatcher = fs.watch(resolvedFullPath, { recursive: false }, function (event, filename) {
                        if (entry) {
                            if (!entry.changed) {
                                entry.changed = true;
                                session.allChangesList.push(resolvedFullPath);
                            }
                            queueOnChanges();
                        }
                    });
                }
                catch (statError) {
                    if (fsWatcher)
                        fsWatcher.close();
                    watchNoteMissing(resolvedFullPath);
                    return;
                }
                entry = {
                    close: closeWatcher,
                    changed: false,
                    missing: false,
                    latestStat: currentStat
                };
                session.watchingMap[resolvedFullPath] = entry;
                return currentStat;
                function closeWatcher() {
                    if (fsWatcher)
                        fsWatcher.close();
                    entry.close = doNothing;
                }
            }
            function unwatchPathOnWrite(resolvedFullPath, length) {
                if (!needsWatching)
                    return;
                var latestStat = {
                    isDirectory: false,
                    length: length,
                    timestamp: Date.now()
                };
                var existingWatchingEntry = session.watchingMap[resolvedFullPath];
                if (existingWatchingEntry) {
                    existingWatchingEntry.changed = false;
                    existingWatchingEntry.latestStat = latestStat;
                    existingWatchingEntry.close();
                }
                else {
                    var entry = {
                        close: doNothing,
                        changed: false,
                        missing: false,
                        latestStat: latestStat
                    };
                    session.watchingMap[resolvedFullPath] = entry;
                }
            }
            function queueOnChanges() {
                if (session.onChangesTimeout)
                    clearTimeout(session.onChangesTimeout);
                session.onChangesTimeout = setTimeout(invokeOnChanges, changesTimeoutMS);
            }
            function invokeOnChanges() {
                session.onChangesTimeout = null;
                var arg = session.allChangesList;
                if (typeof fsWithChanges.onChanges === 'function') {
                    // reset changes for the next watch result
                    session.allChangesList = [];
                    for (var key in session.watchingMap) {
                        var entry = session.watchingMap[key];
                        if (entry && entry.changed) {
                            entry.changed = false;
                            entry.latestStat = void 0;
                        }
                    }
                    fsWithChanges.onChanges(arg);
                }
            }
            function watchNoteMissing(resolvedFullPath) {
                var entry = session.watchingMap[resolvedFullPath];
                if (entry && entry.missing)
                    return;
                {
                    // walk up the directories until not missing anymore
                    // (to avoid watching many missing paths within the same missing directory)
                    while (true) {
                        var parentPath = path.dirname(resolvedFullPath);
                        if (!parentPath || parentPath === resolvedFullPath || parentPath === '/') {
                            break;
                        }
                        var parentEntry = session.watchingMap[parentPath];
                        if (parentEntry) {
                            if (parentEntry.missing)
                                return;
                            resolvedFullPath = resolvedFullPath;
                            break;
                        }
                        else {
                            if (fs.existsSync(parentPath))
                                break;
                        }
                        resolvedFullPath = parentPath;
                    }
                }
                if (entry && typeof entry.close === 'function') {
                    try {
                        entry.close();
                    }
                    catch (_a) { }
                }
                if (entry) {
                    entry.missing = true;
                }
                else {
                    entry = {
                        changed: false,
                        missing: true,
                        close: doNothing
                    };
                    session.watchingMap[resolvedFullPath] = entry;
                }
                entry.missing = true;
                if (session.recurringMissingCheckTimeout)
                    clearTimeout(session.recurringMissingCheckTimeout);
                session.recurringMissingCheckTimeout = setTimeout(retryMissing, recurringMissingCheckTimeoutMS);
            }
            function retryMissing() {
                session.recurringMissingCheckTimeout = null;
                for (var resolvedFullPath in session.watchingMap) {
                    var entry = session.watchingMap[resolvedFullPath];
                    if (entry && entry.missing) {
                        try {
                            var renewedStat = statDirect(resolvedFullPath);
                            entry.missing = false;
                            if (!entry.changed) {
                                session.allChangesList.push(resolvedFullPath);
                                // TODO: maybe even restart watching?
                                queueOnChanges();
                            }
                        }
                        catch (missingAgain) {
                            // OK, do nothing...
                        }
                    }
                }
                clearTimeout(session.recurringMissingCheckTimeout);
                session.recurringMissingCheckTimeout = setTimeout(retryMissing, recurringMissingCheckTimeoutMS);
            }
            function statDirect(resolvedFullPath) {
                var fsStat = fs.statSync(resolvedFullPath);
                return {
                    isDirectory: fsStat.isDirectory(),
                    length: fsStat.size,
                    timestamp: deriveTimestamp(fsStat) || 0
                };
            }
        }
        node.createFS = createFS;
    })(node = danfo.node || (danfo.node = {}));
})(danfo || (danfo = {}));
var danfo;
(function (danfo) {
    function runWorker() {
    }
    danfo.runWorker = runWorker;
})(danfo || (danfo = {}));
var danfo;
(function (danfo) {
    var node;
    (function (node) {
        for (var k in danfo.node) {
            if (k in bootNode)
                continue;
            bootNode[k] = danfo.node[k];
        }
        danfo.node = bootNode;
        node = bootNode;
        function bootNode() {
            var _a;
            if (!((_a = process === null || process === void 0 ? void 0 : process.stdout) === null || _a === void 0 ? void 0 : _a.isTTY)) {
                for (var k in node.colors) {
                    if (typeof node.colors[k] === 'string')
                        node.colors[k] = '';
                }
            }
            var cmdline;
            {
                var cmd = danfo.parsing.cmdline.parseCmdline(process);
                if (!cmd) {
                    // must have been invoked as a library, not a command line tool
                    return;
                }
                if (cmd === 'worker')
                    return danfo.runWorker();
                else
                    cmdline = cmd;
            }
            console.log(node.colors.yellow + '🚌 𝒹𝒶𝓃𝒻𝑜 v' + danfo.versionStr + node.colors.reset);
            if (cmdline.dumpCmdLine) {
                var _dumpCmdline = __assign({}, cmdline);
                if (_dumpCmdline.packageJson)
                    _dumpCmdline.packageJson = '{...}';
                console.log('cmdline ', _dumpCmdline);
            }
            if (cmdline.knownArguments && cmdline.knownArguments.help) {
                console.log(node.helpText());
            }
            if (cmdline.knownArguments && cmdline.knownArguments.version) {
                console.log(danfo.versionStr);
            }
            if (cmdline.errors) {
                for (var i = 0; i < cmdline.errors.length; i++) {
                    console.log(node.colors.red + 'ERROR ' + cmdline.errors[i] + node.colors.reset);
                }
                process.exit(1); // error exit code 1
                return;
            }
            runAsync().then(function () {
                // TODO: finished.
            }, function (error) {
                console.error(error);
                process.exit(2); // error exit code 2 (crash not just incorrect arguments)
            });
            return;
            function runAsync() {
                var _a;
                return __awaiter(this, void 0, void 0, function () {
                    // END of runAsync here
                    function startServer(fileSystem, projDir, outputDirPath) {
                        if (serverUp)
                            return serverUp;
                        var host = (cmdline.server ? cmdline.server.host : void 0) || 'localhost';
                        var port = (cmdline.server ? cmdline.server.port : void 0) || danfo.parsing.cmdline.derivePort(projDir);
                        var options = {
                            distDir: outputDirPath,
                            fileSystem: fileSystem,
                            projectDir: cmdline.projRoot || '.',
                            host: host,
                            port: port
                        };
                        var server = danfo.node.server.run(options);
                        process.stdout.write(' ' + node.colors.brightBlue + ((cmdline.server ? cmdline.server.https : false) ? 'https://' : 'http://') + options.host + ':' + options.port + '/' + node.colors.reset);
                        return { options: options, server: server };
                    }
                    function createParentDirectoryRecursive(filePath) {
                        var path = require('path');
                        var fs = require('fs');
                        var dirPath = path.dirname(filePath);
                        if (fs.existsSync(dirPath))
                            return;
                        createParentDirectoryRecursive(dirPath);
                        fs.mkdirSync(dirPath);
                    }
                    var serverUp, startRootDir_1, trackingFileSystem_1, nonTrackingFileSystem_1, firstBuild_1, fs;
                    return __generator(this, function (_b) {
                        if (cmdline.scaffold) {
                            node.performScaffold();
                        }
                        if (cmdline.build) {
                            startRootDir_1 = npmLifecycleCurrentDirectory();
                            trackingFileSystem_1 = node.createFS(startRootDir_1);
                            nonTrackingFileSystem_1 = node.createFS(startRootDir_1);
                            nonTrackingFileSystem_1.stopWatching();
                            firstBuild_1 = true;
                            fs = require('fs');
                            danfo.build.projectBuilder({
                                projRoot: cmdline.projRoot ||
                                    (((_a = cmdline.sources) === null || _a === void 0 ? void 0 : _a.length) ? void 0 : startRootDir_1), // if neither sources nor project root specified, use current directory
                                trackingFileSystem: trackingFileSystem_1,
                                sources: cmdline.sources || [],
                                outputPath: cmdline.outputPath,
                                watch: cmdline.watch,
                                onBuildStart: function (buildContext) {
                                    if (firstBuild_1) {
                                        if (cmdline.server) {
                                            var projectDirWithFallback = buildContext.projectDir || startRootDir_1;
                                            nonTrackingFileSystem_1.fs.basePath = projectDirWithFallback;
                                            serverUp = startServer(nonTrackingFileSystem_1.fs, projectDirWithFallback, buildContext.outputDirPath);
                                        }
                                        process.stdout.write(node.colors.cyan + 'Build...' + node.colors.reset);
                                    }
                                    else {
                                        var changes = [];
                                        if (buildContext.changes) {
                                            for (var _i = 0, _a = buildContext.changes; _i < _a.length; _i++) {
                                                var ch = _a[_i];
                                                if (ch)
                                                    changes.push(ch);
                                            }
                                        }
                                        var maxChangeOneLine = 3;
                                        var maxChangeCount = 5;
                                        if (!changes.length) {
                                            process.stdout.write('\n' + node.colors.cyan + 'Rebuild [unknown changes]...' + node.colors.reset);
                                        }
                                        else if (changes.length <= maxChangeOneLine) {
                                            var filenames = [];
                                            for (var _b = 0, _c = buildContext.changes; _b < _c.length; _b++) {
                                                var ch = _c[_b];
                                                filenames.push(node.colors.brightCyan + danfo.build.getBaseName(ch).replace(/\\/g, '/')) + node.colors.reset;
                                            }
                                            var rebuildText = '\n' + node.colors.cyan + 'Rebuild [' + node.colors.reset + filenames.join(node.colors.cyan + ', ' + node.colors.reset) + node.colors.cyan + ' changed]...' + node.colors.reset;
                                            process.stdout.write(rebuildText);
                                        }
                                        else {
                                            var rebuildText = '\n' + node.colors.cyan + 'Rebuild [' + node.colors.brightCyan + buildContext.changes.length + node.colors.cyan + ' changes]:' + node.colors.reset;
                                            for (var i = 0; i < maxChangeCount; i++) {
                                                var moreLast = i < changes.length && i === maxChangeCount - 1;
                                                var ch = buildContext.changes[moreLast ? buildContext.changes.length - 1 : i];
                                                var relPath = trackingFileSystem_1.fs.getRelativePath(buildContext.projectDir || trackingFileSystem_1.fs.basePath, ch).replace(/\\/g, '/');
                                                var lastSlashPos = relPath.lastIndexOf('/');
                                                var lead = lastSlashPos >= 0 ? relPath.slice(0, lastSlashPos + 1) : '';
                                                var trail = lastSlashPos >= 0 ? relPath.slice(lastSlashPos + 1) : relPath;
                                                rebuildText += '\n  ' + node.colors.cyan + '< ' + (moreLast ? '... ' : '') + lead + node.colors.brightCyan + trail + node.colors.reset;
                                            }
                                            rebuildText += '\n' + node.colors.cyan + '  ...' + node.colors.reset;
                                            process.stdout.write(rebuildText);
                                        }
                                    }
                                },
                                onBuildFinish: function (buildContext) {
                                    var projectDirWithFallback = buildContext.projectDir || startRootDir_1;
                                    nonTrackingFileSystem_1.fs.basePath = projectDirWithFallback;
                                    if (serverUp) {
                                        serverUp.server.distDir = buildContext.outputDirPath;
                                    }
                                    if (firstBuild_1) {
                                        if (buildContext.html && cmdline.server !== false)
                                            serverUp = startServer(nonTrackingFileSystem_1.fs, projectDirWithFallback, buildContext.outputDirPath);
                                        // TODO: whatever else (start browser maybe?)
                                    }
                                    firstBuild_1 = false;
                                    var builtText = ' ' + node.colors.cyan + ((buildContext.buildTime / 100) | 0) / 10 + 's.' + node.colors.reset;
                                    if (buildContext.errors.length) {
                                        builtText += '\n' + node.colors.red + '>> ' + (buildContext.errors.length === 1 ? 'ERROR' : buildContext.errors.length + ' ERRORS') + ' <<' + node.colors.reset;
                                        for (var _i = 0, _a = buildContext.errors; _i < _a.length; _i++) {
                                            var err = _a[_i];
                                            if (typeof err.format === 'function') {
                                                builtText += '\n' + err.format();
                                            }
                                            else {
                                                builtText += '\n' + err.message;
                                            }
                                        }
                                    }
                                    if (buildContext.emits.length) {
                                        for (var _b = 0, _c = buildContext.emits; _b < _c.length; _b++) {
                                            var em = _c[_b];
                                            var path = (buildContext.projectDir ? trackingFileSystem_1.fs.getRelativePath(buildContext.projectDir, em.fullPath) : em.localPath)
                                                .replace(/\\/g, '/');
                                            if (!em.changedFrom) {
                                                builtText += '\n' + node.colors.grey + '  > ' + path + ' (no change)' + node.colors.reset;
                                            }
                                            else {
                                                if (typeof em.changedFrom.content !== 'string') {
                                                    builtText += '\n  > ' + path + ' > NEW';
                                                }
                                                else {
                                                    builtText += '\n  > ' + path + ' > CHANGED' + node.colors.grey + ' AFTER ' + (((Date.now() - em.changedFrom.timestamp) / 100) | 0) / 10 + 's' + node.colors.reset;
                                                }
                                                createParentDirectoryRecursive(em.fullPath);
                                                trackingFileSystem_1.fs.writeFile(em.fullPath, em.content);
                                            }
                                        }
                                    }
                                    console.log(builtText);
                                }
                            });
                        }
                        return [2 /*return*/];
                    });
                });
            }
        }
    })(node = danfo.node || (danfo.node = {}));
    function npmLifecycleCurrentDirectory() {
        return (process.env.INIT_CWD ||
            (process.env.npm_lifecycle_event ?
                require('path').resolve(__dirname, '../..') :
                process.cwd()));
    }
})(danfo || (danfo = {}));
var danfo;
(function (danfo) {
    var node;
    (function (node) {
        node.colors = {
            grey: '\x1b[90;1m\x1b[38;5;238m',
            red: '\x1b[31m',
            green: '\x1b[32m',
            yellow: '\x1b[33m',
            cyan: '\x1b[36m\x1b[38;5;30m',
            brightGreen: '\x1b[92m',
            brightBlue: '\x1b[94m',
            brightCyan: '\x1b[96m\x1b[38;5;51m',
            reset: '\x1b[0m'
        };
    })(node = danfo.node || (danfo.node = {}));
})(danfo || (danfo = {}));
var danfo;
(function (danfo) {
    var node;
    (function (node) {
        function formatBuildError(err, _a) {
            var typescriptForFormatting = _a.typescriptForFormatting, fileSystem = _a.fileSystem, projRoot = _a.projRoot;
            if (err.typescriptDetails) {
                try {
                    if (!typescriptForFormatting)
                        typescriptForFormatting = require('typescript');
                    var formatted = typescriptForFormatting.formatDiagnosticsWithColorAndContext([err.typescriptDetails], {
                        getCanonicalFileName: function (file) { return fileSystem.resolvePath(file); },
                        getCurrentDirectory: function () { return projRoot; },
                        getNewLine: function () { return '\n'; }
                    }).replace(/^\n+/, '').replace(/\n+$/, '');
                    return formatted;
                }
                catch (tsFormatError) { }
            }
            return err.code + ' ' + err.message;
        }
        node.formatBuildError = formatBuildError;
    })(node = danfo.node || (danfo.node = {}));
})(danfo || (danfo = {}));
var danfo;
(function (danfo) {
    var node;
    (function (node) {
        function helpText() {
            return '';
        }
        node.helpText = helpText;
    })(node = danfo.node || (danfo.node = {}));
})(danfo || (danfo = {}));
var danfo;
(function (danfo) {
    var node;
    (function (node) {
        function startBrowser(url) {
            return __awaiter(this, void 0, void 0, function () {
                return __generator(this, function (_a) {
                    return [2 /*return*/];
                });
            });
        }
        node.startBrowser = startBrowser;
    })(node = danfo.node || (danfo.node = {}));
})(danfo || (danfo = {}));
var danfo;
(function (danfo) {
    var parsing;
    (function (parsing) {
        var cmdline;
        (function (cmdline) {
            function derivePort(projRoot) {
                return 4500 + Math.abs(derivePort.strHashCode(projRoot)) % 5000;
            }
            cmdline.derivePort = derivePort;
            (function (derivePort) {
                function strHashCode(str) {
                    var sum = 127653294848;
                    for (var i = 0; i < str.length; i++) {
                        sum = ((sum << 5) - sum) + str.charCodeAt(i);
                        sum = sum & sum;
                    }
                    return sum;
                }
                derivePort.strHashCode = strHashCode;
            })(derivePort = cmdline.derivePort || (cmdline.derivePort = {}));
        })(cmdline = parsing.cmdline || (parsing.cmdline = {}));
    })(parsing = danfo.parsing || (danfo.parsing = {}));
})(danfo || (danfo = {}));
var danfo;
(function (danfo) {
    var parsing;
    (function (parsing) {
        var cmdline;
        (function (cmdline) {
            function parseCmdline(process) {
                var _a, _b, _c, _d, _e, _f, _g, _h, _j, _k, _l, _m, _o, _p;
                var argv = process.argv.slice();
                if (/^node(\.exe)?$/i.test(danfo.build.getBaseName(argv[0] || '')))
                    argv.shift();
                if (/^danfo(\.js)?$/i.test(danfo.build.getBaseName(argv[0])))
                    argv.shift();
                else
                    return; // only run in command line mode when started as 'danfo'
                if (argv.length === 1 && argv[0] === '--worker')
                    return 'worker';
                var argsParsed = parseCmdline.parseArgs(argv);
                var projRoot = (_a = argsParsed.knownArguments) === null || _a === void 0 ? void 0 : _a.projRoot;
                if (process.env.npm_lifecycle_event === 'postinstall' || process.env.npm_lifecycle_event === 'install') {
                    // TODO: trigger check for scaffolding?
                    return resultNpmLifecycleDoNothing();
                }
                // else if (process.env.npm_lifecycle_event) {
                //   console.log('npm_lifecycle_event ', process.env.npm_lifecycle_event);
                //   return resultNpmLifecycleDoNothing();
                // }
                var printAndExit = argsParsed.errors ||
                    (argsParsed.knownArguments && (argsParsed.knownArguments.help || argsParsed.knownArguments.version));
                if (printAndExit) {
                    return {
                        projRoot: projRoot,
                        scaffold: false,
                        server: void 0,
                        startBrowser: false,
                        build: false,
                        watch: false,
                        dumpCmdLine: (_c = (_b = argsParsed.knownArguments) === null || _b === void 0 ? void 0 : _b.dumpCmdLine) !== null && _c !== void 0 ? _c : false,
                        outputPath: argsParsed.knownArguments &&
                            argsParsed.knownArguments.outPath,
                        sources: argsParsed.unknownArguments,
                        knownArguments: argsParsed.knownArguments,
                        errors: argsParsed.errors
                    };
                }
                if ((_d = argsParsed.unknownArguments) === null || _d === void 0 ? void 0 : _d.length) {
                    return {
                        projRoot: projRoot,
                        scaffold: false,
                        server: (_e = argsParsed.knownArguments) === null || _e === void 0 ? void 0 : _e.serverAndPort,
                        startBrowser: true,
                        build: typeof ((_f = argsParsed.knownArguments) === null || _f === void 0 ? void 0 : _f.build) === 'boolean' ? argsParsed.knownArguments.build : true,
                        watch: (_g = argsParsed.knownArguments) === null || _g === void 0 ? void 0 : _g.watch,
                        dumpCmdLine: (_j = (_h = argsParsed.knownArguments) === null || _h === void 0 ? void 0 : _h.dumpCmdLine) !== null && _j !== void 0 ? _j : false,
                        outputPath: argsParsed.knownArguments &&
                            argsParsed.knownArguments.outPath,
                        sources: argsParsed.unknownArguments,
                        knownArguments: argsParsed.knownArguments,
                        errors: argsParsed.errors
                    };
                }
                else {
                    return {
                        projRoot: projRoot,
                        scaffold: void 0,
                        server: (_k = argsParsed.knownArguments) === null || _k === void 0 ? void 0 : _k.serverAndPort,
                        startBrowser: void 0,
                        build: typeof ((_l = argsParsed.knownArguments) === null || _l === void 0 ? void 0 : _l.build) === 'boolean' ? argsParsed.knownArguments.build : true,
                        watch: (_m = argsParsed.knownArguments) === null || _m === void 0 ? void 0 : _m.watch,
                        dumpCmdLine: (_p = (_o = argsParsed.knownArguments) === null || _o === void 0 ? void 0 : _o.dumpCmdLine) !== null && _p !== void 0 ? _p : false,
                        outputPath: argsParsed.knownArguments &&
                            argsParsed.knownArguments.outPath,
                        sources: argsParsed.unknownArguments,
                        knownArguments: argsParsed.knownArguments,
                        errors: argsParsed.errors
                    };
                }
                function resultNpmLifecycleDoNothing() {
                    return {
                        projRoot: projRoot,
                        scaffold: false,
                        server: void 0,
                        startBrowser: false,
                        build: false,
                        watch: false,
                        dumpCmdLine: false,
                        emptyDirectory: false,
                        defaultTarget: false
                    };
                }
            }
            cmdline.parseCmdline = parseCmdline;
            (function (parseCmdline) {
                var regexp_false = /^(false|no|not|off|\-|disabled|disable)$/i;
                var regexp_true = /^(true|yes|on|\+|enabled|enable)$/i;
                function parseArgs(argv) {
                    var unknownArguments = [];
                    var knownArguments;
                    var errors = [];
                    for (var i = 0; i < argv.length; i++) {
                        var arg = argv[i];
                        if (/^(--|-|\/)?scaffold$/i.test(arg)) {
                            if (i + 1 < argv.length && /^true$/i.test(argv[i + 1])) {
                                if (!knownArguments)
                                    knownArguments = {};
                                knownArguments.scaffold = true;
                                i++;
                            }
                            else if (i + 1 < argv.length && /^false$/i.test(argv[i + 1])) {
                                if (!knownArguments)
                                    knownArguments = {};
                                knownArguments.scaffold = false;
                                i++;
                            }
                            if (!knownArguments)
                                knownArguments = {};
                            knownArguments.scaffold = true;
                            continue;
                        }
                        var scaffoldArgMatch = /^(--|-|\/)?scaffold(\:|\=)(true|false)$/i.exec(arg);
                        if (scaffoldArgMatch && /true/i.test(scaffoldArgMatch[3])) {
                            if (!knownArguments)
                                knownArguments = {};
                            knownArguments.scaffold = true;
                            continue;
                        }
                        else if (scaffoldArgMatch && /false/i.test(scaffoldArgMatch[3])) {
                            if (!knownArguments)
                                knownArguments = {};
                            knownArguments.scaffold = false;
                            continue;
                        }
                        var dumpCmdLine = /^(--|-|\/)?(cmdline|dumpcmdline|dumpcmd|dmpcmd)$/i.exec(arg);
                        if (dumpCmdLine) {
                            if (!knownArguments)
                                knownArguments = {};
                            knownArguments.dumpCmdLine = true;
                            continue;
                        }
                        var portArgMatch = /^(--|-|\/)?(port|serve|server)$/i.exec(arg);
                        if (portArgMatch) {
                            var hostAndPort = void 0;
                            var enabled = true;
                            if (i + 1 < argv.length && /^[^\-\/]$/i.test(argv[i + 1])) {
                                var parsedEnabled = parseCmdline.parseBoolean(argv[i + 1]);
                                if (typeof parsedEnabled === 'boolean') {
                                    enabled = parsedEnabled;
                                    i++;
                                }
                                else if ((hostAndPort = parseHostAndPort(argv[i + 1]))) {
                                    if (!knownArguments)
                                        knownArguments = {};
                                    knownArguments.serverAndPort = __assign(__assign({}, knownArguments.serverAndPort), hostAndPort);
                                    i++;
                                }
                            }
                            else if (/port/i.test(portArgMatch[2])) {
                                errors.push('port option requires numeric parameter');
                                continue;
                            }
                            if (!knownArguments)
                                knownArguments = {};
                            if (!knownArguments.serverAndPort)
                                knownArguments.serverAndPort = enabled ? {} : false;
                            continue;
                        }
                        portArgMatch = /^(--|-|\/)?(port|serve|server)(\:|\=)(.+)$/i.exec(arg);
                        if (portArgMatch) {
                            var enabled = parseCmdline.parseBoolean(portArgMatch[4]);
                            if (typeof enabled !== 'boolean') {
                                var hostAndPort = parseHostAndPort(portArgMatch[4]);
                                if (hostAndPort) {
                                    if (!knownArguments)
                                        knownArguments = {};
                                    knownArguments.serverAndPort = __assign(__assign({}, knownArguments.serverAndPort), hostAndPort);
                                    continue;
                                }
                                else {
                                    errors.push('incorrect host/port parameter: ' + portArgMatch[4]);
                                    continue;
                                }
                            }
                            if (!knownArguments)
                                knownArguments = {};
                            if (!knownArguments.serverAndPort)
                                knownArguments.serverAndPort = enabled ? {} : false;
                            continue;
                        }
                        var watchMatch = /^(--|-|\/)?(w|watch)$/i.exec(arg);
                        if (watchMatch) {
                            var watch = true;
                            if (i + 1 < argv.length && /^[^\-\/]$/i.test(argv[i + 1])) {
                                var parsedWatch = parseCmdline.parseBoolean(argv[i + 1]);
                                if (typeof parsedWatch === 'boolean') {
                                    watch = parsedWatch;
                                    i++;
                                }
                            }
                            if (!knownArguments)
                                knownArguments = {};
                            knownArguments.watch = watch;
                            continue;
                        }
                        watchMatch = /^(--|-|\/)?(nw|nowatch)$/i.exec(arg);
                        if (watchMatch) {
                            if (!knownArguments)
                                knownArguments = {};
                            knownArguments.watch = false;
                            continue;
                        }
                        watchMatch = /^(--|-|\/)?(w|watch)(\:|\=)([a-z\+\-]+)$/i.exec(arg);
                        if (watchMatch) {
                            var watchMatchArg = parseCmdline.parseBoolean(watchMatch[4]);
                            if (typeof watchMatchArg === 'boolean') {
                                if (!knownArguments)
                                    knownArguments = {};
                                knownArguments.watch = watchMatchArg;
                                continue;
                            }
                        }
                        var outputArgMatch = /^(--|-|\/)?(o|out|output|outdir|dist)(\:|\=)?$/i.exec(arg);
                        if (outputArgMatch) {
                            if (i + 1 < argv.length) {
                                if (!knownArguments)
                                    knownArguments = {};
                                knownArguments.outPath = argv[i + 1];
                                i++;
                                continue;
                            }
                        }
                        outputArgMatch = /^(--|-|\/)?(o|out|output|outdir|dist)(\:|\=)(.+)$/i.exec(arg);
                        if (outputArgMatch) {
                            if (!knownArguments)
                                knownArguments = {};
                            knownArguments.outPath = outputArgMatch[4];
                            continue;
                        }
                        {
                            var projRootArgMatch = /^(--|-|\/)?(p|proj|projRoot|projDir|root)(\:|\=)?$/i.exec(arg);
                            if (projRootArgMatch) {
                                if (i + 1 < argv.length) {
                                    if (!knownArguments)
                                        knownArguments = {};
                                    knownArguments.projRoot = argv[i + 1];
                                    i++;
                                    continue;
                                }
                            }
                            projRootArgMatch = /^(--|-|\/)?(p|proj|projRoot|projDir|root)(\:|\=)(.+)$/i.exec(arg);
                            if (projRootArgMatch) {
                                if (!knownArguments)
                                    knownArguments = {};
                                knownArguments.projRoot = projRootArgMatch[4];
                                continue;
                            }
                        }
                        var buildArgMatch = /^(--|-|\/)?(build)(\:|\=)?$/i.exec(arg);
                        if (buildArgMatch &&
                            // 'build' may plausibly be ussed as a directory name, so this option will only be applicable
                            // if used with suffix or prefix: '--build' or 'build= true' or '--build= true'
                            // but not 'build' nor 'build true'
                            (buildArgMatch[1] || buildArgMatch[3])) {
                            var buildMatchBoolean = i + 1 < argv.length ?
                                parseCmdline.parseBoolean(argv[i + 1]) :
                                void 0;
                            if (typeof buildMatchBoolean === 'boolean') {
                                if (!knownArguments)
                                    knownArguments = {};
                                knownArguments.build = buildMatchBoolean;
                                i++;
                                continue;
                            }
                            else if (!buildArgMatch[3]) {
                                // '--build' wihout subsequent parameter implies build: true
                                if (!knownArguments)
                                    knownArguments = {};
                                knownArguments.build = true;
                            }
                        }
                        buildArgMatch = /^(--|-|\/)?(build)(\:|\=)(.+)$/i.exec(arg);
                        if (buildArgMatch) {
                            var buildMatchBoolean = parseCmdline.parseBoolean(buildArgMatch[4]);
                            if (typeof buildMatchBoolean) {
                                if (!knownArguments)
                                    knownArguments = {};
                                knownArguments.build = buildMatchBoolean;
                                continue;
                            }
                        }
                        if (/^(--|-|\/)?h(elp)?$/i.test(arg)) {
                            if (!knownArguments)
                                knownArguments = {};
                            knownArguments.help = true;
                            continue;
                        }
                        if (/^(--|-|\/)?v(er(sion)?)?$/i.test(arg)) {
                            if (!knownArguments)
                                knownArguments = {};
                            knownArguments.version = true;
                            continue;
                        }
                        unknownArguments.push(arg);
                    }
                    return {
                        knownArguments: knownArguments,
                        unknownArguments: unknownArguments && unknownArguments.length && unknownArguments || void 0,
                        errors: errors && errors.length && errors || void 0
                    };
                }
                parseCmdline.parseArgs = parseArgs;
                function parseHostAndPort(hostAndPortStr) {
                    if (/^[0-9]+$/.test(hostAndPortStr))
                        return { host: void 0, port: Number(hostAndPortStr) };
                    var https;
                    var regexp_protocolLead = /^(http|https)\:\/*/i;
                    var protocolLeadMatch = regexp_protocolLead.exec(hostAndPortStr);
                    if (protocolLeadMatch) {
                        https = /https/i.test(protocolLeadMatch[1]);
                        hostAndPortStr = hostAndPortStr.slice(protocolLeadMatch[0].length);
                    }
                    var regexp_hostAndPortPattern = /^(.+)\:([0-9]+)$/;
                    var hostAndPortPatternMatch = regexp_hostAndPortPattern.exec(hostAndPortStr);
                    if (hostAndPortPatternMatch)
                        return { https: https, host: hostAndPortPatternMatch[1], port: Number(hostAndPortPatternMatch[2]) };
                    else
                        return { https: https, host: hostAndPortStr };
                }
                parseCmdline.parseHostAndPort = parseHostAndPort;
                function deriveHostAndPort(hostAndPort, projRoot) {
                    if (!hostAndPort)
                        return void 0;
                    return {
                        https: hostAndPort === true ? false :
                            hostAndPort.https || false,
                        host: hostAndPort === true || !hostAndPort.host ? 'localhost' : hostAndPort.host,
                        port: hostAndPort !== true && typeof hostAndPort.port === 'number' ? hostAndPort.port :
                            hostAndPort !== true && hostAndPort.https === true ? 443 :
                                hostAndPort !== true && hostAndPort.https === false ? 80 :
                                    cmdline.derivePort(projRoot)
                    };
                }
                parseCmdline.deriveHostAndPort = deriveHostAndPort;
                function hasHtmlExtension(fileName) {
                    return /[^\\]\.html$/i.test(fileName);
                }
                parseCmdline.hasHtmlExtension = hasHtmlExtension;
                function parseBoolean(txt) {
                    if (regexp_false.test(txt))
                        return false;
                    else if (regexp_true.test(txt))
                        return true;
                }
                parseCmdline.parseBoolean = parseBoolean;
            })(parseCmdline = cmdline.parseCmdline || (cmdline.parseCmdline = {}));
        })(cmdline = parsing.cmdline || (parsing.cmdline = {}));
    })(parsing = danfo.parsing || (danfo.parsing = {}));
})(danfo || (danfo = {}));
var danfo;
(function (danfo) {
    var parsing;
    (function (parsing) {
        var sourcemap;
        (function (sourcemap) {
            function combineMappings(mappingsList) {
                var output = sourcemap.writer();
                var veryFirstLine = true;
                var prevCombinedFileCount = 0;
                var prevCombinedNameCount = 0;
                for (var _i = 0, mappingsList_1 = mappingsList; _i < mappingsList_1.length; _i++) {
                    var entry = mappingsList_1[_i];
                    for (var input = sourcemap.reader(entry.mappings); input.read();) {
                        input.generatedLine += entry.generatedLine;
                        if (veryFirstLine) {
                            // for concatenated scripts, only the very first line of the first script is bumped
                            input.generatedColumn += entry.generatedColumn;
                            veryFirstLine = false;
                        }
                        // previous scripts' tables shift next scripts' offsets down
                        input.originalFile += prevCombinedFileCount;
                        if (input.originalName >= 0)
                            input.originalName += prevCombinedNameCount;
                        output.write(input);
                    }
                    prevCombinedFileCount += entry.fileCount;
                    prevCombinedNameCount += entry.nameCount;
                }
                return output.text();
            }
            sourcemap.combineMappings = combineMappings;
        })(sourcemap = parsing.sourcemap || (parsing.sourcemap = {}));
    })(parsing = danfo.parsing || (danfo.parsing = {}));
})(danfo || (danfo = {}));
var danfo;
(function (danfo) {
    var parsing;
    (function (parsing) {
        var sourcemap;
        (function (sourcemap) {
            var regex_leadingLineHasNonWhitespace = /^[^\S\r\n]*\S/;
            var regex_trailingLineHasNonWhitespace = /\S[^\S\r\n]*$/;
            var regex_anyNonWhitespace = /\S/;
            var regex_TSorTSX = /\.ts$|\.tsx$/i;
            var regex_MAP = /\.map$/i;
            function concatenate(_a, inputs) {
                var _b, _c;
                var sourcemapFileName = _a.sourcemapFileName, fileName = _a.fileName, extraFiles = _a.extraFiles, preserveWhitespace = _a.preserveWhitespace;
                if (typeof sourcemapFileName === 'undefined') {
                    if (typeof fileName === 'undefined')
                        fileName = 'script.js';
                    sourcemapFileName = fileName.replace(regex_TSorTSX, '.js') + '.map';
                }
                else if (typeof fileName === 'undefined') {
                    fileName = sourcemapFileName.replace(regex_MAP, '');
                }
                if (typeof preserveWhitespace === 'undefined')
                    preserveWhitespace = false;
                var contentCombined = '';
                var emitOffsets = [];
                for (var i = 0; i < inputs.length; i++) {
                    var entry = inputs[i];
                    if (!entry)
                        continue;
                    if (typeof entry === 'string') {
                        contentCombined =
                            !contentCombined ? entry :
                                preserveWhitespace ? concatenate.ensureSingleNewLineSeparator(contentCombined, entry) :
                                    concatenate.ensureDoubleNewLineSeparator(contentCombined, entry);
                        continue;
                    }
                    var entryOutput = entry.output || '';
                    var sourcemapMatch = concatenate.findSourcemapSuffix(entryOutput);
                    var appendContent = sourcemapMatch ? entryOutput.slice(0, sourcemapMatch.offset) : entryOutput;
                    contentCombined =
                        !contentCombined ? appendContent :
                            preserveWhitespace ? concatenate.ensureSingleNewLineSeparator(contentCombined, appendContent) :
                                concatenate.ensureDoubleNewLineSeparator(contentCombined, appendContent);
                    // offset needs calculation because newline may have been injected, or not
                    emitOffsets[i] = contentCombined.length - appendContent.length;
                }
                var combinedLineMap = parsing.lineMap(contentCombined);
                var sourcemapObjects = [];
                for (var i = 0; i < inputs.length; i++) {
                    var entry = inputs[i];
                    if (!entry)
                        continue;
                    if (typeof entry === 'string' || !entry.sourcemap)
                        continue;
                    var offset = combinedLineMap.getLineAndCharacter(emitOffsets[i]);
                    var sourcemapJson = void 0;
                    try {
                        sourcemapJson = JSON.parse(entry.sourcemap.content);
                    }
                    catch (sourcemapParseError) {
                        continue;
                    }
                    sourcemapJson.generatedLine = offset.ln - 1;
                    sourcemapJson.generatedColumn = offset.ch - 1;
                    sourcemapJson.fileCount = ((_b = sourcemapJson.sources) === null || _b === void 0 ? void 0 : _b.length) || 0;
                    sourcemapJson.nameCount = ((_c = sourcemapJson.names) === null || _c === void 0 ? void 0 : _c.length) || 0;
                    sourcemapJson.entry = entry;
                    sourcemapObjects.push(sourcemapJson);
                }
                if (!sourcemapObjects.length)
                    return contentCombined;
                var combinedMappings = sourcemap.combineMappings(sourcemapObjects);
                var combinedSourcemap = {
                    version: sourcemapObjects[0].version,
                    file: fileName,
                    sourceRoot: '',
                    sources: [],
                    names: [],
                    mappings: combinedMappings,
                    sourcesContent: []
                };
                for (var _i = 0, sourcemapObjects_1 = sourcemapObjects; _i < sourcemapObjects_1.length; _i++) {
                    var srcmap = sourcemapObjects_1[_i];
                    for (var _d = 0, _e = srcmap.sources; _d < _e.length; _d++) {
                        var s = _e[_d];
                        var sourcePath = srcmap.sourceRoot ? srcmap.sourceRoot + '/' + s : s;
                        if (typeof (srcmap === null || srcmap === void 0 ? void 0 : srcmap.entry.resolvePath) === 'function')
                            sourcePath = srcmap.entry.resolvePath(sourcePath);
                        combinedSourcemap.sources.push(sourcePath);
                    }
                    for (var _f = 0, _g = srcmap.names; _f < _g.length; _f++) {
                        var n = _g[_f];
                        combinedSourcemap.names.push(n);
                    }
                    for (var i = 0; i < Math.max(srcmap.sources.length, srcmap.sourcesContent.length); i++) {
                        combinedSourcemap.sourcesContent.push(srcmap.sourcesContent[i] || '');
                    }
                }
                if (extraFiles && extraFiles.length) {
                    var existingFileCount = Math.max(combinedSourcemap.sources.length, combinedSourcemap.sourcesContent.length);
                    for (var i = 0; i < extraFiles.length; i++) {
                        var fi = extraFiles[i];
                        combinedSourcemap.sources[existingFileCount + i] = fi.fileName;
                        combinedSourcemap.sourcesContent[existingFileCount + i] = fi.content;
                    }
                }
                var combinedSourcemapString = JSON.stringify(combinedSourcemap);
                contentCombined += '\n//# sourceMappingURL=' + sourcemapFileName;
                if (!preserveWhitespace)
                    contentCombined += '\n';
                return {
                    fileName: fileName,
                    output: contentCombined,
                    sourcemap: { fileName: sourcemapFileName, content: combinedSourcemapString }
                };
            }
            sourcemap.concatenate = concatenate;
            (function (concatenate) {
                var regex_anyNonWhitespace = /\S/;
                var regex_LFwhitespace_end = /\n[^\S\n]*$/;
                var regex_LFwhitespace_LFwhitespace_end = /\n[^\S\n]*\n[^\S\n]*$/;
                var regex_start_LFwhitespace = /^\n[^\S\n]*/;
                var regex_start_LFwhitespace_LFwhitespace = /^\n[^\S\n]*\n[^\S\n]*/;
                var regex_sourcemap = /(\n\s*)(\/\/#\s*sourceMappingURL=)([^\n]+?)(\s*)$/;
                var regex_any_nonNewLines = /[^\n]/;
                function ensureSingleNewLineSeparator(text1, text2) {
                    if (!regex_any_nonNewLines.test(text1) || !regex_any_nonNewLines.test(text2))
                        return text1 + text2;
                    if (!text1 || !regex_anyNonWhitespace.test(text1))
                        return text1;
                    var leadCount = regex_LFwhitespace_end.test(text1) ? 1 :
                        0;
                    var trailCount = regex_start_LFwhitespace.test(text2) ? 1 :
                        0;
                    if (leadCount + trailCount === 0)
                        return text1 + '\n' + text2;
                    else
                        return text1 + text2;
                }
                concatenate.ensureSingleNewLineSeparator = ensureSingleNewLineSeparator;
                function ensureDoubleNewLineSeparator(text1, text2) {
                    if (!regex_any_nonNewLines.test(text1) || !regex_any_nonNewLines.test(text2))
                        return text1 + text2;
                    if (!text1 || !regex_anyNonWhitespace.test(text1))
                        return text1;
                    var leadCount = regex_LFwhitespace_LFwhitespace_end.test(text1) ? 2 :
                        regex_LFwhitespace_end.test(text1) ? 1 :
                            0;
                    var trailCount = regex_start_LFwhitespace_LFwhitespace.test(text2) ? 2 :
                        regex_start_LFwhitespace.test(text2) ? 1 :
                            0;
                    if (leadCount + trailCount === 0)
                        return text1 + '\n\n' + text2;
                    else if (leadCount + trailCount === 1)
                        return text1 + '\n' + text2;
                    else
                        return text1 + text2;
                }
                concatenate.ensureDoubleNewLineSeparator = ensureDoubleNewLineSeparator;
                function findSourcemapSuffix(text) {
                    var match = regex_sourcemap.exec(text);
                    if (match)
                        return {
                            offset: match.index,
                            wholeText: match[0],
                            leadWhitespace: match[1],
                            sourceMappingURLPrefix: match[2],
                            sourcemap: match[3],
                            trailWhitespace: match[4]
                        };
                }
                concatenate.findSourcemapSuffix = findSourcemapSuffix;
            })(concatenate = sourcemap.concatenate || (sourcemap.concatenate = {}));
        })(sourcemap = parsing.sourcemap || (parsing.sourcemap = {}));
    })(parsing = danfo.parsing || (danfo.parsing = {}));
})(danfo || (danfo = {}));
var danfo;
(function (danfo) {
    var parsing;
    (function (parsing) {
        var sourcemap;
        (function (sourcemap_1) {
            function reader(mappings) {
                var numBuffer = [0, 0, 0, 0, 0, 0, 0, 0];
                var decodeSpanStart = 0;
                var pos = 0;
                var current = {
                    generatedLine: 0,
                    generatedColumn: 0,
                    originalLine: 0,
                    originalColumn: 0,
                    originalFile: 0,
                    originalName: -1
                };
                var result = {
                    generatedLine: 0,
                    generatedColumn: 0,
                    originalLine: 0,
                    originalColumn: 0,
                    originalFile: 0,
                    originalName: -1,
                    read: read
                };
                return result;
                function read() {
                    for (; pos < mappings.length; pos++) {
                        var ch = mappings.charCodeAt(pos);
                        var parsedSpan = false;
                        if (ch === 59 /* CharCodes.Semicolon */) {
                            // new line indicator
                            // keep reading if semicolon starts text, or follows another semicolon or colon
                            if (pos > decodeSpanStart) {
                                decodeCopyVerify();
                                parsedSpan = true;
                            }
                            current.generatedLine++;
                            current.generatedColumn = 0;
                            decodeSpanStart = pos + 1;
                        }
                        else if (ch === 44 /* CharCodes.Comma */) {
                            // keep reading if colon starts text, or follows another semicolon or colon
                            if (pos > decodeSpanStart) {
                                decodeCopyVerify();
                                parsedSpan = true;
                            }
                            decodeSpanStart = pos + 1;
                        }
                        if (parsedSpan) {
                            pos++;
                            return true;
                        }
                    }
                    // end of text, check if a span is being read
                    if (pos > decodeSpanStart) {
                        decodeCopyVerify();
                        decodeSpanStart = pos + 1; // to terminate
                        return true;
                    }
                    else {
                        return false;
                    }
                }
                function decodeCopyVerify() {
                    decodeForMapping(mappings, decodeSpanStart, pos, numBuffer, current);
                    copyMapping(current, result);
                    verifyMapping(mappings, decodeSpanStart, pos, current);
                }
            }
            sourcemap_1.reader = reader;
            function verifyMapping(mappings, start, end, mappingEntry) {
                if (mappingEntry.generatedColumn < 0
                    || mappingEntry.originalLine < 0
                    || mappingEntry.originalColumn < 0) {
                    throw new Error('Negative absolute value indicate corrupted source map: ' + [
                        mappingEntry.generatedColumn < 0 ? 'generatedColumn=' + mappingEntry.generatedColumn : '',
                        mappingEntry.originalLine < 0 ? 'originalLine=' + mappingEntry.originalLine : '',
                        mappingEntry.originalColumn < 0 ? 'originalColumn=' + mappingEntry.originalColumn : ''
                    ].filter(function (x) { return x; }).join(', ') +
                        ' at offset ' + start + ' with ' + JSON.stringify(mappings.slice(start, end)));
                }
            }
            function decodeForMapping(mappings, start, end, numBuffer, mappingEntry) {
                var bufLen = sourcemap_1.decodeVLQSpanToArray(mappings, start, end, numBuffer);
                if (bufLen < 4)
                    throw new Error('Incorrect encoded span, ' + bufLen + ' is too short: ' + mappings.slice(start, end) + '.');
                if (bufLen > 5)
                    throw new Error('Incorrect encoded span, ' + bufLen + ' is too long: ' + mappings.slice(start, end) + '.');
                mappingEntry.generatedColumn += numBuffer[0];
                mappingEntry.originalFile += numBuffer[1];
                mappingEntry.originalLine += numBuffer[2];
                mappingEntry.originalColumn += numBuffer[3];
                // Need to carry the last name index even if it's not specified,
                // because it's relative when it is used.
                // For that, it's converted into a negative number (zero becomes -1, 1 becomes -2 etc.) 
                if (bufLen === 5) {
                    mappingEntry.originalName =
                        (mappingEntry.originalName < 0 ? -mappingEntry.originalName - 1 : mappingEntry.originalName)
                            + numBuffer[4];
                }
                else if (mappingEntry.originalName >= 0) {
                    mappingEntry.originalName = -mappingEntry.originalName - 1;
                }
            }
            function copyMapping(from, to) {
                to.generatedLine = from.generatedLine;
                to.generatedColumn = from.generatedColumn;
                to.originalFile = from.originalFile;
                to.originalLine = from.originalLine;
                to.originalName = from.originalName;
            }
            (function (reader) {
                /** note $(?![\r\n])  at the end of regex, which matches the true EOF rather than just EOL */
                var regex_sourcemapUrl = /\/\/[\t ]*#[\t ]*sourceMappingURL[\t ]*=[\t ]*(.+?)(\s*)$(?![\r\n])/m;
                var regex_embeddedDataPrefix = /^data\:application\/json\;base64\,/;
                function findSourcemappingURL(scriptText) {
                    var match = scriptText && regex_sourcemapUrl.exec(scriptText);
                    if (!match)
                        return void 0;
                    var url = match[1];
                    var embeddedDataPrefixMatch = regex_embeddedDataPrefix.exec(url);
                    if (embeddedDataPrefixMatch) {
                        var base64Data = url.slice(embeddedDataPrefixMatch.index + embeddedDataPrefixMatch[0].length);
                        try {
                            var embeddedSourcemap = fromSourceMap(danfo.parsing.atob(base64Data));
                            if (embeddedSourcemap) {
                                return {
                                    url: url,
                                    position: scriptText.length - match[2].length - url.length,
                                    embeddedSourcemap: embeddedSourcemap
                                };
                            }
                        }
                        catch (error) {
                        }
                    }
                    return {
                        url: url,
                        position: scriptText.length - match[2].length - url.length
                    };
                }
                reader.findSourcemappingURL = findSourcemappingURL;
                function fromSourceMap(sourcemapContent) {
                    if (!sourcemapContent)
                        return void 0;
                    var sourcemap;
                    try {
                        // TODO do basic sanity check pre-parse to bail out early
                        sourcemap = JSON.parse(sourcemapContent);
                    }
                    catch (error) {
                        return void 0;
                    }
                    if (!sourcemap || typeof sourcemap.mappings !== 'string')
                        return void 0;
                    var theReader = reader(sourcemap.mappings);
                    return {
                        sourcemap: sourcemap,
                        reader: theReader
                    };
                }
                reader.fromSourceMap = fromSourceMap;
            })(reader = sourcemap_1.reader || (sourcemap_1.reader = {}));
        })(sourcemap = parsing.sourcemap || (parsing.sourcemap = {}));
    })(parsing = danfo.parsing || (danfo.parsing = {}));
})(danfo || (danfo = {}));
var danfo;
(function (danfo) {
    var parsing;
    (function (parsing) {
        var sourcemap;
        (function (sourcemap) {
            var integerToChar = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=';
            var charToInteger = 'i   j_`abcdefgh   k   +,-./0123456789:;<=>?@ABCD      EFGHIJKLMNOPQRSTUVWXYZ[\\]^';
            var baseChar = 43;
            function decodeVLQSpanToArray(string, start, end, resultArray) {
                if (start === void 0) { start = 0; }
                if (end === void 0) { end = string.length; }
                var shift = 0;
                var value = 0;
                var resultArrayOffset = 0;
                for (var i = start; i < end; i += 1) {
                    var ch = string.charCodeAt(i);
                    var integer = charToInteger.charCodeAt(ch - baseChar) - baseChar;
                    if (!(integer >= 0))
                        throw new Error('Invalid character "' + string.charAt(i) + '" at position ' + i + ': ' + string.slice(start, end) + '.');
                    var hasContinuationBit = integer & 32;
                    integer &= 31;
                    value += integer << shift;
                    if (hasContinuationBit) {
                        shift += 5;
                    }
                    else {
                        var shouldNegate = value & 1;
                        value >>>= 1;
                        if (shouldNegate)
                            resultArray[resultArrayOffset] = value === 0 ? -0x80000000 : -value;
                        else
                            resultArray[resultArrayOffset] = value;
                        resultArrayOffset++;
                        // reset
                        value = shift = 0;
                    }
                }
                return resultArrayOffset;
            }
            sourcemap.decodeVLQSpanToArray = decodeVLQSpanToArray;
            function encodeVLQArray(value, start, end, result, offset) {
                if (start === void 0) { start = 0; }
                if (end === void 0) { end = value.length; }
                var resultStr = '';
                var bufSize = 0;
                for (var i = 0; i < end; i += 1) {
                    var num = value[i];
                    if (num < 0)
                        num = (-num << 1) | 1;
                    else
                        num <<= 1;
                    do {
                        var clamped = num & 31;
                        num >>>= 5;
                        if (num > 0)
                            clamped |= 32;
                        if (result)
                            result[offset + bufSize] = integerToChar.charCodeAt(clamped);
                        else
                            resultStr += integerToChar.charAt(clamped);
                        bufSize++;
                    } while (num > 0);
                }
                if (result)
                    return bufSize;
                else
                    return resultStr;
            }
            sourcemap.encodeVLQArray = encodeVLQArray;
        })(sourcemap = parsing.sourcemap || (parsing.sourcemap = {}));
    })(parsing = danfo.parsing || (danfo.parsing = {}));
})(danfo || (danfo = {}));
var danfo;
(function (danfo) {
    var parsing;
    (function (parsing) {
        var sourcemap;
        (function (sourcemap) {
            function writer() {
                var numBuffer = [0, 0, 0, 0, 0, 0, 0, 0];
                var cache = [];
                var current = {
                    generatedLine: 0,
                    generatedColumn: 0,
                    originalLine: 0,
                    originalColumn: 0,
                    originalFile: 0,
                    originalName: -1
                };
                var resultText = typeof Buffer === 'undefined' ? '' :
                    typeof Buffer.alloc === 'function' ? Buffer.alloc(16) :
                        new Buffer(16);
                // resultText = '';
                var resultTextLength = 0;
                var result = {
                    write: write,
                    text: text
                };
                return result;
                function text() {
                    return typeof resultText === 'string' ? resultText :
                        resultText.toString('ascii', 0, resultTextLength);
                }
                function write(mapping) {
                    if (mapping.generatedLine < current.generatedLine)
                        throw new Error('Cannot go back on generated lines: ' + mapping.generatedLine + ' < ' + current.generatedLine + '.');
                    for (var i = 0; i < mapping.generatedLine - current.generatedLine; i++) {
                        if (typeof resultText === 'string')
                            resultText += ';';
                        else
                            appendResultTextByte(59 /* CharCodes.Semicolon */);
                        // new line resets column
                        current.generatedColumn = 0;
                    }
                    if (!endsWithCharCode(59 /* CharCodes.Semicolon */)) {
                        if (typeof resultText === 'string')
                            resultText += ',';
                        else
                            appendResultTextByte(44 /* CharCodes.Comma */);
                    }
                    if (typeof resultText !== 'string' && resultTextLength + 6 > resultText.byteLength)
                        growResultTextBuffer();
                    var numLen = 4;
                    numBuffer[0] = mapping.generatedColumn - current.generatedColumn;
                    numBuffer[1] = mapping.originalFile - current.originalFile;
                    numBuffer[2] = mapping.originalLine - current.originalLine;
                    numBuffer[3] = mapping.originalColumn - current.originalColumn;
                    if (mapping.originalName >= 0) {
                        numLen = 5;
                        numBuffer[4] = mapping.originalName - (current.originalName >= 0 ? current.originalName :
                            -current.originalName - 1 // encoded as negative (zero is -1, 1 is -2 and so on)
                        );
                    }
                    if (typeof resultText === 'string') {
                        resultText += sourcemap.encodeVLQArray(numBuffer, 0, numLen);
                    }
                    else {
                        resultTextLength += sourcemap.encodeVLQArray(numBuffer, 0, numLen, resultText, resultTextLength);
                    }
                    current.generatedLine = mapping.generatedLine;
                    current.generatedColumn = mapping.generatedColumn;
                    current.originalFile = mapping.originalFile;
                    current.originalLine = mapping.originalLine;
                    current.originalColumn = mapping.originalColumn;
                    if (mapping.originalName >= 0)
                        current.originalName = mapping.originalName;
                    else if (current.originalName >= 0)
                        current.originalName = -current.originalName - 1;
                }
                function allocBuffer(size) {
                    return typeof Buffer.alloc === 'function' ? Buffer.alloc(size) :
                        new Buffer(size);
                }
                function appendResultTextByte(b) {
                    if (resultText.byteLength === resultTextLength)
                        growResultTextBuffer();
                    resultText[resultTextLength] = b;
                    resultTextLength++;
                }
                function growResultTextBuffer() {
                    var newBuf = allocBuffer(resultText.byteLength * 2);
                    resultText.copy(newBuf, 0, 0, resultText.length);
                    resultText = newBuf;
                }
                function endsWithCharCode(cd) {
                    if (typeof resultText === 'string')
                        return !!resultText.length && resultText.charCodeAt(resultText.length - 1) === cd;
                    else
                        return !!resultText.byteLength && resultText[resultTextLength - 1] === cd;
                }
            }
            sourcemap.writer = writer;
        })(sourcemap = parsing.sourcemap || (parsing.sourcemap = {}));
    })(parsing = danfo.parsing || (danfo.parsing = {}));
})(danfo || (danfo = {}));
var danfo;
(function (danfo) {
    var parsing;
    (function (parsing) {
    })(parsing = danfo.parsing || (danfo.parsing = {}));
    if (typeof atob === 'function') {
        parsing.atob = atob;
    }
    else if (typeof Buffer === 'function') {
        if (typeof Buffer.from === 'function') {
            parsing.atob = polyfillWithBufferFrom();
        }
        else {
            parsing.atob = polyfillWithBuffer();
        }
    }
    else {
        parsing.atob = polyfillFull();
    }
    function polyfillWithBuffer() {
        return atob;
        function atob(base64Encoded) {
            return new Buffer(base64Encoded, 'base64').toString('binary');
        }
    }
    function polyfillWithBufferFrom() {
        return atob;
        function atob(base64Encoded) {
            return Buffer.from(base64Encoded, 'base64').toString('binary');
        }
    }
    function polyfillFull() {
        var charToInt = createCharToInt();
        var whitespaces = [32 /* CharCodes.Space */, 8 /* CharCodes.TAB */, 13 /* CharCodes.CR */, 10 /* CharCodes.LF */];
        return atob;
        function createCharToInt() {
            var charToIntStr = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/';
            var charToIntArray = [];
            for (var i = 0; i < charToIntStr.length; i++) {
                charToIntArray.push(charToIntStr.charCodeAt(i));
            }
            return charToIntArray;
        }
        function atob(base64Encoded) {
            var result = '';
            var acc = 0;
            var count = 0;
            for (var i = 0; i < base64Encoded.length; i++) {
                var ch = base64Encoded.charCodeAt(i);
                var bits = charToInt.indexOf(ch);
                // skip whitespace and equal signs
                // (allow equal signs in the middle because this is a limited-use polyfill)
                if (bits < 0) {
                    if (ch === 61 /* CharCodes.Equal */ || whitespaces.indexOf(ch) >= 0)
                        continue;
                    else
                        throw new Error('Incorrect character ' + base64Encoded.charAt(i) + ' at position ' + i + '.');
                }
                acc <<= 6;
                acc |= bits;
                count++;
                if (count === 3) {
                    result += String.fromCharCode((acc & 0xff0000) >> 16);
                    result += String.fromCharCode((acc & 0xff00) >> 8);
                    result += String.fromCharCode(acc & 0xff);
                    acc = 0;
                    count = 0;
                }
            }
            if (count) {
                if (count === 2)
                    result += String.fromCharCode((acc & 0xff00) >> 8);
                result += String.fromCharCode(acc & 0xff);
            }
            return result;
        }
    }
})(danfo || (danfo = {}));
var danfo;
(function (danfo) {
    var parsing;
    (function (parsing) {
        var entities;
        function decodeEntities(text) {
            return text.replace(/&((#((\d+)|x([\da-fA-F]+)))|(\w+));/g, function (match, _all, _number, _digits, decimal, hex, word) {
                if (decimal) {
                    return String.fromCharCode(parseInt(decimal, 10));
                }
                else if (hex) {
                    return String.fromCharCode(parseInt(hex, 16));
                }
                else {
                    if (!entities)
                        entities = createEntitiesMap(entitiesCompressed);
                    var ch = entities[word];
                    // If this is not a valid entity, then just use `match` (replace it with itself, i.e. don't replace)
                    return typeof ch === 'number' ? String.fromCharCode(ch) : match;
                }
            });
        }
        parsing.decodeEntities = decodeEntities;
        function createEntitiesMap(array) {
            var result = {};
            var val = array[0] - 1;
            for (var i = 1; i < array.length; i++) {
                var x = array[i];
                if (typeof x === 'number') {
                    val += x;
                    continue;
                }
                val++;
                if (x)
                    result[x] = val;
            }
            return result;
        }
        var entitiesCompressed = [
            34, "quot", , , , "amp", "apos",
            20, "lt", , "gt",
            97, "nbsp", "iexcl", "cent", "pound", "curren", "yen", "brvbar", "sect", "uml", "copy", "ordf", "laquo", "not", "shy", "reg", "macr", "deg", "plusmn", "sup2", "sup3", "acute", "micro", "para", "middot", "cedil", "sup1", "ordm", "raquo", "frac14", "frac12", "frac34", "iquest", "Agrave", "Aacute", "Acirc", "Atilde", "Auml", "Aring", "AElig", "Ccedil", "Egrave", "Eacute", "Ecirc", "Euml", "Igrave", "Iacute", "Icirc", "Iuml", "ETH", "Ntilde", "Ograve", "Oacute", "Ocirc", "Otilde", "Ouml", "times", "Oslash", "Ugrave", "Uacute", "Ucirc", "Uuml", "Yacute", "THORN", "szlig", "agrave", "aacute", "acirc", "atilde", "auml", "aring", "aelig", "ccedil", "egrave", "eacute", "ecirc", "euml", "igrave", "iacute", "icirc", "iuml", "eth", "ntilde", "ograve", "oacute", "ocirc", "otilde", "ouml", "divide", "oslash", "ugrave", "uacute", "ucirc", "uuml", "yacute", "thorn", "yuml",
            82, "OElig", "oelig",
            12, "Scaron", "scaron",
            22, "Yuml",
            25, "fnof",
            307, "circ",
            21, "tilde",
            180, "Alpha", "Beta", "Gamma", "Delta", "Epsilon", "Zeta", "Eta", "Theta", "Iota", "Kappa", "Lambda", "Mu", "Nu", "Xi", "Omicron", "Pi", "Rho", , "Sigma", "Tau", "Upsilon", "Phi", "Chi", "Psi", "Omega",
            7, "alpha", "beta", "gamma", "delta", "epsilon", "zeta", "eta", "theta", "iota", "kappa", "lambda", "mu", "nu", "xi", "omicron", "pi", "rho", "sigmaf", "sigma", "tau", "upsilon", "phi", "chi", "psi", "omega",
            7, "thetasym", "upsih", , , , "piv",
            7211, "ensp", "emsp",
            5, "thinsp", , , "zwnj", "zwj", "lrm", "rlm", , , , "ndash", "mdash", , , , "lsquo", "rsquo", "sbquo", , "ldquo", "rdquo", "bdquo", , "dagger", "Dagger", "bull", , , , "hellip",
            9, "permil", , "prime", "Prime",
            5, "lsaquo", "rsaquo", , , , "oline",
            5, "frasl",
            103, "euro",
            100, "image",
            6, "weierp", , , , "real",
            5, "trade",
            18, "alefsym",
            90, "larr", "uarr", "rarr", "darr", "harr",
            32, "crarr",
            26, "lArr", "uArr", "rArr", "dArr", "hArr",
            43, "forall", , "part", "exist", , "empty", , "nabla", "isin", "notin", , "ni", , , , "prod", , "sum", "minus",
            4, "lowast", , , "radic", , , "prop", "infin", , "ang",
            6, "and", "or", "cap", "cup", "int",
            8, "there4",
            7, "sim",
            8, "cong", , , "asymp",
            23, "ne", "equiv", , , "le", "ge",
            28, "sub", "sup", "nsub", , "sube", "supe",
            13, "oplus", , "otimes",
            13, "perp",
            31, "sdot",
            66, "lceil", "rceil", "lfloor", "rfloor",
            29, "lang", "rang",
            671, "loz",
            149, "spades", , , "clubs", , "hearts", "diams"
        ];
    })(parsing = danfo.parsing || (danfo.parsing = {}));
})(danfo || (danfo = {}));
var danfo;
(function (danfo) {
    var parsing;
    (function (parsing) {
        function lineMap(text) {
            var textCopy = String(text);
            return {
                getLineAndCharacter: getLineAndCharacter
            };
            function getLineAndCharacter(pos) {
                if (pos < 0 || pos > textCopy.length)
                    return null;
                var lineStartPos = 0;
                var line = 1;
                var currentPos = 0;
                var lineBreakRegExp = /\r\n|\n|\r/gm;
                while (true) {
                    var nextLineBreak = lineBreakRegExp.exec(textCopy);
                    if (!nextLineBreak)
                        return {
                            ln: line,
                            ch: pos - lineStartPos + 1
                        };
                    if (nextLineBreak.index >= pos) {
                        return {
                            ln: line,
                            ch: pos - lineStartPos + 1
                        };
                    }
                    line++;
                    lineStartPos = nextLineBreak.index + nextLineBreak[0].length;
                }
            }
        }
        parsing.lineMap = lineMap;
    })(parsing = danfo.parsing || (danfo.parsing = {}));
})(danfo || (danfo = {}));
var danfo;
(function (danfo) {
    var parsing;
    (function (parsing) {
        function parseHTML(html) {
            var elements = [];
            var pos = 0;
            while (pos < html.length - 7) { // 7 chars: < STY LE >
                pos = html.indexOf('<', pos);
                var firstLetter = html.charCodeAt(pos + 1); // next after <
                if (firstLetter === 33 /* CharCodes.Exclamation */) {
                    if (html.charCodeAt(pos + 2) !== 45 /* CharCodes.Dash */) {
                        pos = html.indexOf('>', pos + 2);
                        if (pos < 0)
                            break; // no angle close? finish
                        pos++; // skip angle close
                        continue;
                    }
                    else if (html.charCodeAt(pos + 3) === 45 /* CharCodes.Dash */) {
                        // fully formed HTML comment <!-- bla bla -->
                        pos = html.indexOf('-->', pos + 3);
                        if (pos < 0)
                            break; // no close comment? finish
                        pos += 3; // skip close comment
                        continue;
                    }
                    else {
                        // partial HTML comment <!- bla bla ->
                        pos = html.indexOf('->', pos + 2);
                        if (pos < 0)
                            break; // no close comment? finish
                        pos += 2; // skip close comment
                        continue;
                    }
                }
                else if (firstLetter === 47 /* CharCodes.Slash */) {
                    pos = html.indexOf('>', pos + 2);
                    if (pos < 0)
                        break;
                    pos++;
                    continue;
                }
                else if (isAtoZ(firstLetter)) {
                    var elementEndPos = html.indexOf('>', pos + 3);
                    if (elementEndPos < 0)
                        break;
                    elementEndPos++;
                    if (firstLetter === 76 /* CharCodes.UPPER_L */ || firstLetter === 108 /* CharCodes.lower_l */) {
                        if (isElementNameAt(html, pos + 1, 'link')) {
                            processLinkElement(elementEndPos);
                            continue;
                        }
                    }
                    else if (firstLetter === 83 /* CharCodes.UPPER_S */ || firstLetter === 115 /* CharCodes.lower_s */) {
                        if (isElementNameAt(html, pos + 1, 'script')) {
                            processScriptElement(elementEndPos);
                            continue;
                        }
                        else if (isElementNameAt(html, pos + 1, 'style')) {
                            processStyleElement(elementEndPos);
                            continue;
                        }
                    }
                    pos = elementEndPos;
                }
                else {
                    pos++;
                }
            }
            return elements;
            function enclosedInMatchedQuotes(start, end) {
                var firstChar = html.charCodeAt(start);
                if (firstChar === 34 /* CharCodes.Quote */ || firstChar === 39 /* CharCodes.Apostrophe */) {
                    var lastChar = html.charCodeAt(end - 1);
                    if (lastChar === firstChar && end > start + 1) {
                        return true;
                    }
                }
                return false;
            }
            function processLinkElement(elementEndPos) {
                var seek = pos + 6 /* < LINK */;
                var lastRelPos = 0, lastRelEnd = 0, lastRelAttributePos = 0, lastRelAttributeEnd = 0;
                var lastHrefPos = 0, lastHrefEnd = 0, lastHrefAttributePos = 0, lastHrefAttributeEnd = 0;
                while (true) {
                    seek = findAttributeStart(html, seek, elementEndPos);
                    if (!seek)
                        break;
                    if (isAttributeAndEqualsAt(html, seek, 'rel')) {
                        var attributeEnd = findAttributeEnd(html, seek + 4 /* REL= */, elementEndPos - 1);
                        if (attributeEnd < 0) {
                            pos = elementEndPos;
                            break;
                        }
                        var relPos = seek + 4 /* REL= */;
                        var relEnd = attributeEnd;
                        if (enclosedInMatchedQuotes(relPos, relEnd)) {
                            relPos++;
                            relEnd--;
                        }
                        lastRelPos = relPos;
                        lastRelEnd = relEnd;
                        lastRelAttributePos = seek;
                        lastRelAttributeEnd = attributeEnd;
                        seek = attributeEnd;
                    }
                    else if (isAttributeAndEqualsAt(html, seek, 'href')) {
                        var attributeEnd = findAttributeEnd(html, seek + 5 /* HREF= */, elementEndPos - 1);
                        if (attributeEnd < 0) {
                            pos = elementEndPos;
                            break;
                        }
                        var hrefPos = seek + 5 /* HREF= */;
                        var hrefEnd = attributeEnd;
                        if (enclosedInMatchedQuotes(hrefPos, hrefEnd)) {
                            hrefPos++;
                            hrefEnd--;
                        }
                        lastHrefPos = hrefPos;
                        lastHrefEnd = hrefEnd;
                        lastHrefAttributePos = seek;
                        lastHrefAttributeEnd = attributeEnd;
                        seek = attributeEnd;
                    }
                    else {
                        var attributeEnd = findAttributeEnd(html, seek + 1 /* at least one letter attribute */, elementEndPos - 1);
                        if (attributeEnd < 0) {
                            pos = elementEndPos;
                            break;
                        }
                        seek = attributeEnd;
                    }
                }
                if (!lastRelPos || !lastHrefPos)
                    return;
                var rel = parsing.decodeEntities(html.slice(lastRelPos, lastRelEnd));
                if (!/stylesheet/i.test(rel))
                    return;
                var href = parsing.decodeEntities(html.slice(lastHrefPos, lastHrefEnd));
                elements.push({
                    tag: 'link',
                    type: 'css',
                    start: pos, length: elementEndPos - pos,
                    reference: href,
                    originalLeadLength: elementEndPos - pos,
                    originalTrailLength: 0,
                    lead: '<style' + sliceElementWithAttributeHoles(html, pos + 5 /* < LINK */, elementEndPos, lastRelAttributePos, lastRelAttributeEnd, lastHrefAttributePos, lastHrefAttributeEnd),
                    trail: '</' + 'style' + '>'
                });
                pos = elementEndPos;
            }
            function processStyleElement(elementEndPos) {
                var seekClose = elementEndPos;
                var closeElementPos = 0;
                var closeElementEnd = 0;
                while (seekClose < html.length) {
                    closeElementPos = html.indexOf('</', seekClose); // may not be STYLE element end
                    if (closeElementPos < 0)
                        break; // incomplete element, ignore
                    if (!isElementNameAt(html, closeElementPos + 2, 'style')) { // not STYLE element close - keep seeking
                        seekClose = closeElementPos + 2;
                        continue;
                    }
                    closeElementEnd = html.indexOf('>', closeElementPos + 7 /* </ STY LE */);
                    if (closeElementEnd > 0)
                        closeElementEnd++;
                    break;
                }
                if (closeElementEnd > 0) {
                    elements.push({
                        tag: 'style',
                        type: 'css',
                        start: pos, length: closeElementEnd - pos,
                        content: html.slice(elementEndPos, closeElementPos),
                        originalLeadLength: elementEndPos - pos,
                        originalTrailLength: closeElementEnd - closeElementPos,
                        lead: html.slice(pos, elementEndPos), trail: html.slice(closeElementPos, closeElementEnd)
                    });
                    pos = closeElementEnd;
                }
                else {
                    // STYLE not closed, finish
                    pos = html.length;
                }
            }
            function processScriptElement(elementEndPos) {
                var seek = pos + 7 /* < SCR IPT */;
                var lastSrcPos = 0, lastSrcEnd = 0, lastSrcAttributePos = 0, lastSrcAttributeEnd = 0;
                var lastTypePos = 0, lastTypeEnd = 0, lastTypeAttributePos = 0, lastTypeAttributeEnd = 0;
                while (true) {
                    seek = findAttributeStart(html, seek, elementEndPos);
                    if (!seek)
                        break;
                    if (isAttributeAndEqualsAt(html, seek, 'src')) {
                        var attributeEnd = findAttributeEnd(html, seek + 4 /* SRC= */, elementEndPos - 1);
                        if (attributeEnd < 0) {
                            seek = elementEndPos;
                            break;
                        }
                        var srcPos = seek + 4 /* SRC= */;
                        var srcEnd = attributeEnd;
                        if (enclosedInMatchedQuotes(srcPos, srcEnd)) {
                            srcPos++;
                            srcEnd--;
                        }
                        lastSrcPos = srcPos;
                        lastSrcEnd = srcEnd;
                        lastSrcAttributePos = seek;
                        lastSrcAttributeEnd = attributeEnd;
                        seek = attributeEnd;
                    }
                    else if (isAttributeAndEqualsAt(html, seek, 'type')) {
                        var attributeEnd = findAttributeEnd(html, seek + 5 /* TYPE= */, elementEndPos - 1);
                        if (attributeEnd < 0) {
                            seek = elementEndPos;
                            break;
                        }
                        var typePos = seek + 5 /* TYPE= */;
                        var typeEnd = attributeEnd;
                        if (enclosedInMatchedQuotes(typePos, typeEnd)) {
                            typePos++;
                            typeEnd--;
                        }
                        lastTypePos = typePos;
                        lastTypeEnd = typeEnd;
                        lastTypeAttributePos = seek;
                        lastTypeAttributeEnd = attributeEnd;
                        seek = attributeEnd;
                    }
                    else {
                        var attributeEnd = findAttributeEnd(html, seek + 1 /* one letter attribute at least */, elementEndPos - 1);
                        if (attributeEnd < 0) {
                            seek = elementEndPos;
                            break;
                        }
                        seek = attributeEnd;
                    }
                }
                var src = lastSrcPos ? parsing.decodeEntities(html.slice(lastSrcPos, lastSrcEnd)) : null;
                var type = lastTypePos ? parsing.decodeEntities(html.slice(lastTypePos, lastTypeEnd)) : null;
                var seekClose = elementEndPos;
                var closeElementPos = 0;
                var closeElementEnd = 0;
                while (seekClose < html.length) {
                    closeElementPos = html.indexOf('</', seekClose); // may not be SCRIPT element end
                    if (closeElementPos < 0)
                        break; // incomplete element, ignore
                    if (!isElementNameAt(html, closeElementPos + 2, 'script')) { // not SCRIPT element close - keep seeking
                        seekClose = closeElementPos + 2;
                        continue;
                    }
                    closeElementEnd = html.indexOf('>', closeElementPos + 8 /* </ SCR IPT */);
                    if (closeElementEnd > 0)
                        closeElementEnd++;
                    break;
                }
                if (closeElementEnd > 0) {
                    if (type) {
                        if (parseHTML.isJavascriptType(type)) {
                            type = 'javascript';
                        }
                        else if (parseHTML.isTypeScriptType(type)) {
                            type = 'typescript';
                        }
                        else if (parseHTML.isTsconfigType(type)) {
                            type = 'tsconfig';
                        }
                    }
                    else {
                        if (src && parseHTML.hasTypeScriptFileExtension(src))
                            type = 'typescript';
                        else if (src && parseHTML.isTsconfigJsonFileName(src))
                            type = 'tsconfig';
                        else
                            type = 'javascript';
                    }
                    var lead = sliceElementWithAttributeHoles(html, pos, elementEndPos, lastSrcAttributePos, lastSrcAttributeEnd, 
                    // exclude type attribute for typescript (it's translated into javascript)
                    type === 'typescript' || type === 'tsconfig' ? lastTypeAttributePos : 0, type === 'typescript' || type === 'tsconfig' ? lastTypeAttributeEnd : 0);
                    if (src) {
                        elements.push({
                            tag: 'script',
                            type: type,
                            start: pos, length: closeElementEnd - pos,
                            reference: src,
                            originalLeadLength: elementEndPos - pos,
                            originalTrailLength: closeElementEnd - closeElementPos,
                            lead: lead,
                            trail: html.slice(closeElementPos, closeElementEnd)
                        });
                    }
                    else {
                        elements.push({
                            tag: 'script',
                            type: type,
                            start: pos, length: closeElementEnd - pos,
                            content: html.slice(elementEndPos, closeElementPos),
                            originalLeadLength: elementEndPos - pos,
                            originalTrailLength: closeElementEnd - closeElementPos,
                            lead: lead,
                            trail: html.slice(closeElementPos, closeElementEnd)
                        });
                    }
                    pos = closeElementEnd;
                }
                else {
                    // STYLE not closed, finish
                    pos = html.length;
                }
            }
        }
        parsing.parseHTML = parseHTML;
        function findAttributeEnd(html, pos, end) {
            if (end === pos)
                return -1;
            var firstChar = html.charCodeAt(pos);
            for (var i = pos + 1; i < end; i++) {
                var ch = html.charCodeAt(i);
                if (firstChar === 34 /* CharCodes.Quote */) {
                    if (ch === 34 /* CharCodes.Quote */)
                        return i + 1;
                }
                else if (firstChar === 39 /* CharCodes.Apostrophe */) {
                    if (ch === 39 /* CharCodes.Apostrophe */)
                        return i + 1;
                }
                else if (isWhitespace(ch)) {
                    return i;
                }
            }
            return end;
        }
        function isWordAt(text, pos, wordLowercase) {
            for (var i = 0; i < wordLowercase.length; i++) {
                var ch = text.charCodeAt(pos + i);
                var expectChLower = wordLowercase.charCodeAt(i);
                if (ch !== expectChLower && ch + 32 /* CharCodes.MakeLower */ !== expectChLower)
                    return false;
            }
            return true;
        }
        function isElementNameAt(html, pos, elementName) {
            if (!isWordAt(html, pos, elementName))
                return false;
            var afterWordCh = html.charCodeAt(pos + elementName.length);
            if (isWhitespace(afterWordCh) || afterWordCh === 62 /* CharCodes.AngleClose */)
                return true;
            else
                return false;
        }
        function isAttributeAndEqualsAt(html, pos, attrName) {
            if (!isWordAt(html, pos, attrName))
                return false;
            var afterWordCh = html.charCodeAt(pos + attrName.length);
            if (afterWordCh === 61 /* CharCodes.Equal */)
                return true;
            else
                return false;
        }
        function isWhitespace(ch) {
            return ch === 32 /* CharCodes.Space */ ||
                ch === 13 /* CharCodes.CR */ ||
                ch === 10 /* CharCodes.LF */ ||
                ch === 8 /* CharCodes.TAB */;
        }
        function isAtoZ(ch) {
            return (ch >= 65 /* CharCodes.UPPER_A */ && ch <= 90 /* CharCodes.UPPER_Z */) ||
                (ch >= 97 /* CharCodes.lower_a */ && ch <= 122 /* CharCodes.lower_z */);
        }
        function findAttributeStart(html, pos, end) {
            for (var i = pos; i < end; i++) {
                var ch = html.charCodeAt(i);
                while (isWhitespace(ch)) {
                    i++;
                    if (i >= end)
                        return 0;
                    ch = html.charCodeAt(i);
                }
                if (isAtoZ(ch))
                    return i;
            }
            return 0;
        }
        function findAnyOf(text, pos, end, setOfChars) {
            for (var i = pos; i < end; i++) {
                var ch = text.charCodeAt(i);
                for (var j = 0; j < setOfChars.length; j++) {
                    var match = setOfChars.charCodeAt(j);
                    if (ch === match)
                        return i;
                }
            }
            return -1;
        }
        function sliceElementWithAttributeHoles(html, pos, end, attr1Pos, attr1End, attr2Pos, attr2End) {
            if (attr1Pos) {
                while (attr1Pos > pos && isWhitespace(html.charCodeAt(attr1Pos - 1))) {
                    attr1Pos--;
                }
            }
            if (attr2Pos) {
                while (attr2Pos > pos && isWhitespace(html.charCodeAt(attr2Pos - 1))) {
                    attr2Pos--;
                }
            }
            if (attr1Pos) {
                if (attr2Pos) {
                    return attr1Pos < attr2Pos ?
                        html.slice(pos, attr1Pos) + html.slice(attr1End, attr2Pos) + html.slice(attr2End, end) :
                        html.slice(pos, attr2Pos) + html.slice(attr2End, attr1Pos) + html.slice(attr1End, end);
                }
                else {
                    return html.slice(pos, attr1Pos) + html.slice(attr1End, end);
                }
            }
            else if (attr2Pos) {
                return html.slice(pos, attr2Pos) + html.slice(attr2End, end);
            }
            else {
                return html.slice(pos, end);
            }
        }
        (function (parseHTML) {
            var regex_javascriptType = /^\s*(javascript|jscript|js|jsx)\s*$/i;
            var regex_typescriptType = /^\s*(typescript|ts|tsx)\s*$/i;
            var regex_typescriptFileExtension = /\.(ts|tsx)$/i;
            var regex_tsconfigJsonFileName = /(^|\\|\/)tsconfig\.json$/i;
            var regex_tsconfigJsonType = /^\s*(tsconfig)\s*$/i;
            function isJavascriptType(type) {
                return regex_javascriptType.test(type);
            }
            parseHTML.isJavascriptType = isJavascriptType;
            function isTypeScriptType(type) {
                return regex_typescriptType.test(type);
            }
            parseHTML.isTypeScriptType = isTypeScriptType;
            function hasTypeScriptFileExtension(file) {
                return regex_typescriptFileExtension.test(file);
            }
            parseHTML.hasTypeScriptFileExtension = hasTypeScriptFileExtension;
            function isTsconfigJsonFileName(file) {
                return regex_tsconfigJsonFileName.test(file);
            }
            parseHTML.isTsconfigJsonFileName = isTsconfigJsonFileName;
            function isTsconfigType(type) {
                return regex_tsconfigJsonType.test(type);
            }
            parseHTML.isTsconfigType = isTsconfigType;
        })(parseHTML = parsing.parseHTML || (parsing.parseHTML = {}));
    })(parsing = danfo.parsing || (danfo.parsing = {}));
})(danfo || (danfo = {}));
var danfo;
(function (danfo) {
    var wscript;
    (function (wscript) {
        for (var k in danfo.wscript) {
            if (k in bootWScript)
                continue;
            bootWScript[k] = danfo.wscript[k];
        }
        danfo.wscript = bootWScript;
        wscript = bootWScript;
        function bootWScript() {
            wscript.fromConsole = /cscript(\.exe)$/i.test(WScript.FullName);
            var nodePath = wscript.findNode();
            if (!nodePath) {
                WScript.Echo('Node.JS not found\n\n' +
                    'WScript.Name ' + WScript.Name + '\n' +
                    'WScript.FullName ' + WScript.FullName + '\n' +
                    'WScript.ScriptName ' + WScript.ScriptName + '\n' +
                    'WScript.ScriptFullName ' + WScript.ScriptFullName);
                WScript.Quit(-1);
                return;
            }
            if (wscript.fromConsole)
                WScript.Echo('WScript: Restarting with "' + nodePath + '" "' + WScript.ScriptFullName + '"');
            wscript.shell.runAndForget('"' + nodePath + '" "' + WScript.ScriptFullName + '"');
        }
    })(wscript = danfo.wscript || (danfo.wscript = {}));
    (function (wscript) {
        wscript.fromConsole = false;
    })(wscript = danfo.wscript || (danfo.wscript = {}));
})(danfo || (danfo = {}));
var danfo;
(function (danfo) {
    var wscript;
    (function (wscript) {
        function findNode() {
            var simpleWhereProbes = wscript.shell.run('cmd /c where node').replace(/^\s*/, '').replace(/\s*$/, '').split(/(\r\n)|\r|\n/g);
            if (simpleWhereProbes.length && simpleWhereProbes[0])
                return simpleWhereProbes[0];
            return null;
        }
        wscript.findNode = findNode;
    })(wscript = danfo.wscript || (danfo.wscript = {}));
})(danfo || (danfo = {}));
var danfo;
(function (danfo) {
    var wscript;
    (function (wscript) {
        var shell;
        (function (shell) {
            function run(cmdline) {
                var wShell = WScript.CreateObject('WScript.Shell');
                var process = wShell.Exec(cmdline);
                while (process.Status === 0 /* WshShell.WshStatus.WshRunning */) {
                    WScript.Sleep(50);
                }
                var output = process.StdOut.ReadAll();
                var err = process.StdErr.ReadAll();
                return output ? (err ? output + '\n' + err : output) : err;
            }
            shell.run = run;
            function runAndForget(cmdline) {
                var wShell = WScript.CreateObject('WScript.Shell');
                var process = wShell.Run(cmdline, 10, false);
            }
            shell.runAndForget = runAndForget;
        })(shell = wscript.shell || (wscript.shell = {}));
    })(wscript = danfo.wscript || (danfo.wscript = {}));
})(danfo || (danfo = {}));
var danfo;
(function (danfo) {
    danfo.versionStr = '0.3.0';
})(danfo || (danfo = {}));
var _a;
if (typeof module !== 'undefined' && module &&
    typeof require !== 'undefined' && require &&
    typeof process !== 'undefined' && process) {
    module.exports = danfo;
    var isMainModule = require.main ? require.main === module :
        process.mainModule ? process.mainModule === module :
            void 0;
    // node-like environment
    if (isMainModule) {
        global.danfo = danfo;
        danfo.node();
    }
    else {
        var mainModuleFilename = (_a = (require.main || process.mainModule)) === null || _a === void 0 ? void 0 : _a.filename;
        if (mainModuleFilename && /[\/\\]bin[\/\\]danfo(\.[a-z]+)?$/.test(mainModuleFilename)) {
            // started from bin/danfo, good enough
            global.danfo = danfo;
            danfo.node();
        }
        else {
            // just run as a module, not a command-line tool
        }
    }
}
else if (typeof WScript !== 'undefined') {
    // TODO: if not main script, just ignore...
    danfo.wscript();
}
else if (typeof window !== 'undefined' && window) {
    // run in browser main thread
    // TODO: check why danfo is loaded in browser
    window.danfo = danfo;
    danfo.browser.startMain();
}
else if (typeof self !== 'undefined' && self) {
    // run in browser worker
    // TODO: check why danfo is loaded in browser
    self.danfo = danfo;
    danfo.browser.startWorker();
}
// @ts-check
/** @type {{
 *  build: {
 *    code: {
 *      defineAmd():  ((moduleName: string, imports: string[], moduleBody: Function) => any)
 *      & { amd: boolean, require(moduleName: string): any }
 *    }
 *  }
 * }} */
var danfo;
// @ts-ignore
if (!danfo)
    danfo = { build: { code: {} } };
else if (!danfo.build)
    danfo.build = { code: {} };
else if (!danfo.build.code)
    danfo.build.code = {};
danfo.build.code.defineAmd = function defineAmd() {
    /** @typedef {{ moduleName?: string, imports?: string[], exports?: any, moduleBody?: Function, initialized?: boolean }} ModuleInfo */
    /** @type {ModuleInfo[]} */
    var modules = [];
    /** @type {{ [moduleName: string]: ModuleInfo }} */
    var moduleByName = {};
    /**
     * @param {string=} moduleName
     * @param {string[]=} imports
     * @param {Function=} moduleBody
     */
    function define(moduleName, imports, moduleBody) {
        if (!moduleBody) {
            if (!imports) {
                moduleBody = /** @type {*} */ (moduleName);
                moduleName = void 0;
            }
            else {
                moduleBody = /** @type {*} */ (imports);
                imports = /** @type {*} */ (moduleName);
                moduleName = void 0;
            }
        }
        var mod = {
            moduleName: moduleName,
            imports: imports,
            moduleBody: moduleBody
        };
        if (typeof moduleName === 'string')
            modules.push(moduleByName[moduleName] = mod);
        else
            modules.push(mod);
    }
    define.amd = true;
    /**
     * @param {ModuleInfo} modInfo
     */
    function define_loadModule(modInfo) {
        modInfo.exports = {};
        var args = [];
        if (modInfo.imports) {
            for (var i = 0; i < modInfo.imports.length; i++) {
                var depModuleName = modInfo.imports[i];
                if (depModuleName === 'require')
                    args.push(module_require);
                else if (depModuleName === 'exports')
                    args.push(modInfo.exports);
                else {
                    var depModDesc = moduleByName[depModuleName];
                    args.push(depModDesc && (depModDesc.initialized ?
                        depModDesc.exports :
                        define_loadModule(depModDesc)));
                }
            }
        }
        modInfo.initialized = true;
        var result = /** @type {Function} */ (modInfo.moduleBody).apply(
        // @ts-ignore
        this, args);
        if (result) {
            for (var k in result) {
                modInfo.exports[k] = result[k];
            }
            modInfo.exports = result;
        }
        return modInfo.exports;
        /**
         * @param {string} moduleName
         */
        function module_require(moduleName) {
            // TODO: relative path calc
            return global_require(moduleName);
        }
    }
    /**
     * @param {string} moduleName
     */
    function global_require(moduleName) {
        var modDesc = moduleByName && moduleByName[moduleName];
        if (!modDesc) {
            if (typeof require === 'function')
                return require(moduleName);
            else
                throw new Error('Module not found: ' + moduleName + '.');
        }
        if (modDesc.initialized)
            return modDesc.exports;
        return define_loadModule(modDesc);
    }
    define.require = global_require;
    return define;
};
//# sourceMappingURL=danfo.js.map
